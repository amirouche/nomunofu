<h1 id="arew-scheme">arew-scheme</h1>
<p><a href="https://builds.sr.ht/~amz3/arew-scheme/.build.yml?"><img src="https://builds.sr.ht/~amz3/arew-scheme/.build.yml.svg" alt="builds.sr.ht status" /></a></p>
<p>Various libraries for Chez Scheme (R7RS, SRFI and more…)</p>
<p><a href="https://github.com/amirouche/arew-scheme"><img src="https://raw.githubusercontent.com/amirouche/arew-scheme/master/gabriel-sollmann-Y7d265_7i08-unsplash.jpg" alt="people walking in a library" /></a></p>
<h2 id="status">Status</h2>
<ul>
<li>[ ] SRFI-1: (scheme list) ???</li>
<li>[ ] SRFI-2: ???</li>
<li>[ ] SRFI-4: ???</li>
<li>[ ] SRFI-5: ???</li>
<li>[ ] SRFI-6: ???</li>
<li>[ ] SRFI-8: ???</li>
<li>[ ] SRFI-9: ???</li>
<li>[ ] SRFI-11: ???</li>
<li>[ ] SRFI-13: ???</li>
<li>[ ] SRFI-14: (scheme charset) ???</li>
<li>[ ] SRFI-16: ???</li>
<li>[ ] SRFI-17: ???</li>
<li>[ ] SRFI-19: ???</li>
<li>[ ] SRFI-23: ???</li>
<li>[ ] SRFI-25: missing</li>
<li>[ ] SRFI-26: missing doc</li>
<li>[ ] SRFI-27: missing</li>
<li>[ ] SRFI-28: missing tests</li>
<li>[ ] SRFI-29: missing tests, missing doc</li>
<li>[ ] SRFI-31: missing tests, missing doc</li>
<li>[ ] SRFI-34: missing tests, missing doc</li>
<li>[ ] SRFI-35: missing tests, missing doc</li>
<li>[ ] SRFI-37: missing tests, missing doc</li>
<li>[ ] SRFI-38: missing tests, missing doc</li>
<li>[ ] SRFI-39: missing doc</li>
<li>[ ] SRFI-41: (scheme stream) missing doc, missing tests</li>
<li>[ ] SRFI-42: missing doc, missing tests</li>
<li>[ ] SRFI-43: missing doc, missing tests</li>
<li>[ ] SRFI-45: missing doc, missing tests</li>
<li>[ ] SRFI-48: missing doc, missing tests</li>
<li>[ ] SRFI-51: missing doc, missing tests</li>
<li>[ ] SRFI-54: missing doc, missing tests</li>
<li>[ ] SRFI-60: missing doc, missing tests</li>
<li>[ ] SRFI-61: missing doc, missing tests</li>
<li>[ ] SRFI-64: no</li>
<li>[ ] SRFI-67: missing doc, missing tests</li>
<li>[ ] SRFI-69: missing doc, missing tests</li>
<li>[ ] SRFI-78: no</li>
<li>[ ] SRFI-98: missing doc, missing tests</li>
<li>[ ] SRFI-99: not yet</li>
<li>[ ] SRFI-101: (scheme rlist): missing doc, missing tests</li>
<li>[ ] SRFI-111: (scheme box): missing tests</li>
<li>[ ] SRFI-113: (scheme set): missing tests</li>
<li>[ ] SRFI-115: (scheme regex): not yet</li>
<li>[ ] SRFI-116: (scheme ilist): not yet</li>
<li>[ ] SRFI-117: (scheme list-queue): missing doc, missing tests</li>
<li>[ ] SRFI-124: (scheme ephemeron): missing doc, missing tests</li>
<li>[ ] SRFI-125: (scheme hash-table): missing tests</li>
<li>[ ] SRFI-126: not yet</li>
<li>[ ] SRFI-127: (scheme lseq): missing doc, missing tests</li>
<li>[ ] SRFI-128: (scheme comparator): missing tests</li>
<li>[ ] SRFI-129: not yet</li>
<li>[ ] SRFI-132: (scheme sort): not yet</li>
<li>[ ] SRFI-133: (scheme vector): not yet</li>
<li>[ ] SRFI-134: (scheme idque)</li>
<li>[ ] SRFI-135: (scheme text)</li>
<li>[ ] SRFI-141: (scheme division)</li>
<li>[ ] SRFI-143: (scheme fixnum)</li>
<li>[ ] SRFI-144: (scheme flonum)</li>
<li>[ ] SRFI-145</li>
<li>[ ] SRFI-146: (scheme mapping) and (scheme mapping hash)</li>
<li>[ ] SRFI-151: (scheme bitwise)</li>
<li>[ ] SRFI-152</li>
<li>[ ] SRFI-156</li>
<li>[ ] SRFI-158: (scheme generator)</li>
<li>[ ] SRFI-159: (scheme show)</li>
<li>[ ] SRFI-160: (scheme vector @)</li>
<li>[ ] SRFI-167</li>
<li>[ ] SRFI-168</li>
<li>[ ] SRFI-170</li>
<li>[ ] SRFI-173 ## <code>(srfi srfi-1)</code></li>
</ul>
<p>This is based on <a href="https://srfi.schemers.org/srfi-1/">SRFI-1</a>.</p>
<h3 id="abstract">Abstract</h3>
<p>TODO</p>
<h3 id="reference">Reference</h3>
<h4 id="constructors">Constructors</h4>
<h5 id="cons-a-d"><code>(cons a d)</code></h5>
<p>The primitive constructor. Returns a newly allocated pair whose <code>car</code> is <code>a</code> and whose <code>cdr</code> is <code>d</code>. The pair is guaranteed to be different (in the sense of <code>eqv?</code>) from every existing object.</p>
<h5 id="list-object-..."><code>(list object ...)</code></h5>
<p>Returns a newly allocated list of its arguments.</p>
<h5 id="xcons-d-a"><code>(xcons d a)</code></h5>
<div class="sourceCode" id="cb1"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb1-1" title="1">(<span class="kw">lambda</span> (d a) (<span class="kw">cons</span> a d))</a></code></pre></div>
<p>Of utility only as a value to be conveniently passed to higher-order procedures.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb2-1" title="1">(xcons &#39;(b c) &#39;a) <span class="co">;; =&gt; (a b c)</span></a></code></pre></div>
<p>The name stands for “eXchanged CONS.”</p>
<h5 id="cons-obj-...-tail"><code>(cons* obj ... tail)</code></h5>
<p>Like list, but the last argument provides the tail of the constructed list.</p>
<h5 id="make-list-n-fill"><code>(make-list n [fill])</code></h5>
<p>Returns an n-element list, whose elements are all the value fill. If the fill argument is not given, the elements of the list may be arbitrary values.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb3-1" title="1">(make-list <span class="dv">4</span> &#39;c) <span class="op">=&gt;</span> (c c c c)</a></code></pre></div>
<h5 id="list-tabulate-n-init-proc"><code>(list-tabulate n init-proc)</code></h5>
<p>Returns an n-element list. Element i of the list, where 0 &lt;= i &lt; n, is produced by (init-proc i). No guarantee is made about the dynamic order in which init-proc is applied to these indices.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb4-1" title="1">(list-tabulate <span class="dv">4</span> <span class="kw">values</span>) <span class="op">=&gt;</span> (<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)</a></code></pre></div>
<h5 id="list-copy-flist"><code>(list-copy flist)</code></h5>
<p>Copies the spine of the argument.</p>
<h5 id="circular-list-elt1-elt2-..."><code>(circular-list elt1 elt2 ...)</code></h5>
<p>Constructs a circular list of the elements.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb5-1" title="1">(circular-list &#39;z &#39;q) <span class="op">=&gt;</span> (z q z q z q ...)</a></code></pre></div>
<h5 id="iota-count-start-step"><code>(iota count [start step])</code></h5>
<p>Returns a list containing the elements:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb6-1" title="1">(start start+step ... start+(count<span class="dv">-1</span>)*step)</a></code></pre></div>
<p>The start and step parameters default to 0 and 1, respectively.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb7-1" title="1">(iota <span class="dv">5</span>) <span class="op">=&gt;</span> (<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>)</a>
<a class="sourceLine" id="cb7-2" title="2">(iota <span class="dv">5</span> <span class="dv">0</span> <span class="fl">-0.1</span>) <span class="op">=&gt;</span> (<span class="dv">0</span> <span class="fl">-0.1</span> <span class="fl">-0.2</span> <span class="fl">-0.3</span> <span class="fl">-0.4</span>)</a></code></pre></div>
<h4 id="predicates">Predicates</h4>
<h5 id="proper-list-x"><code>(proper-list? x)</code></h5>
<p>Returns true iff x is a proper list – a finite, nil-terminated list.</p>
<p>More carefully: The empty list is a proper list. A pair whose cdr is a proper list is also a proper list. The opposite of proper is improper.</p>
<h5 id="circular-list-x"><code>(circular-list? x)</code></h5>
<p>True if x is a circular list. A circular list is a value such that for every n &gt;= 0, cdrn(x) is a pair.</p>
<p>Terminology: The opposite of circular is finite.</p>
<h5 id="dotted-list-x">`(dotted-list? x)</h5>
<p>True if x is a finite, non-nil-terminated list. That is, there exists an n &gt;= 0 such that cdrn(x) is neither a pair nor (). This includes non-pair, non-() values (e.g. symbols, numbers), which are considered to be dotted lists of length 0.</p>
<h5 id="pair-obj"><code>(pair? obj)</code></h5>
<p>Returns #t if object is a pair; otherwise, #f.</p>
<h5 id="null-obj"><code>(null? obj)</code></h5>
<p>Returns #t if object is the empty list; otherwise, #f.</p>
<h5 id="null-list-list"><code>(null-list? list)</code></h5>
<p>List is a proper or circular list. This procedure returns true if the argument is the empty list (), and false otherwise. It is an error to pass this procedure a value which is not a proper or circular list. This procedure is recommended as the termination condition for list-processing procedures that are not defined on dotted lists.</p>
<h5 id="not-pair-x">`(not-pair? x)</h5>
<p>Provided as a procedure as it can be useful as the termination condition for list-processing procedures that wish to handle all finite lists, both proper and dotted.</p>
<h5 id="list-elt-list1-..."><code>(list= elt= list1 ...)</code></h5>
<p>Determines list equality, given an element-equality procedure.</p>
<h4 id="selectors">Selectors</h4>
<h5 id="car-pair">(car pair)</h5>
<h5 id="cdr-pair">(cdr pair)</h5>
<p>These functions return the contents of the car and cdr field of their argument, respectively. Note that it is an error to apply them to the empty list.</p>
<p>Also the following selectors are defined:</p>
<ul>
<li><code>caar</code></li>
<li><code>cadr</code></li>
<li><code>cdar</code></li>
<li><code>cddr</code></li>
<li><code>caaar</code></li>
<li><code>caadr</code></li>
<li><code>cadar</code></li>
<li><code>caddr</code></li>
<li><code>cdaar</code></li>
<li><code>cdadr</code></li>
<li><code>cddar</code></li>
<li><code>cdddr</code></li>
<li><code>caaaar</code></li>
<li><code>caaadr</code></li>
<li><code>caadar</code></li>
<li><code>caaddr</code></li>
<li><code>cadaar</code></li>
<li><code>cadadr</code></li>
<li><code>caddar</code></li>
<li><code>cadddr</code></li>
<li><code>cdaaar</code></li>
<li><code>cdaadr</code></li>
<li><code>cdadar</code></li>
<li><code>cdaddr</code></li>
<li><code>cddaar</code></li>
<li><code>cddadr</code></li>
<li><code>cdddar</code></li>
<li><code>cddddr</code></li>
</ul>
<h5 id="list-ref-clist-i"><code>(list-ref clist i)</code></h5>
<p>Returns the ith element of clist. (This is the same as the car of (drop clist i).) It is an error if i &gt;= n, where n is the length of clist.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb8-1" title="1">(<span class="kw">list-ref</span> &#39;(a b c d) <span class="dv">2</span>) <span class="op">=&gt;</span> c</a></code></pre></div>
<h5 id="first-pair"><code>(first pair)</code></h5>
<h5 id="second-pair"><code>(second pair)</code></h5>
<h5 id="third-pair"><code>(third pair)</code></h5>
<h5 id="fourth-pair"><code>(fourth pair)</code></h5>
<h5 id="fifth-pair"><code>(fifth pair)</code></h5>
<h5 id="sixth-pair"><code>(sixth pair)</code></h5>
<h5 id="seventh-pair"><code>(seventh pair)</code></h5>
<h5 id="eighth-pair"><code>(eighth pair)</code></h5>
<h5 id="ninth-pair"><code>(ninth pair)</code></h5>
<h5 id="tenth-pair"><code>(tenth pair)</code></h5>
<p>Synonyms for <code>car</code>, <code>cadr</code>, <code>caddr</code>, …</p>
<h5 id="carcdr-pair"><code>(car+cdr pair)</code></h5>
<p>The fundamental pair deconstructor:</p>
<pre><code>(lambda (p) (values (car p) (cdr p)))</code></pre>
<p>This can, of course, be implemented more efficiently by a compiler.</p>
<h5 id="take-lst-i"><code>(take lst i)</code></h5>
<h5 id="drop-lst-i"><code>(drop lst i)</code></h5>
<p><code>take</code> returns the first <code>I</code> elements of list <code>LST</code>. <code>drop</code> returns all but the first i elements of list <code>LST</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb10-1" title="1">(take &#39;(a b c d e) <span class="dv">2</span>) <span class="co">;; =&gt; (a b)</span></a>
<a class="sourceLine" id="cb10-2" title="2">(drop &#39;(a b c d e) <span class="dv">2</span>) <span class="co">;; =&gt; (c d e)</span></a></code></pre></div>
<p><code>LST</code> may be any value – a proper, circular, or dotted list:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb11-1" title="1">(take &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> . d) <span class="dv">2</span>) <span class="co">;; =&gt; (1 2)</span></a>
<a class="sourceLine" id="cb11-2" title="2">(drop &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> . d) <span class="dv">2</span>) <span class="co">;; =&gt; (3 . d)</span></a>
<a class="sourceLine" id="cb11-3" title="3">(take &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> . d) <span class="dv">3</span>) <span class="co">;; =&gt; (1 2 3)</span></a>
<a class="sourceLine" id="cb11-4" title="4">(drop &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> . d) <span class="dv">3</span>) <span class="co">;; =&gt; d</span></a></code></pre></div>
<p>For a legal <code>I</code>, <code>take</code> and <code>drop</code> partition the list in a manner which can be inverted with append:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb12-1" title="1">(<span class="kw">equal?</span> (<span class="kw">append</span> (take lst i) (drop x i)) lst)</a></code></pre></div>
<p><code>drop</code> is exactly equivalent to performing <code>i</code> <code>cdr</code> operations on <code>LST</code>; the returned value shares a common tail with <code>LST</code>. If the argument is a list of non-zero length, <code>take</code> is guaranteed to return a freshly-allocated list, even in the case where the entire list is taken, e.g. <code>(take lst (length lst))</code>.</p>
<h5 id="take-right-flist-i"><code>(take-right flist i)</code></h5>
<h5 id="drop-right-flist-i"><code>(drop-right flist i)</code></h5>
<p><code>take-right</code> returns the last <code>I</code> elements of <code>FLIST</code>. <code>drop-right</code> returns all but the last <code>I</code> elements of <code>FLIST</code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb13-1" title="1">(take-right &#39;(a b c d e) <span class="dv">2</span>) <span class="op">=&gt;</span> (d e)</a>
<a class="sourceLine" id="cb13-2" title="2">(drop-right &#39;(a b c d e) <span class="dv">2</span>) <span class="op">=&gt;</span> (a b c)</a></code></pre></div>
<p>The returned list may share a common tail with the argument list.</p>
<p><code>FLIST</code> may be any finite list, either proper or dotted:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb14-1" title="1">(take-right &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> . d) <span class="dv">2</span>) <span class="op">=&gt;</span> (<span class="dv">2</span> <span class="dv">3</span> . d)</a>
<a class="sourceLine" id="cb14-2" title="2">(drop-right &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> . d) <span class="dv">2</span>) <span class="op">=&gt;</span> (<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb14-3" title="3">(take-right &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> . d) <span class="dv">0</span>) <span class="op">=&gt;</span> d</a>
<a class="sourceLine" id="cb14-4" title="4">(drop-right &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> . d) <span class="dv">0</span>) <span class="op">=&gt;</span> (<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)</a></code></pre></div>
<p>For a legal <code>I</code>, <code>take-right</code> and <code>drop-right</code> partition the list in a manner which can be inverted with <code>append</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb15-1" title="1">(<span class="kw">equal?</span> (<span class="kw">append</span> (take flist i) (drop flist i)) flist)</a></code></pre></div>
<p><code>take-right</code>’s return value is guaranteed to share a common tail with <code>FLIST</code>. If the argument is a list of non-zero length, <code>drop-right</code> is guaranteed to return a freshly-allocated list, even in the case where nothing is dropped, e.g. <code>(drop-right flist 0)</code>.</p>
<h5 id="take-x-i"><code>(take! x i)</code></h5>
<h5 id="drop-right-flist-i-1"><code>(drop-right! flist i)</code></h5>
<p><code>take!</code> and <code>drop-right!</code> are “linear-update” variants of <code>take</code> and <code>drop-right</code>: the procedure is allowed, but not required, to alter the argument list to produce the result.</p>
<p>If <code>x</code> is circular, <code>take!</code> may return a shorter-than-expected list:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb16-1" title="1">(take! (circular-list <span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span>) <span class="dv">8</span>) <span class="op">=&gt;</span> (<span class="dv">1</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb16-2" title="2">(take! (circular-list <span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span>) <span class="dv">8</span>) <span class="op">=&gt;</span> (<span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">1</span> <span class="dv">3</span>)</a></code></pre></div>
<h5 id="split-at-x-i"><code>(split-at  x i)</code></h5>
<h5 id="split-at-x-i-1"><code>(split-at! x i)</code></h5>
<p><code>split-at</code> splits the list <code>x</code> at index <code>i</code>, returning a list of the first <code>i</code> elements, and the remaining tail. It is equivalent to:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb17-1" title="1">(<span class="kw">values</span> (take x i) (drop x i))</a></code></pre></div>
<p><code>split-at!</code> is the linear-update variant. It is allowed, but not required, to alter the argument list to produce the result.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb18-1" title="1">(split-at &#39;(a b c d e f g h) <span class="dv">3</span>) <span class="co">;; =&gt; (a b c) and (d e f g h)</span></a></code></pre></div>
<h5 id="last-pair"><code>(last pair)</code></h5>
<h5 id="last-pair-pair"><code>(last-pair pair)</code></h5>
<p><code>last</code> returns the last element of the non-empty, finite list <code>pair</code>. <code>last-pair</code> returns the last pair in the non-empty, finite list <code>pair</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb19-1" title="1">(last &#39;(a b c)) <span class="co">;; =&gt; c</span></a>
<a class="sourceLine" id="cb19-2" title="2">(last-pair &#39;(a b c)) <span class="co">;; =&gt; (c)</span></a></code></pre></div>
<h4 id="miscellaneous">Miscellaneous</h4>
<h5 id="length-list"><code>(length list)</code></h5>
<h5 id="length-clist"><code>(length+ clist)</code></h5>
<p>Both <code>length</code> and <code>length+</code> return the length of the argument. It is an error to pass a value to length which is not a proper list (finite and nil-terminated). In particular, this means an implementation may diverge or signal an error when length is applied to a circular list.</p>
<p><code>length+</code>, on the other hand, returns <code>#f</code> when applied to a circular list.</p>
<p>The length of a proper list is a non-negative integer <code>n</code> such that <code>cdr</code> applied <code>n</code> times to the list produces the empty list.</p>
<h5 id="append-list1-..."><code>(append  list1 ...)</code></h5>
<h5 id="append-list1-...-1"><code>(append! list1 ...)</code></h5>
<p><code>append</code> returns a list consisting of the elements of <code>list1</code> followed by the elements of the other list parameters.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb20-1" title="1">(<span class="kw">append</span> &#39;(x) &#39;(y))        <span class="op">=&gt;</span>  (x y)</a>
<a class="sourceLine" id="cb20-2" title="2">(<span class="kw">append</span> &#39;(a) &#39;(b c d))    <span class="op">=&gt;</span>  (a b c d)</a>
<a class="sourceLine" id="cb20-3" title="3">(<span class="kw">append</span> &#39;(a (b)) &#39;((c)))  <span class="op">=&gt;</span>  (a (b) (c))</a></code></pre></div>
<p>The resulting list is always newly allocated, except that it shares structure with the final list argument. This last argument may be any value at all; an improper list results if it is not a proper list. All other arguments must be proper lists.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb21-1" title="1">(<span class="kw">append</span> &#39;(a b) &#39;(c . d))  <span class="op">=&gt;</span>  (a b c . d)</a>
<a class="sourceLine" id="cb21-2" title="2">(<span class="kw">append</span> &#39;() &#39;a)           <span class="op">=&gt;</span>  a</a>
<a class="sourceLine" id="cb21-3" title="3">(<span class="kw">append</span> &#39;(x y))           <span class="op">=&gt;</span>  (x y)</a>
<a class="sourceLine" id="cb21-4" title="4">(<span class="kw">append</span>)                  <span class="op">=&gt;</span>  ()</a></code></pre></div>
<p><code>append!</code> is the “linear-update” variant of append – it is allowed, but not required, to alter <code>cons</code> cells in the argument lists to construct the result list. The last argument is never altered; the result list shares structure with this parameter.</p>
<h5 id="concatenate-list-of-lists"><code>(concatenate  list-of-lists)</code></h5>
<h5 id="concatenate-list-of-lists-1"><code>(concatenate! list-of-lists)</code></h5>
<p>These functions append the elements of their argument together. That is, <code>concatenate</code> returns:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb22-1" title="1">(apply <span class="kw">append</span> list-of-lists)</a></code></pre></div>
<p>Or, equivalently,</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb23-1" title="1">(reduce-right <span class="kw">append</span> &#39;() list-of-lists)</a></code></pre></div>
<p><code>concatenate!</code> is the linear-update variant, defined in terms of <code>append!</code> instead of <code>append</code>.</p>
<p>As with <code>append</code> and <code>append!</code>, the last element of the input list may be any value at all.</p>
<h5 id="reverse-list"><code>(reverse list)</code></h5>
<h5 id="reverse-list-1"><code>(reverse! list)</code></h5>
<p><code>reverse</code> returns a newly allocated list consisting of the elements of list in reverse order.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb24-1" title="1">(<span class="kw">reverse</span> &#39;(a b c)) <span class="co">;; =&gt;  (c b a)</span></a>
<a class="sourceLine" id="cb24-2" title="2">(<span class="kw">reverse</span> &#39;(a (b c) d (e (f)))) <span class="co">;; =&gt;  ((e (f)) d (b c) a)</span></a></code></pre></div>
<p><code>reverse!</code> is the linear-update variant of reverse. It is permitted, but not required, to alter the argument’s <code>cons</code> cells to produce the reversed list.</p>
<h5 id="append-reverse-rev-head-tail"><code>(append-reverse rev-head tail)</code></h5>
<h5 id="append-reverse-rev-head-tail-1"><code>(append-reverse! rev-head tail)</code></h5>
<p><code>append-reverse</code> returns <code>(append (reverse rev-head) tail)</code>. It is provided because it is a common operation – a common list-processing style calls for this exact operation to transfer values accumulated in reverse order onto the front of another list, and because the implementation is significantly more efficient than the simple composition it replaces. (But note that this pattern of iterative computation followed by a <code>reverse</code> can frequently be rewritten as a recursion, dispensing with the <code>reverse</code> and <code>append-reverse</code> steps, and shifting temporary, intermediate storage from the heap to the stack, which is typically a win for reasons of cache locality and eager storage reclamation.)</p>
<p><code>append-reverse!</code> is just the linear-update variant – it is allowed, but not required, to alter rev-head’s <code>cons</code> cells to construct the result.</p>
<h5 id="zip-clist1-clist2-..."><code>(zip clist1 clist2 ...)</code></h5>
<div class="sourceCode" id="cb25"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb25-1" title="1">(<span class="kw">lambda</span> lists (apply map <span class="kw">list</span> lists))</a></code></pre></div>
<p>If <code>zip</code> is passed n lists, it returns a list as long as the shortest of these lists, each element of which is an n-element list comprised of the corresponding elements from the parameter lists.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb26-1" title="1">(zip &#39;(one two three)</a>
<a class="sourceLine" id="cb26-2" title="2">     &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb26-3" title="3">     &#39;(odd even odd even odd even odd even))</a>
<a class="sourceLine" id="cb26-4" title="4">     <span class="co">;; =&gt; ((one 1 odd) (two 2 even) (three 3 odd))</span></a>
<a class="sourceLine" id="cb26-5" title="5"></a>
<a class="sourceLine" id="cb26-6" title="6">(zip &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)) <span class="op">=&gt;</span> ((<span class="dv">1</span>) (<span class="dv">2</span>) (<span class="dv">3</span>))</a></code></pre></div>
<h5 id="unzip1-list"><code>(unzip1 list)</code></h5>
<h5 id="unzip2-list"><code>(unzip2 list)</code></h5>
<h5 id="unzip3-list"><code>(unzip3 list)</code></h5>
<h5 id="unzip4-list"><code>(unzip4 list)</code></h5>
<h5 id="unzip5-list"><code>(unzip5 list)</code></h5>
<p><code>unzip1</code> takes a list of lists, where every list must contain at least one element, and returns a list containing the initial element of each such list. That is, it returns <code>(map car lists)</code>. <code>unzip2</code> takes a list of lists, where every list must contain at least two elements, and returns two values: a list of the first elements, and a list of the second elements. <code>unzip3</code> does the same for the first three elements of the lists, and so forth.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb27-1" title="1">(unzip2 &#39;((<span class="dv">1</span> one) (<span class="dv">2</span> two) (<span class="dv">3</span> three))) <span class="co">;; =&gt; &#39;((1 2 3) (one two three))</span></a></code></pre></div>
<h5 id="count-pred-clist1-..."><code>(count pred clist1 ...)</code></h5>
<p><code>pred</code> is a procedure taking as many arguments as there are lists and returning a single value. It is applied element-wise to the elements of the lists, and a count is tallied of the number of elements that produce a true value. This count is returned. <code>count</code> is “iterative” in that it is guaranteed to apply <code>pred</code> to the list elements in a left-to-right order. The counting stops when the shortest list expires.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb28-1" title="1">(count <span class="kw">even?</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span> <span class="dv">5</span> <span class="dv">6</span>)) <span class="op">=&gt;</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb28-2" title="2">(count <span class="op">&lt;</span> &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">4</span> <span class="dv">8</span>) &#39;(<span class="dv">2</span> <span class="dv">4</span> <span class="dv">6</span> <span class="dv">8</span> <span class="dv">10</span> <span class="dv">12</span> <span class="dv">14</span> <span class="dv">16</span>)) <span class="op">=&gt;</span> <span class="dv">3</span></a></code></pre></div>
<p>At least one of the argument lists must be finite:</p>
<pre><code>(count &lt; &#39;(3 1 4 1) (circular-list 1 10)) =&gt; 2</code></pre>
<h4 id="fold-unfold-map">Fold, unfold &amp; map</h4>
<h5 id="fold-kons-knil-list1-..."><code>(fold kons knil list1 ...)</code></h5>
<p>TODO</p>
<h5 id="fold-right-kons-knil-list1-..."><code>(fold-right kons knil list1 ...)</code></h5>
<p>TODO</p>
<h5 id="pair-fold-kons-knil-list1-..."><code>(pair-fold kons knil list1 ...)</code></h5>
<p>TODO</p>
<h5 id="pair-fold-right-kons-knil-list1-..."><code>(pair-fold-right kons knil list1 ...)</code></h5>
<p>TODO</p>
<h5 id="reduce-f-ridentity-list"><code>(reduce f ridentity list)</code></h5>
<p><code>reduce</code> is a variant of <code>fold</code>.</p>
<p><code>ridentity</code> should be a “right identity” of the procedure <code>f</code> – that is, for any value <code>x</code> acceptable to <code>f</code>:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb30-1" title="1">(f x ridentity) <span class="co">;; =&gt; x</span></a></code></pre></div>
<p>Note: that <code>ridentity</code> is used only in the empty-list case. You typically use reduce when applying <code>f</code> is expensive and you’d like to avoid the extra application incurred when fold applies <code>f</code> to the head of list and the identity value, redundantly producing the same value passed in to <code>f</code>. For example, if <code>f</code> involves searching a file directory or performing a database query, this can be significant. In general, however, <code>fold</code> is useful in many contexts where <code>reduce</code> is not (consider the examples given in the <code>fold</code> definition – only one of the five folds uses a function with a right identity. The other four may not be performed with reduce).</p>
<h5 id="reducse-right-f-ridentity-list"><code>(reducse-right f ridentity list)</code></h5>
<p><code>reduce-right</code> is the <code>fold-right</code> variant of reduce. It obeys the following definition:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb31-1" title="1">(reduce-right f ridentity &#39;()) <span class="op">=</span> ridentity</a>
<a class="sourceLine" id="cb31-2" title="2">(reduce-right f ridentity &#39;(e1)) <span class="op">=</span> (f e1 ridentity) <span class="op">=</span> e1</a>
<a class="sourceLine" id="cb31-3" title="3">(reduce-right f ridentity &#39;(e1 e2 ...)) <span class="op">=</span></a>
<a class="sourceLine" id="cb31-4" title="4">    (f e1 (reduce f ridentity (e2 ...)))</a></code></pre></div>
<p>… in other words, we compute <code>(fold-right f ridentity list)</code>.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb32-1" title="1"><span class="co">;; Append a bunch of lists together.</span></a>
<a class="sourceLine" id="cb32-2" title="2"><span class="co">;; I.e., (apply append list-of-lists)</span></a>
<a class="sourceLine" id="cb32-3" title="3">(reduce-right <span class="kw">append</span> &#39;() list-of-lists)</a></code></pre></div>
<h5 id="unfold-p-f-g-seed-tail-gen"><code>(unfold p f g seed [tail-gen])</code></h5>
<p>TODO</p>
<h5 id="unfold-right-p-f-g-seed-tail-gen"><code>(unfold-right p f g seed [tail-gen])</code></h5>
<p>TODO</p>
<h5 id="map-proc-list1-..."><code>(map proc list1 ...)</code></h5>
<p><code>proc</code> is a procedure taking as many arguments as there are list arguments and returning a single value. map applies <code>proc</code> element-wise to the elements of the lists and returns a list of the results, in order. The dynamic order in which proc is applied to the elements of the lists is unspecified.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb33-1" title="1">(map <span class="kw">cadr</span> &#39;((a b) (d e) (g h))) <span class="op">=&gt;</span>  (b e h)</a>
<a class="sourceLine" id="cb33-2" title="2"></a>
<a class="sourceLine" id="cb33-3" title="3">(map (<span class="kw">lambda</span> (n) (<span class="kw">expt</span> n n))</a>
<a class="sourceLine" id="cb33-4" title="4">     &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>))</a>
<a class="sourceLine" id="cb33-5" title="5">    <span class="op">=&gt;</span>  (<span class="dv">1</span> <span class="dv">4</span> <span class="dv">27</span> <span class="dv">256</span> <span class="dv">3125</span>)</a>
<a class="sourceLine" id="cb33-6" title="6"></a>
<a class="sourceLine" id="cb33-7" title="7">(map <span class="op">+</span> &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>) &#39;(<span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>)) <span class="op">=&gt;</span>  (<span class="dv">5</span> <span class="dv">7</span> <span class="dv">9</span>)</a>
<a class="sourceLine" id="cb33-8" title="8"></a>
<a class="sourceLine" id="cb33-9" title="9">(<span class="kw">let</span> ((count <span class="dv">0</span>))</a>
<a class="sourceLine" id="cb33-10" title="10">  (map (<span class="kw">lambda</span> (ignored)</a>
<a class="sourceLine" id="cb33-11" title="11">         (set! count (<span class="op">+</span> count <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb33-12" title="12">         count)</a>
<a class="sourceLine" id="cb33-13" title="13">       &#39;(a b))) <span class="op">=&gt;</span>  (<span class="dv">1</span> <span class="dv">2</span>) <span class="kw">or</span> (<span class="dv">2</span> <span class="dv">1</span>)</a></code></pre></div>
<p>At least one of the argument lists must be finite:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb34-1" title="1">(map <span class="op">+</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span>) (circular-list <span class="dv">1</span> <span class="dv">0</span>)) <span class="co">;; =&gt; (4 1 5 1)</span></a></code></pre></div>
<h5 id="for-each-proc-clist1-..."><code>(for-each proc clist1 ...)</code></h5>
<p>The arguments to <code>for-each</code> are like the arguments to <code>map</code>, but <code>for-each</code> calls <code>proc</code> for its side effects rather than for its values. Unlike <code>map</code>, <code>for-each</code> is guaranteed to call <code>proc</code> on the elements of the lists in order from the first element(s) to the last, and the value returned by for-each is unspecified.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb35-1" title="1">(<span class="kw">let</span> ((v (<span class="kw">make-vector</span> <span class="dv">5</span>)))</a>
<a class="sourceLine" id="cb35-2" title="2">  (<span class="kw">for-each</span> (<span class="kw">lambda</span> (i)</a>
<a class="sourceLine" id="cb35-3" title="3">              (<span class="kw">vector-set!</span> v i (* i i)))</a>
<a class="sourceLine" id="cb35-4" title="4">            &#39;(<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>))</a>
<a class="sourceLine" id="cb35-5" title="5">  v)  <span class="op">=&gt;</span>  #(<span class="dv">0</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">9</span> <span class="dv">16</span>)</a></code></pre></div>
<p>At least one of the argument lists must be finite.</p>
<h5 id="append-map-f-list-..."><code>(append-map f list ...)</code></h5>
<h5 id="append-map-f-list-...-1"><code>(append-map! f list ...)</code></h5>
<p>Equivalent to:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb36-1" title="1">(apply <span class="kw">append</span> (map f clist1 clist2 ...))</a></code></pre></div>
<p>And:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb37-1" title="1">(apply append! (map f clist1 clist2 ...))</a></code></pre></div>
<p>Map <code>f</code> over the elements of the lists, just as in the <code>map</code> function. However, the results of the applications are appended together to make the final result. <code>append-map</code> uses <code>append</code> to append the results together; <code>append-map!</code> uses <code>append!</code>.</p>
<p>The dynamic order in which the various applications of <code>f</code> are made is not specified.</p>
<p>Example:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb38-1" title="1">(append-map! (<span class="kw">lambda</span> (x) (<span class="kw">list</span> x (<span class="op">-</span> x))) &#39;(<span class="dv">1</span> <span class="dv">3</span> <span class="dv">8</span>)) <span class="co">;; =&gt; (1 -1 3 -3 8 -8)</span></a></code></pre></div>
<p>At least one of the list arguments must be finite.</p>
<h5 id="map-f-list1-..."><code>(map! f list1 ...)</code></h5>
<p>Linear-update variant of <code>map</code> – <code>map!</code> is allowed, but not required, to alter the cons cells of <code>list1</code> to construct the result list.</p>
<p>The dynamic order in which the various applications of <code>f</code> are made is not specified. In the n-ary case, <code>clist2</code>, <code>clist3</code>, … must have at least as many elements as <code>list1</code>.</p>
<h5 id="map-in-order-f-clist1-..."><code>(map-in-order f clist1 ...)</code></h5>
<p>A variant of the map procedure that guarantees to apply <code>f</code> across the elements of the <code>clisti</code> arguments in a left-to-right order. This is useful for mapping procedures that both have side effects and return useful values.</p>
<p>At least one of the list arguments must be finite.</p>
<h5 id="pair-for-each-f-clist1-..."><code>(pair-for-each f clist1 ...)</code></h5>
<p>Like for-each, but <code>f</code> is applied to successive sublists of the argument lists. That is, <code>f</code> is applied to the <code>cons</code> cells of the lists, rather than the lists’ elements. These applications occur in left-to-right order.</p>
<p>The f procedure may reliably apply <code>set-cdr!</code> to the pairs it is given without altering the sequence of execution.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb39-1" title="1">(pair-for-each (<span class="kw">lambda</span> (pair) (<span class="kw">display</span> pair) (<span class="kw">newline</span>)) &#39;(a b c))</a>
<a class="sourceLine" id="cb39-2" title="2"> <span class="co">;; =&gt; (a b c)</span></a>
<a class="sourceLine" id="cb39-3" title="3"> <span class="co">;; =&gt; (b c)</span></a>
<a class="sourceLine" id="cb39-4" title="4"> <span class="co">;; =&gt; (c)</span></a></code></pre></div>
<p>At least one of the list arguments must be finite.</p>
<h5 id="filter-map-f-clist1-..."><code>(filter-map f clist1 ...)</code></h5>
<p>Like <code>map</code>, but only true values are saved.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb40-1" title="1">(filter-map (<span class="kw">lambda</span> (x) (<span class="kw">and</span> (<span class="kw">number?</span> x) (* x x))) &#39;(a <span class="dv">1</span> b <span class="dv">3</span> c <span class="dv">7</span>))</a>
<a class="sourceLine" id="cb40-2" title="2">    <span class="co">;; =&gt; (1 9 49)</span></a></code></pre></div>
<p>The dynamic order in which the various applications of <code>f</code> are made is not specified.</p>
<p>At least one of the list arguments must be finite.</p>
<h4 id="filtering-partitioning">Filtering &amp; partitioning</h4>
<h5 id="filter-pred-list"><code>(filter pred list)</code></h5>
<p>Return all the elements of list that satisfy predicate <code>pred</code>. The list is not disordered – elements that appear in the result list occur in the same order as they occur in the argument list. The returned list may share a common tail with the argument list. The dynamic order in which the various applications of <code>pred</code> are made is not specified.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb41-1" title="1">(filter <span class="kw">even?</span> &#39;(<span class="dv">0</span> <span class="dv">7</span> <span class="dv">8</span> <span class="dv">8</span> <span class="dv">43</span> <span class="dv">-4</span>)) <span class="op">=&gt;</span> (<span class="dv">0</span> <span class="dv">8</span> <span class="dv">8</span> <span class="dv">-4</span>)</a></code></pre></div>
<h5 id="partition-pred-list"><code>(partition pred list)</code></h5>
<p>Partitions the elements of list with predicate <code>pred</code>, and returns two values: the list of in-elements and the list of out-elements. The list is not disordered – elements occur in the result lists in the same order as they occur in the argument list. The dynamic order in which the various applications of pred are made is not specified. One of the returned lists may share a common tail with the argument list.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb42-1" title="1">(partition <span class="kw">symbol?</span> &#39;(one <span class="dv">2</span> <span class="dv">3</span> four five <span class="dv">6</span>)) <span class="op">=&gt;</span></a>
<a class="sourceLine" id="cb42-2" title="2">    (one four five)</a>
<a class="sourceLine" id="cb42-3" title="3">    (<span class="dv">2</span> <span class="dv">3</span> <span class="dv">6</span>)</a></code></pre></div>
<h5 id="remove-pred-list"><code>(remove pred list)</code></h5>
<p>Returns <code>list</code> without the elements that satisfy predicate <code>pred</code>:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb43-1" title="1">(<span class="kw">lambda</span> (pred <span class="kw">list</span>) (filter (<span class="kw">lambda</span> (x) (<span class="kw">not</span> (pred x))) <span class="kw">list</span>))</a></code></pre></div>
<p>The <code>list</code> is not disordered – elements that appear in the result list occur in the same order as they occur in the argument list. The returned list may share a common tail with the argument list. The dynamic order in which the various applications of <code>pred</code> are made is not specified.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb44-1" title="1">(remove <span class="kw">even?</span> &#39;(<span class="dv">0</span> <span class="dv">7</span> <span class="dv">8</span> <span class="dv">8</span> <span class="dv">43</span> <span class="dv">-4</span>)) <span class="op">=&gt;</span> (<span class="dv">7</span> <span class="dv">43</span>)</a></code></pre></div>
<h5 id="filter-pred-list-1"><code>(filter! pred list)</code></h5>
<h5 id="partition-pred-list-1"><code>(partition! pred list)</code></h5>
<h5 id="remove-pred-list-1"><code>(remove! pred list)</code></h5>
<p>Linear-update variants of <code>filter</code>, <code>partition</code> and <code>remove</code>. These procedures are allowed, but not required, to alter the cons cells in the argument list to construct the result lists.</p>
<h4 id="searching">Searching</h4>
<h5 id="find-pred-clist"><code>(find pred clist)</code></h5>
<p>Return the first element of clist that satisfies predicate <code>pred</code>; false if no element does.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb45-1" title="1">(find <span class="kw">even?</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span>)) <span class="op">=&gt;</span> <span class="dv">4</span></a></code></pre></div>
<p>Note that <code>find</code> has an ambiguity in its lookup semantics – if <code>find</code> returns <code>#f</code>, you cannot tell (in general) if it found a #f element that satisfied <code>pred</code>, or if it did not find any element at all. In many situations, this ambiguity cannot arise – either the list being searched is known not to contain any <code>#f</code> elements, or the list is guaranteed to have an element satisfying <code>pred</code>. However, in cases where this ambiguity can arise, you should use <code>find-tail</code> instead of find – <code>find-tail</code> has no such ambiguity.</p>
<h5 id="find-tail-pred-clist"><code>(find-tail pred clist)</code></h5>
<p>Return the first pair of <code>clist</code> whose <code>car</code> satisfies <code>pred</code>. If no pair does, return false.</p>
<p><code>find-tail</code> can be viewed as a general-predicate variant of the member function.</p>
<p>Examples:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb46-1" title="1">(find-tail <span class="kw">even?</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">37</span> <span class="dv">-8</span> <span class="dv">-5</span> <span class="dv">0</span> <span class="dv">0</span>)) <span class="op">=&gt;</span> (-<span class="dv">8</span> <span class="dv">-5</span> <span class="dv">0</span> <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb46-2" title="2">(find-tail <span class="kw">even?</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">37</span> <span class="dv">-5</span>)) <span class="op">=&gt;</span> <span class="dv">#f</span></a>
<a class="sourceLine" id="cb46-3" title="3"></a>
<a class="sourceLine" id="cb46-4" title="4"><span class="co">;; MEMBER X LIS:</span></a>
<a class="sourceLine" id="cb46-5" title="5">(find-tail (<span class="kw">lambda</span> (elt) (<span class="kw">equal?</span> x elt)) lis)</a></code></pre></div>
<p>In the circular-list case, this procedure “rotates” the list.</p>
<p><code>find-tail</code> is essentially drop-while, where the sense of the predicate is inverted: <code>find-tail</code> searches until it finds an element satisfying the predicate; drop-while searches until it finds an element that doesn’t satisfy the predicate.</p>
<h5 id="take-while-pred-clist"><code>(take-while  pred clist)</code></h5>
<h5 id="take-while-pred-clist-1"><code>(take-while! pred clist)</code></h5>
<p>Returns the longest initial prefix of <code>clist</code> whose elements all satisfy the predicate <code>pred</code>.</p>
<p><code>take-while!</code> is the linear-update variant. It is allowed, but not required, to alter the argument list to produce the result.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb47-1" title="1">(take-while <span class="kw">even?</span> &#39;(<span class="dv">2</span> <span class="dv">18</span> <span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)) <span class="op">=&gt;</span> (<span class="dv">2</span> <span class="dv">18</span>)</a></code></pre></div>
<h5 id="drop-while-pred-clist"><code>(drop-while pred clist)</code></h5>
<p>Drops the longest initial prefix of <code>clist</code> whose elements all satisfy the predicate <code>pred</code>, and returns the rest of the list.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb48-1" title="1">(drop-while <span class="kw">even?</span> &#39;(<span class="dv">2</span> <span class="dv">18</span> <span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)) <span class="op">=&gt;</span> (<span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)</a></code></pre></div>
<p>The circular-list case may be viewed as “rotating” the list.</p>
<h5 id="span-pred-clist"><code>(span pred clist)</code></h5>
<h5 id="span-pred-list"><code>(span!  pred list)</code></h5>
<h5 id="break-pred-clist"><code>(break  pred clist)</code></h5>
<h5 id="break-pred-list">`(break! pred list)</h5>
<p>Span splits the list into the longest initial prefix whose elements all satisfy <code>pred</code>, and the remaining tail. Break inverts the sense of the predicate: the tail commences with the first element of the input list that satisfies the predicate.</p>
<p>In other words: <code>span</code> finds the intial span of elements satisfying <code>pred</code>, and break breaks the list at the first element satisfying <code>pred</code>.</p>
<p>Span is equivalent to</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb49-1" title="1">(<span class="kw">values</span> (take-while pred clist)</a>
<a class="sourceLine" id="cb49-2" title="2">        (drop-while pred clist))</a></code></pre></div>
<p><code>span!</code> and <code>break!</code> are the linear-update variants. They are allowed, but not required, to alter the argument list to produce the result.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb50-1" title="1">(span <span class="kw">even?</span> &#39;(<span class="dv">2</span> <span class="dv">18</span> <span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)) <span class="op">=&gt;</span></a>
<a class="sourceLine" id="cb50-2" title="2">      (<span class="dv">2</span> <span class="dv">18</span>)</a>
<a class="sourceLine" id="cb50-3" title="3">      (<span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)</a>
<a class="sourceLine" id="cb50-4" title="4"></a>
<a class="sourceLine" id="cb50-5" title="5">(<span class="kw">break</span> <span class="kw">even?</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span>)) <span class="op">=&gt;</span></a>
<a class="sourceLine" id="cb50-6" title="6">      (<span class="dv">3</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb50-7" title="7">      (<span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span>)</a></code></pre></div>
<h5 id="any-pred-clist1-..."><code>(any pred clist1 ...)</code></h5>
<p>Applies the predicate across the lists, returning true if the predicate returns true on any application.</p>
<p>If there are n list arguments <code>clist1 ... clistn</code>, then <code>pred</code> must be a procedure taking n arguments and returning a single value, interpreted as a boolean (that is, <code>#f</code> means false, and any other value means true).</p>
<p><code>any</code> applies <code>pred</code> to the first elements of the <code>clisti</code> parameters. If this application returns a true value, any immediately returns that value. Otherwise, it iterates, applying <code>pred</code> to the second elements of the <code>clisti</code> parameters, then the third, and so forth. The iteration stops when a true value is produced or one of the lists runs out of values; in the latter case, any returns <code>#f</code>. The application of pred to the last element of the lists is a tail call.</p>
<p>Note the difference between <code>find</code> and <code>any</code> – <code>find</code> returns the element that satisfied the predicate; <code>any</code> returns the true value that the predicate produced.</p>
<p>Like <code>every</code>, <code>any</code>’s name does not end with a question mark – this is to indicate that it does not return a simple boolean (#t or #f), but a general value.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb51-1" title="1">(any <span class="kw">integer?</span> &#39;(a <span class="dv">3</span> b <span class="fl">2.7</span>))   <span class="op">=&gt;</span> <span class="dv">#t</span></a>
<a class="sourceLine" id="cb51-2" title="2">(any <span class="kw">integer?</span> &#39;(a <span class="fl">3.1</span> b <span class="fl">2.7</span>)) <span class="op">=&gt;</span> <span class="dv">#f</span></a>
<a class="sourceLine" id="cb51-3" title="3">(any <span class="op">&lt;</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span>)</a>
<a class="sourceLine" id="cb51-4" title="4">           &#39;(<span class="dv">2</span> <span class="dv">7</span> <span class="dv">1</span> <span class="dv">8</span> <span class="dv">2</span>)) <span class="op">=&gt;</span> <span class="dv">#t</span></a></code></pre></div>
<h5 id="every-pred-clist1-..."><code>(every pred clist1 ...)</code></h5>
<p>Applies the predicate across the lists, returning true if the predicate returns true on every application.</p>
<p>If there are n list arguments <code>clist1 ... clistn</code>, then <code>pred</code> must be a procedure taking n arguments and returning a single value, interpreted as a boolean (that is, #f means false, and any other value means true).</p>
<p><code>every</code> applies <code>pred</code> to the first elements of the <code>clisti</code> parameters. If this application returns false, every immediately returns false. Otherwise, it iterates, applying <code>pred</code> to the second elements of the <code>clisti</code> parameters, then the third, and so forth. The iteration stops when a false value is produced or one of the lists runs out of values. In the latter case, <code>every</code> returns the true value produced by its final application of pred. The application of <code>pred</code> to the last element of the lists is a tail call.</p>
<p>If one of the <code>clisti</code> has no elements, <code>every</code> simply returns #t.</p>
<p>Like <code>any</code>, <code>every</code>’s name does not end with a question mark – this is to indicate that it does not return a simple boolean (<code>#t</code> or <code>#f</code>), but a general value.</p>
<h5 id="list-index-pred-clist1-..."><code>(list-index pred clist1 ...)</code></h5>
<p>Return the index of the leftmost element that satisfies <code>pred</code>.</p>
<p>If there are n list arguments <code>clist1 ... clistn</code>, then <code>pred</code> must be a function taking n arguments and returning a single value, interpreted as a boolean (that is, <code>#f</code> means false, and any other value means true).</p>
<p><code>list-index</code> applies <code>pred</code> to the first elements of the <code>clisti</code> parameters. If this application returns true, <code>list-index</code> immediately returns zero. Otherwise, it iterates, applying <code>pred</code> to the second elements of the <code>clisti</code> parameters, then the third, and so forth. When it finds a tuple of list elements that cause <code>pred</code> to return true, it stops and returns the zero-based index of that position in the lists.</p>
<p>The iteration stops when one of the lists runs out of values; in this case, <code>list-index</code> returns <code>#f</code>.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb52-1" title="1">(list-index <span class="kw">even?</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span>)) <span class="op">=&gt;</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb52-2" title="2">(list-index <span class="op">&lt;</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span> <span class="dv">5</span> <span class="dv">6</span>) &#39;(<span class="dv">2</span> <span class="dv">7</span> <span class="dv">1</span> <span class="dv">8</span> <span class="dv">2</span>)) <span class="op">=&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb52-3" title="3">(list-index <span class="op">=</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span> <span class="dv">5</span> <span class="dv">6</span>) &#39;(<span class="dv">2</span> <span class="dv">7</span> <span class="dv">1</span> <span class="dv">8</span> <span class="dv">2</span>)) <span class="op">=&gt;</span> <span class="dv">#f</span></a></code></pre></div>
<h5 id="member-x-list"><code>(member x list [=])</code></h5>
<h5 id="memq-x-list"><code>(memq x list)</code></h5>
<h5 id="memv-x-list"><code>(memv x list)</code></h5>
<p>These procedures return the first sublist of <code>list</code> whose <code>car</code> is <code>x</code>, where the sublists of <code>list</code> are the non-empty lists returned by <code>(drop list i)</code> for <code>i</code> less than the length of list. If <code>x</code> does not occur in list, then <code>#f</code> is returned. <code>memq</code> uses <code>eq?</code> to compare <code>x</code> with the elements of list, while <code>memv</code> uses <code>eqv?</code>, and <code>member</code> uses <code>equal?</code>.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb53-1" title="1">(<span class="kw">memq</span> &#39;a &#39;(a b c))          <span class="op">=&gt;</span>  (a b c)</a>
<a class="sourceLine" id="cb53-2" title="2">(<span class="kw">memq</span> &#39;b &#39;(a b c))          <span class="op">=&gt;</span>  (b c)</a>
<a class="sourceLine" id="cb53-3" title="3">(<span class="kw">memq</span> &#39;a &#39;(b c d))          <span class="op">=&gt;</span>  <span class="dv">#f</span></a>
<a class="sourceLine" id="cb53-4" title="4">(<span class="kw">memq</span> (<span class="kw">list</span> &#39;a) &#39;(b (a) c)) <span class="op">=&gt;</span>  <span class="dv">#f</span></a>
<a class="sourceLine" id="cb53-5" title="5">(<span class="kw">member</span> (<span class="kw">list</span> &#39;a) &#39;(b (a) c))         <span class="op">=&gt;</span>  ((a) c)</a>
<a class="sourceLine" id="cb53-6" title="6">(<span class="kw">memq</span> <span class="dv">101</span> &#39;(<span class="dv">100</span> <span class="dv">101</span> <span class="dv">102</span>))   <span class="op">=&gt;</span>  *unspecified*</a>
<a class="sourceLine" id="cb53-7" title="7">(<span class="kw">memv</span> <span class="dv">101</span> &#39;(<span class="dv">100</span> <span class="dv">101</span> <span class="dv">102</span>))   <span class="op">=&gt;</span>  (<span class="dv">101</span> <span class="dv">102</span>)</a></code></pre></div>
<p>The comparison procedure is used to compare the elements <code>ei</code> of list to the key <code>x</code> in this way:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb54-1" title="1">(<span class="op">=</span> x ei) <span class="co">; list is (e1 ... en)</span></a></code></pre></div>
<p>That is, the first argument is always <code>x</code>, and the second argument is one of the list elements. Thus one can reliably find the first element of list that is greater than five with <code>(member 5 list &lt;)</code></p>
<p>Note that fully general list searching may be performed with the <code>find-tail</code> and <code>find</code> procedures, e.g.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb55-1" title="1">(find-tail <span class="kw">even?</span> <span class="kw">list</span>) <span class="co">; Find the first elt with an even key.</span></a></code></pre></div>
<h4 id="deleting">Deleting</h4>
<h5 id="delete-x-list"><code>(delete x list)</code></h5>
<h5 id="delete-x-list-1"><code>(delete! x list)</code></h5>
<p><code>delete</code> uses the comparison procedure <code>=</code>, which defaults to <code>equal?</code>, to find all elements of list that are equal to <code>x</code>, and deletes them from list. The dynamic order in which the various applications of <code>=</code> are made is not specified.</p>
<p>The list is not disordered – elements that appear in the result list occur in the same order as they occur in the argument list. The result may share a common tail with the argument list.</p>
<p>Note that fully general element deletion can be performed with the <code>remove</code> and <code>remove!</code> procedures, e.g.:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb56-1" title="1"><span class="co">;; Delete all the even elements from LIS:</span></a>
<a class="sourceLine" id="cb56-2" title="2">(remove <span class="kw">even?</span> lis)</a></code></pre></div>
<p>The comparison procedure is used in this way: <code>(= x ei)</code>. That is, <code>x</code> is always the first argument, and a list element is always the second argument. The comparison procedure will be used to compare each element of list exactly once; the order in which it is applied to the various <code>ei</code> is not specified. Thus, one can reliably remove all the numbers greater than five from a list with <code>(delete 5 list &lt;)</code>.</p>
<p><code>delete!</code> is the linear-update variant of <code>delete</code>. It is allowed, but not required, to alter the cons cells in its argument list to construct the result.</p>
<h5 id="delete-duplicates-list"><code>(delete-duplicates  list [=])</code></h5>
<h5 id="delete-duplicates-list-1"><code>(delete-duplicates! list [=])</code></h5>
<p><code>delete-duplicates</code> removes duplicate elements from the list argument. If there are multiple equal elements in the argument list, the result list only contains the first or leftmost of these elements in the result. The order of these surviving elements is the same as in the original list – delete-duplicates does not disorder the list (hence it is useful for “cleaning up” association lists).</p>
<p>The <code>=</code> parameter is used to compare the elements of the list; it defaults to equal?. If x comes before y in list, then the comparison is performed (= x y). The comparison procedure will be used to compare each pair of elements in list no more than once; the order in which it is applied to the various pairs is not specified.</p>
<p>Implementations of <code>delete-duplicates</code> are allowed to share common tails between argument and result lists – for example, if the list argument contains only unique elements, it may simply return exactly this list.</p>
<p>Be aware that, in general, delete-duplicates runs in time O(n2) for n-element lists. Uniquifying long lists can be accomplished in O(n lg n) time by sorting the list to bring equal elements together, then using a linear-time algorithm to remove equal elements. Alternatively, one can use algorithms based on element-marking, with linear-time results.</p>
<p><code>delete-duplicates!</code> is the linear-update variant of <code>delete-duplicates</code>; it is allowed, but not required, to alter the cons cells in its argument list to construct the result.</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb57-1" title="1">(delete-duplicates &#39;(a b a c a b c z)) <span class="op">=&gt;</span> (a b c z)</a>
<a class="sourceLine" id="cb57-2" title="2"></a>
<a class="sourceLine" id="cb57-3" title="3"><span class="co">;; Clean up an alist:</span></a>
<a class="sourceLine" id="cb57-4" title="4">(delete-duplicates &#39;((a . <span class="dv">3</span>) (b . <span class="dv">7</span>) (a . <span class="dv">9</span>) (c . <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb57-5" title="5">                   (<span class="kw">lambda</span> (x y) (<span class="kw">eq?</span> (<span class="kw">car</span> x) (<span class="kw">car</span> y))))</a>
<a class="sourceLine" id="cb57-6" title="6"><span class="co">;;  =&gt; ((a . 3) (b . 7) (c . 1))</span></a></code></pre></div>
<h4 id="association-lists">Association lists</h4>
<p>An “association list” (or “alist”) is a list of pairs. The car of each pair contains a key value, and the cdr contains the associated data value. They can be used to construct simple look-up tables in Scheme. Note that association lists are probably inappropriate for performance-critical use on large data; in these cases, hash tables or some other alternative should be employed.</p>
<h5 id="assoc-key-alist"><code>(assoc key alist [=])</code></h5>
<h5 id="assq-key-alist"><code>(assq key alist)</code></h5>
<h5 id="assv-key-alist"><code>(assv key alist)</code></h5>
<p><code>alist</code> must be an association list – a list of pairs. These procedures find the first pair in <code>alist</code> whose <code>car</code> field is <code>key</code>, and returns that pair. If no pair in <code>alist</code> has <code>key</code> as its <code>car</code>, then <code>#f</code> is returned. <code>assq</code> uses <code>eq?</code> to compare <code>key</code> with the <code>car</code> fields of the pairs in <code>alist</code>, while <code>assv</code> uses <code>eqv?</code> and <code>assoc</code> uses <code>equal?</code>.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb58-1" title="1">(<span class="ex">define</span><span class="fu"> e </span>&#39;((a <span class="dv">1</span>) (b <span class="dv">2</span>) (c <span class="dv">3</span>)))</a>
<a class="sourceLine" id="cb58-2" title="2">(<span class="kw">assq</span> &#39;a e)                            <span class="op">=&gt;</span>  (a <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb58-3" title="3">(<span class="kw">assq</span> &#39;b e)                            <span class="op">=&gt;</span>  (b <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb58-4" title="4">(<span class="kw">assq</span> &#39;d e)                            <span class="op">=&gt;</span>  <span class="dv">#f</span></a>
<a class="sourceLine" id="cb58-5" title="5">(<span class="kw">assq</span> (<span class="kw">list</span> &#39;a) &#39;(((a)) ((b)) ((c))))  <span class="op">=&gt;</span>  <span class="dv">#f</span></a>
<a class="sourceLine" id="cb58-6" title="6">(<span class="kw">assoc</span> (<span class="kw">list</span> &#39;a) &#39;(((a)) ((b)) ((c)))) <span class="op">=&gt;</span>  ((a))</a>
<a class="sourceLine" id="cb58-7" title="7">(<span class="kw">assq</span> <span class="dv">5</span> &#39;((<span class="dv">2</span> <span class="dv">3</span>) (<span class="dv">5</span> <span class="dv">7</span>) (<span class="dv">11</span> <span class="dv">13</span>)))    <span class="op">=&gt;</span>  *unspecified*</a>
<a class="sourceLine" id="cb58-8" title="8">(<span class="kw">assv</span> <span class="dv">5</span> &#39;((<span class="dv">2</span> <span class="dv">3</span>) (<span class="dv">5</span> <span class="dv">7</span>) (<span class="dv">11</span> <span class="dv">13</span>)))    <span class="op">=&gt;</span>  (<span class="dv">5</span> <span class="dv">7</span>)</a></code></pre></div>
<p>The comparison procedure is used to compare the elements <code>ei</code> of list to the <code>key</code> parameter in this way:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb59-1" title="1">(<span class="op">=</span> key (<span class="kw">car</span> ei)) <span class="co">; list is (E1 ... En)</span></a></code></pre></div>
<p>That is, the first argument is always <code>key</code>, and the second argument is one of the list elements. Thus one can reliably find the first entry of alist whose key is greater than five with <code>(assoc 5 alist &lt;)</code></p>
<p>Note that fully general <code>alist</code> searching may be performed with the <code>find-tail</code> and <code>find</code> procedures, e.g.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb60-1" title="1"><span class="co">;; Look up the first association in alist with an even key:</span></a>
<a class="sourceLine" id="cb60-2" title="2">(find (<span class="kw">lambda</span> (a) (<span class="kw">even?</span> (<span class="kw">car</span> a))) alist)</a></code></pre></div>
<h5 id="alist-cons-key-datum-alist"><code>(alist-cons key datum alist)</code></h5>
<div class="sourceCode" id="cb61"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb61-1" title="1">(<span class="kw">lambda</span> (key datum alist) (<span class="kw">cons</span> (<span class="kw">cons</span> key datum) alist))</a></code></pre></div>
<p><code>cons</code> a new entry mapping <code>key</code> to <code>datum</code> onto <code>alist</code>.</p>
<h5 id="alist-copy-alist"><code>(alist-copy alist)</code></h5>
<p>Make a fresh copy of <code>alist</code>. This means copying each pair that forms an association as well as the spine of the list, i.e.</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb62-1" title="1">(<span class="kw">lambda</span> (a) (map (<span class="kw">lambda</span> (elt) (<span class="kw">cons</span> (<span class="kw">car</span> elt) (<span class="kw">cdr</span> elt))) a))</a></code></pre></div>
<h5 id="alist-delete-key-alist"><code>(alist-delete  key alist [=])</code></h5>
<h5 id="alist-delete-key-alist-1"><code>(alist-delete! key alist [=])</code></h5>
<p><code>alist-delete</code> deletes all associations from alist with the given key, using key-comparison procedure <code>=</code>, which defaults to equal?. The dynamic order in which the various applications of = are made is not specified.</p>
<p>Return values may share common tails with the alist argument. The alist is not disordered – elements that appear in the result alist occur in the same order as they occur in the argument alist.</p>
<p>The comparison procedure is used to compare the element keys ki of alist’s entries to the key parameter in this way: (= key ki). Thus, one can reliably remove all entries of alist whose key is greater than five with (alist-delete 5 alist &lt;)</p>
<p>alist-delete! is the linear-update variant of alist-delete. It is allowed, but not required, to alter cons cells from the alist parameter to construct the result.</p>
<h4 id="set-operations-on-lists">Set operations on lists</h4>
<p>These procedures implement operations on sets represented as lists of elements. They all take an = argument used to compare elements of lists. This equality procedure is required to be consistent with eq?. That is, it must be the case that <code>(eq? x y) =&gt; (= x y)</code>.</p>
<p>Note that this implies, in turn, that two lists that are eq? are also set-equal by any legal comparison procedure. This allows for constant-time determination of set operations on eq? lists.</p>
<p>Be aware that these procedures typically run in time O(n * m) for n- and m-element list arguments. Performance-critical applications operating upon large sets will probably wish to use other data structures and algorithms.</p>
<h5 id="lset-list1-..."><code>(lset&lt;= = list1 ...)</code></h5>
<p>Returns true iff every listi is a subset of listi+1, using = for the element-equality procedure. List A is a subset of list B if every element in A is equal to some element of B. When performing an element comparison, the = procedure’s first argument is an element of A; its second, an element of B.</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb63-1" title="1">(lset&lt;= <span class="kw">eq?</span> &#39;(a) &#39;(a b a) &#39;(a b c c)) <span class="op">=&gt;</span> <span class="dv">#t</span></a>
<a class="sourceLine" id="cb63-2" title="2"></a>
<a class="sourceLine" id="cb63-3" title="3">(lset&lt;= <span class="kw">eq?</span>) <span class="op">=&gt;</span> <span class="dv">#t</span>             <span class="co">; Trivial cases</span></a>
<a class="sourceLine" id="cb63-4" title="4">(lset&lt;= <span class="kw">eq?</span> &#39;(a)) <span class="op">=&gt;</span> <span class="dv">#t</span></a></code></pre></div>
<h5 id="lset-list1-...-1"><code>(lset= = list1 ...)</code></h5>
<p>Returns true iff every listi is set-equal to listi+1, using = for the element-equality procedure. “Set-equal” simply means that listi is a subset of listi+1, and listi+1 is a subset of listi. The = procedure’s first argument is an element of listi; its second is an element of listi+1.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb64-1" title="1">(lset= <span class="kw">eq?</span> &#39;(b e a) &#39;(a e b) &#39;(e e b a)) <span class="op">=&gt;</span> <span class="dv">#t</span></a>
<a class="sourceLine" id="cb64-2" title="2"></a>
<a class="sourceLine" id="cb64-3" title="3">(lset= <span class="kw">eq?</span>) <span class="op">=&gt;</span> <span class="dv">#t</span>               <span class="co">; Trivial cases</span></a>
<a class="sourceLine" id="cb64-4" title="4">(lset= <span class="kw">eq?</span> &#39;(a)) <span class="op">=&gt;</span> <span class="dv">#t</span></a></code></pre></div>
<h5 id="lset-adjoin-list-elt1-..."><code>(lset-adjoin = list elt1 ...)</code></h5>
<p>Adds the elti elements not already in the list parameter to the result list. The result shares a common tail with the list parameter. The new elements are added to the front of the list, but no guarantees are made about their order. The = parameter is an equality procedure used to determine if an elti is already a member of list. Its first argument is an element of list; its second is one of the elti.</p>
<p>The list parameter is always a suffix of the result – even if the list parameter contains repeated elements, these are not reduced.</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb65-1" title="1">(lset-adjoin <span class="kw">eq?</span> &#39;(a b c d c e) &#39;a &#39;e &#39;i &#39;o &#39;u) <span class="op">=&gt;</span> (u o i a b c d c e)</a></code></pre></div>
<h5 id="lset-union-list1-..."><code>(lset-union = list1 ...)</code></h5>
<p>Returns the union of the lists, using = for the element-equality procedure.</p>
<p>The union of lists A and B is constructed as follows:</p>
<ul>
<li>If A is the empty list, the answer is B (or a copy of B).</li>
<li>Otherwise, the result is initialised to be list A (or a copy of A).</li>
<li>Proceed through the elements of list B in a left-to-right order. If b is such an element of B, compare every element r of the current result list to b: (= r b). If all comparisons fail, b is consed onto the front of the result.</li>
</ul>
<p>However, there is no guarantee that = will be applied to every pair of arguments from A and B. In particular, if A is eq? to B, the operation may immediately terminate.</p>
<p>In the n-ary case, the two-argument list-union operation is simply folded across the argument lists.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb66-1" title="1">(lset-union <span class="kw">eq?</span> &#39;(a b c d e) &#39;(a e i o u)) <span class="op">=&gt;</span></a>
<a class="sourceLine" id="cb66-2" title="2">        (u o i a b c d e)</a>
<a class="sourceLine" id="cb66-3" title="3"></a>
<a class="sourceLine" id="cb66-4" title="4"><span class="co">;; Repeated elements in LIST1 are preserved.</span></a>
<a class="sourceLine" id="cb66-5" title="5">(lset-union <span class="kw">eq?</span> &#39;(a a c) &#39;(x a x)) <span class="op">=&gt;</span> (x a a c)</a>
<a class="sourceLine" id="cb66-6" title="6"></a>
<a class="sourceLine" id="cb66-7" title="7"><span class="co">;; Trivial cases</span></a>
<a class="sourceLine" id="cb66-8" title="8">(lset-union <span class="kw">eq?</span>) <span class="op">=&gt;</span> ()</a>
<a class="sourceLine" id="cb66-9" title="9">(lset-union <span class="kw">eq?</span> &#39;(a b c)) <span class="op">=&gt;</span> (a b c)</a></code></pre></div>
<h5 id="lset-intersection-list1-list2-..."><code>(lset-intersection = list1 list2 ...)</code></h5>
<p>Returns the intersection of the lists, using = for the element-equality procedure.</p>
<p>The intersection of lists A and B is comprised of every element of A that is = to some element of B: (= a b), for a in A, and b in B. Note this implies that an element which appears in B and multiple times in list A will also appear multiple times in the result.</p>
<p>The order in which elements appear in the result is the same as they appear in list1 – that is, lset-intersection essentially filters list1, without disarranging element order. The result may share a common tail with list1.</p>
<p>In the n-ary case, the two-argument list-intersection operation is simply folded across the argument lists. However, the dynamic order in which the applications of = are made is not specified. The procedure may check an element of list1 for membership in every other list before proceeding to consider the next element of list1, or it may completely intersect list1 and list2 before proceeding to list3, or it may go about its work in some third order.</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb67-1" title="1">(lset-intersection <span class="kw">eq?</span> &#39;(a b c d e) &#39;(a e i o u)) <span class="op">=&gt;</span> (a e)</a>
<a class="sourceLine" id="cb67-2" title="2"></a>
<a class="sourceLine" id="cb67-3" title="3"><span class="co">;; Repeated elements in LIST1 are preserved.</span></a>
<a class="sourceLine" id="cb67-4" title="4">(lset-intersection <span class="kw">eq?</span> &#39;(a x y a) &#39;(x a x z)) <span class="op">=&gt;</span> &#39;(a x a)</a>
<a class="sourceLine" id="cb67-5" title="5"></a>
<a class="sourceLine" id="cb67-6" title="6">(lset-intersection <span class="kw">eq?</span> &#39;(a b c)) <span class="op">=&gt;</span> (a b c)     <span class="co">; Trivial case</span></a></code></pre></div>
<h5 id="lset-difference-list1-list2-..."><code>(lset-difference = list1 list2 ...)</code></h5>
<p>Returns the difference of the lists, using = for the element-equality procedure – all the elements of list1 that are not = to any element from one of the other listi parameters.</p>
<p>The = procedure’s first argument is always an element of list1; its second is an element of one of the other listi. Elements that are repeated multiple times in the list1 parameter will occur multiple times in the result. The order in which elements appear in the result is the same as they appear in list1 – that is, lset-difference essentially filters list1, without disarranging element order. The result may share a common tail with list1. The dynamic order in which the applications of = are made is not specified. The procedure may check an element of list1 for membership in every other list before proceeding to consider the next element of list1, or it may completely compute the difference of list1 and list2 before proceeding to list3, or it may go about its work in some third order.</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb68-1" title="1">(lset-difference <span class="kw">eq?</span> &#39;(a b c d e) &#39;(a e i o u)) <span class="op">=&gt;</span> (b c d)</a>
<a class="sourceLine" id="cb68-2" title="2"></a>
<a class="sourceLine" id="cb68-3" title="3">(lset-difference <span class="kw">eq?</span> &#39;(a b c)) <span class="op">=&gt;</span> (a b c) <span class="co">; Trivial case</span></a></code></pre></div>
<h5 id="lset-xor-list1">`(lset-xor = list1 …)</h5>
<p>Returns the exclusive-or of the sets, using = for the element-equality procedure. If there are exactly two lists, this is all the elements that appear in exactly one of the two lists. The operation is associative, and thus extends to the n-ary case – the elements that appear in an odd number of the lists. The result may share a common tail with any of the listi parameters.</p>
<p>More precisely, for two lists A and B, A xor B is a list of</p>
<ul>
<li>every element a of A such that there is no element b of B such that (= a b), and</li>
<li>every element b of B such that there is no element a of A such that (= b a).</li>
</ul>
<p>However, an implementation is allowed to assume that = is symmetric – that is, that</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb69-1" title="1">(<span class="op">=</span> a b) <span class="op">=&gt;</span> (<span class="op">=</span> b a).</a></code></pre></div>
<p>This means, for example, that if a comparison (= a b) produces true for some a in A and b in B, both a and b may be removed from inclusion in the result.</p>
<p>In the n-ary case, the binary-xor operation is simply folded across the lists.</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb70-1" title="1">(lset-xor <span class="kw">eq?</span> &#39;(a b c d e) &#39;(a e i o u)) <span class="op">=&gt;</span> (d c b i o u)</a>
<a class="sourceLine" id="cb70-2" title="2"></a>
<a class="sourceLine" id="cb70-3" title="3"><span class="co">;; Trivial cases.</span></a>
<a class="sourceLine" id="cb70-4" title="4">(lset-xor <span class="kw">eq?</span>) <span class="op">=&gt;</span> ()</a>
<a class="sourceLine" id="cb70-5" title="5">(lset-xor <span class="kw">eq?</span> &#39;(a b c d e)) <span class="op">=&gt;</span> (a b c d e)</a></code></pre></div>
<h5 id="lset-diffintersection-list1-list2-..."><code>(lset-diff+intersection = list1 list2 ...)</code></h5>
<p>Returns two values – the difference and the intersection of the lists. Is equivalent to:</p>
<pre><code>(values (lset-difference = list1 list2 ...)
        (lset-intersection = list1
                             (lset-union = list2 ...)))</code></pre>
<p>But can be implemented more efficiently.</p>
<p>The = procedure’s first argument is an element of list1; its second is an element of one of the other listi.</p>
<p>Either of the answer lists may share a common tail with list1. This operation essentially partitions list1.</p>
<h5 id="lset-union-list1-...-1"><code>(lset-union! list1 ...)</code></h5>
<h5 id="lset-intersection-list1-..."><code>(lset-intersection! list1 ...)</code></h5>
<h5 id="lset-difference-list1-..."><code>(lset-difference! list1 ...)</code></h5>
<h5 id="lset-xor-list1-..."><code>(lset-xor! list1 ...)</code></h5>
<h5 id="lset-diffintersection-list1-..."><code>(lset-diff+intersection! list1 ...)</code></h5>
<p>These are linear-update variants. They are allowed, but not required, to use the cons cells in their first list parameter to construct their answer. lset-union! is permitted to recycle cons cells from any of its list arguments.</p>
<h4 id="primitive-side-effects">Primitive side-effects</h4>
<h5 id="set-car-pair-object"><code>(set-car! pair object)</code></h5>
<h5 id="set-cdr-pair-object"><code>(set-cdr! pair object)</code></h5>
<p>These procedures store object in the car and cdr field of pair, respectively. The value returned is unspecified.</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb72-1" title="1">(<span class="ex">define</span><span class="fu"> </span>(f) (<span class="kw">list</span> &#39;not-a-constant-list))</a>
<a class="sourceLine" id="cb72-2" title="2">(<span class="ex">define</span><span class="fu"> </span>(g) &#39;(constant-list))</a>
<a class="sourceLine" id="cb72-3" title="3">(<span class="kw">set-car!</span> (f) <span class="dv">3</span>) <span class="op">=&gt;</span>  *unspecified*</a>
<a class="sourceLine" id="cb72-4" title="4">(<span class="kw">set-car!</span> (g) <span class="dv">3</span>) <span class="op">=&gt;</span>  *error*</a></code></pre></div>
<h2 id="srfi-srfi-2"><code>(srfi srfi-2)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-2/">SRFI-2</a>.</p>
<h3 id="abstract-1">Abstract</h3>
<p>Like an ordinary <code>and</code>, an <code>and-let*</code> special form evaluates its arguments – expressions – one after another in order, till the first one that yields <code>#f</code>. Unlike <code>and</code>, however, a non-<code>#f</code> result of one expression can be bound to a fresh variable and used in the subsequent expressions. <code>and-let*</code> is a cross-breed between <code>let*</code> and <code>and</code>.</p>
<h3 id="reference-1">Reference</h3>
<h4 id="and-let"><code>and-let*</code></h4>
<p><code>and-let*</code> is a generalized <code>and</code>: it evaluates a sequence of forms one after another till the first one that yields <code>#f</code>; the non-<code>#f</code> result of a form can be bound to a fresh variable and used in the subsequent forms. ## <code>(srfi srfi-4)</code></p>
<p>This is based on <a href="https://srfi.schemers.org/srfi-4/">SRFI-4</a>.</p>
<h3 id="abstract-2">Abstract</h3>
<p>This SRFI describes a set of datatypes for vectors whose elements are of the same numeric type (signed or unsigned exact integer or inexact real of a given precision). These datatypes support operations analogous to the Scheme vector type, but they are distinct datatypes.</p>
<h3 id="reference-2">Reference</h3>
<h4 id="signed-8-bits-integer">Signed 8 bits integer</h4>
<h5 id="s8vector">s8vector?</h5>
<h5 id="make-s8vector">make-s8vector</h5>
<h5 id="s8vector-1">s8vector</h5>
<h5 id="s8vector-length">s8vector-length</h5>
<h5 id="s8vector-ref">s8vector-ref</h5>
<h5 id="s8vector-set">s8vector-set!</h5>
<h5 id="s8vector-list">s8vector-&gt;list</h5>
<h5 id="list-s8vector">list-&gt;s8vector</h5>
<h4 id="signed-16-bits-integer">Signed 16 bits integer</h4>
<h5 id="s16vector">s16vector?</h5>
<h5 id="make-s16vector">make-s16vector</h5>
<h5 id="s16vector-1">s16vector</h5>
<h5 id="s16vector-length">s16vector-length</h5>
<h5 id="s16vector-ref">s16vector-ref</h5>
<h5 id="s16vector-set">s16vector-set!</h5>
<h5 id="s16vector-list">s16vector-&gt;list</h5>
<h5 id="list-s16vector">list-&gt;s16vector</h5>
<h4 id="signed-32-bits-integer">Signed 32 bits integer</h4>
<h5 id="s32vector">s32vector?</h5>
<h5 id="make-s32vector">make-s32vector</h5>
<h5 id="s32vector-1">s32vector</h5>
<h5 id="s32vector-length">s32vector-length</h5>
<h5 id="s32vector-ref">s32vector-ref</h5>
<h5 id="s32vector-set">s32vector-set!</h5>
<h5 id="s32vector-list">s32vector-&gt;list</h5>
<h5 id="list-s32vector">list-&gt;s32vector</h5>
<h4 id="signed-64-bits-integer">Signed 64 bits integer</h4>
<h5 id="s64vector">s64vector?</h5>
<h5 id="make-s64vector">make-s64vector</h5>
<h5 id="s64vector-1">s64vector</h5>
<h5 id="s64vector-length">s64vector-length</h5>
<h5 id="s64vector-ref">s64vector-ref</h5>
<h5 id="s64vector-set">s64vector-set!</h5>
<h5 id="s64vector-list">s64vector-&gt;list</h5>
<h5 id="list-s64vector">list-&gt;s64vector</h5>
<h4 id="unsigned-8-bits-integer">Unsigned 8 bits integer</h4>
<h5 id="u8vector">u8vector?</h5>
<h5 id="make-u8vector">make-u8vector</h5>
<h5 id="u8vector-1">u8vector</h5>
<h5 id="u8vector-length">u8vector-length</h5>
<h5 id="u8vector-ref">u8vector-ref</h5>
<h5 id="u8vector-set">u8vector-set!</h5>
<h5 id="u8vector-list">u8vector-&gt;list</h5>
<h5 id="list-u8vector">list-&gt;u8vector</h5>
<h4 id="unsigned-16-bits-integer">Unsigned 16 bits integer</h4>
<h5 id="u16vector">u16vector?</h5>
<h5 id="make-u16vector">make-u16vector</h5>
<h5 id="u16vector-1">u16vector</h5>
<h5 id="u16vector-length">u16vector-length</h5>
<h5 id="u16vector-ref">u16vector-ref</h5>
<h5 id="u16vector-set">u16vector-set!</h5>
<h5 id="u16vector-list">u16vector-&gt;list</h5>
<h5 id="list-u16vector">list-&gt;u16vector</h5>
<h4 id="unsigned-32-bits-integer">Unsigned 32 bits integer</h4>
<h5 id="u32vector">u32vector?</h5>
<h5 id="make-u32vector">make-u32vector</h5>
<h5 id="u32vector-1">u32vector</h5>
<h5 id="u32vector-length">u32vector-length</h5>
<h5 id="u32vector-ref">u32vector-ref</h5>
<h5 id="u32vector-set">u32vector-set!</h5>
<h5 id="u32vector-list">u32vector-&gt;list</h5>
<h5 id="list-u32vector">list-&gt;u32vector</h5>
<h4 id="unsigned-64-bits-integer">Unsigned 64 bits integer</h4>
<h5 id="u64vector">u64vector?</h5>
<h5 id="make-u64vector">make-u64vector</h5>
<h5 id="u64vector-1">u64vector</h5>
<h5 id="u64vector-length">u64vector-length</h5>
<h5 id="u64vector-ref">u64vector-ref</h5>
<h5 id="u64vector-set">u64vector-set!</h5>
<h5 id="u64vector-list">u64vector-&gt;list</h5>
<h5 id="list-u64vector">list-&gt;u64vector</h5>
<h4 id="bits-float">32 bits float</h4>
<h5 id="f32vector">f32vector?</h5>
<h5 id="make-f32vector">make-f32vector</h5>
<h5 id="f32vector-1">f32vector</h5>
<h5 id="f32vector-length">f32vector-length</h5>
<h5 id="f32vector-ref">f32vector-ref</h5>
<h5 id="f32vector-set">f32vector-set!</h5>
<h5 id="f32vector-list">f32vector-&gt;list</h5>
<h5 id="list-f32vector">list-&gt;f32vector</h5>
<h4 id="bits-float-1">64 bits float</h4>
<h5 id="f64vector">f64vector?</h5>
<h5 id="make-f64vector">make-f64vector</h5>
<h5 id="f64vector-1">f64vector</h5>
<h5 id="f64vector-length">f64vector-length</h5>
<h5 id="f64vector-ref">f64vector-ref</h5>
<h5 id="f64vector-set">f64vector-set!</h5>
<h5 id="f64vector-list">f64vector-&gt;list</h5>
<h5 id="list-f64vector">list-&gt;f64vector</h5>
<h2 id="srfi-srfi-5"><code>(srfi srfi-5)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-5/">SRFI-5</a>.</p>
<h3 id="abstract-3">Abstract</h3>
<p>The named-<code>let</code> incarnation of the <code>let</code> form has two slight inconsistencies with the <code>define</code> form. As defined, the <code>let</code> form makes no accommodation for rest arguments, an issue of functionality and consistency. As defined, the let form does not accommodate signature-style syntax, an issue of aesthetics and consistency. Both issues are addressed here in a manner which is compatible with the traditional <code>let</code> form but for minor extensions.</p>
<h3 id="reference-3">Reference</h3>
<p>TODO ## <code>(srfi srfi-6)</code></p>
<p>This is based on <a href="https://srfi.schemers.org/srfi-6/">SRFI-6</a>.</p>
<h3 id="abstract-4">Abstract</h3>
<p>Scheme’s i/o primitives are extended by adding three new procedures that</p>
<ul>
<li><p>create an input port from a string,</p></li>
<li><p>create an output port whose contents are accumulated in Scheme’s working memory instead of an external file, and</p></li>
<li><p>extract the accumulated contents of an in-memory output port and return them in the form of a string.</p></li>
</ul>
<h3 id="reference-4">Reference</h3>
<h4 id="open-input-string-string"><code>(open-input-string string)</code></h4>
<p>Takes a string and returns an input port that delivers characters from the string. The port can be closed by <code>close-input-port</code>, though its storage will be reclaimed by the garbage collector if it becomes inaccessible.</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb73-1" title="1">(<span class="ex">define</span><span class="fu"> p</span></a>
<a class="sourceLine" id="cb73-2" title="2">  (open-input-string <span class="st">&quot;(a . (b . (c . ()))) 34&quot;</span>))</a>
<a class="sourceLine" id="cb73-3" title="3"></a>
<a class="sourceLine" id="cb73-4" title="4">(<span class="kw">input-port?</span> p) <span class="co">;; =&gt;  #t</span></a>
<a class="sourceLine" id="cb73-5" title="5">(<span class="kw">read</span> p) <span class="co">;; =&gt; (a b c)</span></a>
<a class="sourceLine" id="cb73-6" title="6">(<span class="kw">read</span> p) <span class="co">;; =&gt; 34</span></a>
<a class="sourceLine" id="cb73-7" title="7">(<span class="kw">eof-object?</span> (<span class="kw">peek-char</span> p)) <span class="co">;; =&gt; #t</span></a></code></pre></div>
<h4 id="open-output-string"><code>(open-output-string)</code></h4>
<p>Returns an output port that will accumulate characters for retrieval by <code>get-output-string</code>. The port can be closed by the procedure <code>close-output-port</code>, though its storage will be reclaimed by the garbage collector if it becomes inaccessible.</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb74-1" title="1">(<span class="kw">let</span> ((q (open-output-string))</a>
<a class="sourceLine" id="cb74-2" title="2">      (x &#39;(a b c)))</a>
<a class="sourceLine" id="cb74-3" title="3">  (<span class="kw">write</span> (<span class="kw">car</span> x) q)</a>
<a class="sourceLine" id="cb74-4" title="4">  (<span class="kw">write</span> (<span class="kw">cdr</span> x) q)</a>
<a class="sourceLine" id="cb74-5" title="5">  (get-output-string q)) <span class="co">;; =&gt; &quot;a(b c)&quot;</span></a></code></pre></div>
<h4 id="get-output-string-output-port"><code>(get-output-string output-port)</code></h4>
<p>Given an output port created by <code>open-output-string</code>, returns a string consisting of the characters that have been output to the port so far. ## <code>(srfi srfi-8)</code></p>
<p>This is based on <a href="https://srfi.schemers.org/srfi-8/">SRFI-8</a>.</p>
<h3 id="abstract-5">Abstract</h3>
<p>The only mechanism that R5RS provides for binding identifiers to the values of a multiple-valued expression is the primitive <code>call-with-values</code>. This SRFI proposes a more concise, more readable syntax for creating such bindings.</p>
<h3 id="reference-5">Reference</h3>
<h4 id="receive-formals-expression-body-syntax"><code>(receive &lt;formals&gt; &lt;expression&gt; &lt;body&gt;)</code> syntax</h4>
<h2 id="srfi-srfi-9"><code>(srfi srfi-9)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-9/">SRFI-9</a>.</p>
<h3 id="abstract-6">Abstract</h3>
<p>Syntax for creating new data types, called record types. A predicate, constructor, and field accessors and modifiers are defined for each record type. Each new record type is distinct from all existing types, including other record types and Scheme’s predefined types.</p>
<h3 id="reference-6">Reference</h3>
<h4 id="define-record-type-...-syntax"><code>(define-record-type ...)</code> syntax</h4>
<p>The following:</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb75-1" title="1">  (define-record-type &lt;pare&gt;</a>
<a class="sourceLine" id="cb75-2" title="2">    (kons x y)</a>
<a class="sourceLine" id="cb75-3" title="3">    pare?</a>
<a class="sourceLine" id="cb75-4" title="4">    (x kar set-kar!)</a>
<a class="sourceLine" id="cb75-5" title="5">    (y kdr))</a></code></pre></div>
<p>Defines <code>KONS</code> to be a constructor, <code>KAR</code> and <code>KDR</code> to be accessors, <code>SET-KAR!</code> to be a modifier, and <code>PARE?</code> to be a predicate for <code>&lt;PAREs&gt;</code>.</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb76-1" title="1">  (pare? (kons <span class="dv">1</span> <span class="dv">2</span>))        --&gt; <span class="dv">#t</span></a>
<a class="sourceLine" id="cb76-2" title="2">  (pare? (<span class="kw">cons</span> <span class="dv">1</span> <span class="dv">2</span>))        --&gt; <span class="dv">#f</span></a>
<a class="sourceLine" id="cb76-3" title="3">  (kar (kons <span class="dv">1</span> <span class="dv">2</span>))          --&gt; <span class="dv">1</span></a>
<a class="sourceLine" id="cb76-4" title="4">  (kdr (kons <span class="dv">1</span> <span class="dv">2</span>))          --&gt; <span class="dv">2</span></a>
<a class="sourceLine" id="cb76-5" title="5">  (<span class="kw">let</span> ((k (kons <span class="dv">1</span> <span class="dv">2</span>)))</a>
<a class="sourceLine" id="cb76-6" title="6">    (set-kar! k <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb76-7" title="7">    (kar k))                --&gt; <span class="dv">3</span></a></code></pre></div>
<h2 id="srfi-srfi-13"><code>(srfi srfi-13)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-13/">SRFI-13</a>.</p>
<h3 id="abstract-7">Abstract</h3>
<p>TODO</p>
<h3 id="reference-7">Reference</h3>
<h4 id="predicates-1">Predicates</h4>
<h5 id="string"><code>string?</code></h5>
<h5 id="string-null"><code>string-null?</code></h5>
<h5 id="string-every"><code>string-every</code></h5>
<h5 id="string-any"><code>string-any</code></h5>
<h4 id="constructors-1">Constructors</h4>
<h5 id="make-string"><code>make-string</code></h5>
<h5 id="string-1"><code>string</code></h5>
<h5 id="string-tabulate"><code>string-tabulate</code></h5>
<h4 id="list-string-conversion">List &amp; string conversion</h4>
<h5 id="string-list"><code>string-&gt;list</code></h5>
<h5 id="list-string"><code>list-&gt;string</code></h5>
<h5 id="reverse-list-string"><code>reverse-list-&gt;string</code></h5>
<h5 id="string-join"><code>string-join</code></h5>
<h4 id="selection">Selection</h4>
<h5 id="string-length"><code>string-length</code></h5>
<h5 id="string-ref"><code>string-ref</code></h5>
<h5 id="string-copy"><code>string-copy</code></h5>
<h5 id="substringshared"><code>substring/shared</code></h5>
<h5 id="string-copy-1"><code>string-copy!</code></h5>
<h5 id="string-take"><code>string-take</code></h5>
<h5 id="string-take-right"><code>string-take-right</code></h5>
<h5 id="string-drop"><code>string-drop</code></h5>
<h5 id="string-drop-right"><code>string-drop-right</code></h5>
<h5 id="string-pad"><code>string-pad</code></h5>
<h5 id="string-pad-right"><code>string-pad-right</code></h5>
<h5 id="string-trim"><code>string-trim</code></h5>
<h5 id="string-trim-right"><code>string-trim-right</code></h5>
<h5 id="string-trim-both"><code>string-trim-both</code></h5>
<h4 id="modification">Modification</h4>
<h5 id="string-set"><code>string-set!</code></h5>
<h5 id="string-fill"><code>string-fill!</code></h5>
<h4 id="comparison">Comparison</h4>
<h5 id="string-compare"><code>string-compare</code></h5>
<h5 id="string-compare-ci"><code>string-compare-ci</code></h5>
<h5 id="string-2"><code>string&lt;&gt;</code></h5>
<h5 id="string-3"><code>string=</code></h5>
<h5 id="string-4"><code>string&lt;</code></h5>
<h5 id="string-5"><code>string&gt;</code></h5>
<h5 id="string-6"><code>string&lt;=</code></h5>
<h5 id="string-7"><code>string&gt;=</code></h5>
<h5 id="string-ci"><code>string-ci&lt;&gt;</code></h5>
<h5 id="string-ci-1"><code>string-ci=</code></h5>
<h5 id="string-ci-2"><code>string-ci&lt;</code></h5>
<h5 id="string-ci-3"><code>string-ci&gt;</code></h5>
<h5 id="string-ci-4"><code>string-ci&lt;=</code></h5>
<h5 id="string-ci-5"><code>string-ci&gt;=</code></h5>
<h5 id="string-hash"><code>string-hash</code></h5>
<h5 id="string-hash-ci"><code>string-hash-ci</code></h5>
<h4 id="prefixes-suffixes">Prefixes &amp; suffixes</h4>
<h5 id="string-prefix-length"><code>string-prefix-length</code></h5>
<h5 id="string-suffix-length"><code>string-suffix-length</code></h5>
<h5 id="string-prefix-length-ci"><code>string-prefix-length-ci</code></h5>
<h5 id="string-suffix-length-ci"><code>string-suffix-length-ci</code></h5>
<h5 id="string-prefix"><code>string-prefix?</code></h5>
<h5 id="string-suffix"><code>string-suffix?</code></h5>
<h5 id="string-prefix-ci"><code>string-prefix-ci?</code></h5>
<h5 id="string-suffix-ci"><code>string-suffix-ci?</code></h5>
<h4 id="searching-1">Searching</h4>
<h5 id="string-index"><code>string-index</code></h5>
<h5 id="string-index-right"><code>string-index-right</code></h5>
<h5 id="string-skip"><code>string-skip</code></h5>
<h5 id="string-skip-right"><code>string-skip-right</code></h5>
<h5 id="string-count"><code>string-count</code></h5>
<h5 id="string-contains"><code>string-contains</code></h5>
<h5 id="string-contains-ci"><code>string-contains-ci</code></h5>
<h4 id="alphabetic-case-mapping">Alphabetic case mapping</h4>
<h5 id="string-titlecase"><code>string-titlecase</code></h5>
<h5 id="string-upcase"><code>string-upcase</code></h5>
<h5 id="string-downcase"><code>string-downcase</code></h5>
<h5 id="string-titlecase-1"><code>string-titlecase!</code></h5>
<h5 id="string-upcase-1"><code>string-upcase!</code></h5>
<h5 id="string-downcase-1"><code>string-downcase!</code></h5>
<h4 id="reverse-append">Reverse &amp; append</h4>
<h5 id="string-reverse"><code>string-reverse</code></h5>
<h5 id="string-reverse-1"><code>string-reverse!</code></h5>
<h5 id="string-append"><code>string-append</code></h5>
<h5 id="string-concatenate"><code>string-concatenate</code></h5>
<h5 id="string-concatenateshared"><code>string-concatenate/shared</code></h5>
<h5 id="string-appendshared"><code>string-append/shared</code></h5>
<h5 id="string-concatenate-reverse"><code>string-concatenate-reverse</code></h5>
<h5 id="string-concatenate-reverseshared"><code>string-concatenate-reverse/shared</code></h5>
<h4 id="fold-unfold-map-1">Fold, unfold &amp; map</h4>
<h5 id="string-map"><code>string-map</code></h5>
<h5 id="string-map-1"><code>string-map!</code></h5>
<h5 id="string-fold"><code>string-fold</code></h5>
<h5 id="string-fold-right"><code>string-fold-right</code></h5>
<h5 id="string-unfold"><code>string-unfold</code></h5>
<h5 id="string-unfold-right"><code>string-unfold-right</code></h5>
<h5 id="string-for-each"><code>string-for-each</code></h5>
<h5 id="string-for-each-index"><code>string-for-each-index</code></h5>
<h4 id="replicate-rotate">Replicate &amp; rotate</h4>
<h5 id="xsubstring"><code>xsubstring</code></h5>
<h5 id="string-xcopy"><code>string-xcopy!</code></h5>
<h4 id="miscellaneous-insertion-parsing">Miscellaneous: insertion, parsing</h4>
<h5 id="string-replace"><code>string-replace</code></h5>
<h5 id="string-tokenize"><code>string-tokenize</code></h5>
<h4 id="filtering-deleting">Filtering &amp; deleting</h4>
<h5 id="string-filter"><code>string-filter</code></h5>
<h5 id="string-delete"><code>string-delete</code></h5>
<h4 id="low-level-procedures">Low-level procedures</h4>
<h5 id="string-parse-startend"><code>string-parse-start+end</code></h5>
<h5 id="string-parse-final-startend"><code>string-parse-final-start+end</code></h5>
<h5 id="let-string-startend"><code>let-string-start+end</code></h5>
<h5 id="check-substring-spec"><code>check-substring-spec</code></h5>
<h5 id="substring-spec-ok"><code>substring-spec-ok?</code></h5>
<h5 id="make-kmp-restart-vector"><code>make-kmp-restart-vector</code></h5>
<h5 id="kmp-step"><code>kmp-step</code></h5>
<h5 id="string-kmp-partial-search"><code>string-kmp-partial-search</code></h5>
<h2 id="srfi-srfi-14"><code>(srfi srfi-14)</code></h2>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-14/">SRFI-14</a>.</p>
<h3 id="abstract-8">Abstract</h3>
<p>The ability to efficiently represent and manipulate sets of characters is an unglamorous but very useful capability for text-processing code – one that tends to pop up in the definitions of other libraries.</p>
<h3 id="reference-8">Reference</h3>
<h4 id="char-set">-&gt;char-set</h4>
<h4 id="char-set-1">char-set</h4>
<h4 id="char-set-list">char-set-&gt;list</h4>
<h4 id="char-set-string">char-set-&gt;string</h4>
<h4 id="char-set-adjoin">char-set-adjoin</h4>
<h4 id="char-set-adjoin-1">char-set-adjoin!</h4>
<h4 id="char-set-any">char-set-any</h4>
<h4 id="char-set-complement">char-set-complement</h4>
<h4 id="char-set-complement-1">char-set-complement!</h4>
<h4 id="char-set-contains">char-set-contains?</h4>
<h4 id="char-set-copy">char-set-copy</h4>
<h4 id="char-set-count">char-set-count</h4>
<h4 id="char-set-cursor">char-set-cursor</h4>
<h4 id="char-set-cursor-next">char-set-cursor-next</h4>
<h4 id="char-set-delete">char-set-delete</h4>
<h4 id="char-set-delete-1">char-set-delete!</h4>
<h4 id="char-set-diffintersection">char-set-diff+intersection</h4>
<h4 id="char-set-diffintersection-1">char-set-diff+intersection!</h4>
<h4 id="char-set-difference">char-set-difference</h4>
<h4 id="char-set-difference-1">char-set-difference!</h4>
<h4 id="char-set-every">char-set-every</h4>
<h4 id="char-set-filter">char-set-filter</h4>
<h4 id="char-set-filter-1">char-set-filter!</h4>
<h4 id="char-set-fold">char-set-fold</h4>
<h4 id="char-set-for-each">char-set-for-each</h4>
<h4 id="char-set-hash">char-set-hash</h4>
<h4 id="char-set-intersection">char-set-intersection</h4>
<h4 id="char-set-intersection-1">char-set-intersection!</h4>
<h4 id="char-set-map">char-set-map</h4>
<h4 id="char-set-ref">char-set-ref</h4>
<h4 id="char-set-size">char-set-size</h4>
<h4 id="char-set-unfold">char-set-unfold</h4>
<h4 id="char-set-unfold-1">char-set-unfold!</h4>
<h4 id="char-set-union">char-set-union</h4>
<h4 id="char-set-union-1">char-set-union!</h4>
<h4 id="char-set-xor">char-set-xor</h4>
<h4 id="char-set-xor-1">char-set-xor!</h4>
<h4 id="char-setascii">char-set:ascii</h4>
<h4 id="char-setblank">char-set:blank</h4>
<h4 id="char-setdigit">char-set:digit</h4>
<h4 id="char-setempty">char-set:empty</h4>
<h4 id="char-setfull">char-set:full</h4>
<h4 id="char-setgraphic">char-set:graphic</h4>
<h4 id="char-sethex-digit">char-set:hex-digit</h4>
<h4 id="char-setiso-control">char-set:iso-control</h4>
<h4 id="char-setletter">char-set:letter</h4>
<h4 id="char-setletterdigit">char-set:letter+digit</h4>
<h4 id="char-setlower-case">char-set:lower-case</h4>
<h4 id="char-setprinting">char-set:printing</h4>
<h4 id="char-setpunctuation">char-set:punctuation</h4>
<h4 id="char-setsymbol">char-set:symbol</h4>
<h4 id="char-settitle-case">char-set:title-case</h4>
<h4 id="char-setupper-case">char-set:upper-case</h4>
<h4 id="char-setwhitespace">char-set:whitespace</h4>
<h4 id="char-set-2">char-set&lt;=</h4>
<h4 id="char-set-3">char-set=</h4>
<h4 id="char-set-4">char-set?</h4>
<h4 id="end-of-char-set">end-of-char-set?</h4>
<h4 id="list-char-set">list-&gt;char-set</h4>
<h4 id="list-char-set-1">list-&gt;char-set!</h4>
<h4 id="string-char-set">string-&gt;char-set</h4>
<h4 id="string-char-set-1">string-&gt;char-set!</h4>
<h4 id="ucs-range-char-set">ucs-range-&gt;char-set</h4>
<h4 id="ucs-range-char-set-1">ucs-range-&gt;char-set!)</h4>
<h2 id="srfi-srfi-16"><code>(srfi srfi-16)</code></h2>
<h3 id="case-lambda-clause1-clause2-...-syntax"><code>(case-lambda clause1 clause2 ...)</code> syntax</h3>
<p>Each clause is of the form <code>(formals body)</code>, where <code>formals</code> and <code>body</code> have the same syntax as in a lambda expression.</p>
<p>A case-lambda expression evaluates to a procedure that accepts a variable number of arguments and is lexically scoped in the same manner as a procedure resulting from a lambda expression. When the procedure is called, the first clause for which the arguments agree with <code>formals</code> is selected, where agreement is specified as for the <code>formals</code> of a lambda expression. The variables of <code>formals</code> are bound to fresh locations, the values of the arguments are stored in those locations, the <code>body</code> is evaluated in the extended environment, and the results of <code>body</code> are returned as the results of the procedure call.</p>
<p>It is an error for the arguments not to agree with the <code>formals</code> of any clause`.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb77"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb77-1" title="1">(<span class="ex">define</span><span class="fu"> add1</span></a>
<a class="sourceLine" id="cb77-2" title="2">  (case-lambda</a>
<a class="sourceLine" id="cb77-3" title="3">    ((a) (add1 a <span class="dv">0</span>))</a>
<a class="sourceLine" id="cb77-4" title="4">    ((a b) (<span class="op">+</span> <span class="dv">1</span> a b))))</a>
<a class="sourceLine" id="cb77-5" title="5"></a>
<a class="sourceLine" id="cb77-6" title="6">(add1 <span class="dv">1</span>) <span class="co">;; =&gt; 2</span></a>
<a class="sourceLine" id="cb77-7" title="7">(add1 <span class="dv">1</span> <span class="dv">2</span>) <span class="co">;; =&gt; 4</span></a></code></pre></div>
<h2 id="srfi-srfi-17"><code>(srfi srfi-17)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-17/">SRFI-17</a>.</p>
<h3 id="abstract-9">Abstract</h3>
<p>Allow procedure calls that evaluate to the “value of a location” to be used to set the value of the location, when used as the first operand of <code>set!</code>. For example:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb78-1" title="1">(set! (<span class="kw">car</span> x) (<span class="kw">car</span> y))</a></code></pre></div>
<p>becomes equivalent to</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb79-1" title="1">(<span class="kw">set-car!</span> x (<span class="kw">car</span> y))</a></code></pre></div>
<h3 id="reference-9">Reference</h3>
<div class="sourceCode" id="cb80"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb80-1" title="1">(set! (<span class="kw">car</span> x) v) == (<span class="kw">set-car!</span> x v)</a>
<a class="sourceLine" id="cb80-2" title="2">(set! (<span class="kw">cdr</span> x) v) == (<span class="kw">set-cdr!</span> x v)</a>
<a class="sourceLine" id="cb80-3" title="3">(set! (<span class="kw">caar</span> x) v) == (<span class="kw">set-car!</span> (<span class="kw">car</span> x) v)</a>
<a class="sourceLine" id="cb80-4" title="4">(set! (<span class="kw">cadr</span> x) v) == (<span class="kw">set-car!</span> (<span class="kw">cdr</span> x) v)</a>
<a class="sourceLine" id="cb80-5" title="5">....</a>
<a class="sourceLine" id="cb80-6" title="6">(set! (caXXr x) v) == (<span class="kw">set-car!</span> (cXXr x) v)</a>
<a class="sourceLine" id="cb80-7" title="7">(set! (cdXXr x) v) == (<span class="kw">set-cdr!</span> (cXXr x) v)</a>
<a class="sourceLine" id="cb80-8" title="8">(set! (<span class="kw">string-ref</span> x i) v) == (<span class="kw">string-set!</span> x i v)</a>
<a class="sourceLine" id="cb80-9" title="9">(set! (<span class="kw">vector-ref</span> x i) v) == (<span class="kw">vector-set!</span> x i v)</a></code></pre></div>
<h2 id="srfi-srfi-19"><code>(srfi srfi-19)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-19/">SRFI-19</a>.</p>
<h3 id="abstract-10">Abstract</h3>
<p>TODO</p>
<h3 id="reference-10">Reference</h3>
<h4 id="time-duration"><code>time-duration</code></h4>
<h4 id="time-monotonic"><code>time-monotonic</code></h4>
<h4 id="time-process"><code>time-process</code></h4>
<h4 id="time-tai"><code>time-tai</code></h4>
<h4 id="time-thread"><code>time-thread</code></h4>
<h4 id="time-utc"><code>time-utc</code></h4>
<h4 id="current-date"><code>current-date</code></h4>
<h4 id="current-julian-day"><code>current-julian-day</code></h4>
<h4 id="current-modified-julian-day"><code>current-modified-julian-day</code></h4>
<h4 id="current-time"><code>current-time</code></h4>
<h4 id="time-resolution"><code>time-resolution</code></h4>
<h4 id="make-time"><code>make-time</code></h4>
<h4 id="time"><code>time?</code></h4>
<h4 id="time-type"><code>time-type</code></h4>
<h4 id="time-nanosecond"><code>time-nanosecond</code></h4>
<h4 id="time-second"><code>time-second</code></h4>
<h4 id="set-time-type"><code>set-time-type!</code></h4>
<h4 id="set-time-nanosecond"><code>set-time-nanosecond!</code></h4>
<h4 id="set-time-second"><code>set-time-second!</code></h4>
<h4 id="copy-time"><code>copy-time</code></h4>
<h4 id="time-1"><code>time&lt;=?</code></h4>
<h4 id="time-2"><code>time&lt;?</code></h4>
<h4 id="time-3"><code>time=?</code></h4>
<h4 id="time-4"><code>time&gt;=?</code></h4>
<h4 id="time-5"><code>time&gt;?</code></h4>
<h4 id="time-difference"><code>time-difference</code></h4>
<h4 id="time-difference-1"><code>time-difference!</code></h4>
<h4 id="add-duration"><code>add-duration</code></h4>
<h4 id="add-duration-1"><code>add-duration!</code></h4>
<h4 id="subtract-duration"><code>subtract-duration</code></h4>
<h4 id="subtract-duration-1"><code>subtract-duration!</code></h4>
<h4 id="make-date"><code>make-date</code></h4>
<h4 id="date"><code>date?</code></h4>
<h4 id="date-nanosecond"><code>date-nanosecond</code></h4>
<h4 id="date-second"><code>date-second</code></h4>
<h4 id="date-minute"><code>date-minute</code></h4>
<h4 id="date-hour"><code>date-hour</code></h4>
<h4 id="date-day"><code>date-day</code></h4>
<h4 id="date-month"><code>date-month</code></h4>
<h4 id="date-year"><code>date-year</code></h4>
<h4 id="date-zone-offset"><code>date-zone-offset</code></h4>
<h4 id="date-year-day"><code>date-year-day</code></h4>
<h4 id="date-week-day"><code>date-week-day</code></h4>
<h4 id="date-week-number"><code>date-week-number</code></h4>
<h4 id="date-julian-day"><code>date-&gt;julian-day</code></h4>
<h4 id="date-modified-julian-day"><code>date-&gt;modified-julian-day</code></h4>
<h4 id="date-time-monotonic"><code>date-&gt;time-monotonic</code></h4>
<h4 id="date-time-tai"><code>date-&gt;time-tai</code></h4>
<h4 id="date-time-utc"><code>date-&gt;time-utc</code></h4>
<h4 id="julian-day-date"><code>julian-day-&gt;date</code></h4>
<h4 id="julian-day-time-monotonic"><code>julian-day-&gt;time-monotonic</code></h4>
<h4 id="julian-day-time-tai"><code>julian-day-&gt;time-tai</code></h4>
<h4 id="julian-day-time-utc"><code>julian-day-&gt;time-utc</code></h4>
<h4 id="modified-julian-day-date"><code>modified-julian-day-&gt;date</code></h4>
<h4 id="modified-julian-day-time-monotonic"><code>modified-julian-day-&gt;time-monotonic</code></h4>
<h4 id="modified-julian-day-time-tai"><code>modified-julian-day-&gt;time-tai</code></h4>
<h4 id="modified-julian-day-time-utc"><code>modified-julian-day-&gt;time-utc</code></h4>
<h4 id="time-monotonic-date"><code>time-monotonic-&gt;date</code></h4>
<h4 id="time-monotonic-julian-day"><code>time-monotonic-&gt;julian-day</code></h4>
<h4 id="time-monotonic-modified-julian-day"><code>time-monotonic-&gt;modified-julian-day</code></h4>
<h4 id="time-monotonic-time-tai"><code>time-monotonic-&gt;time-tai</code></h4>
<h4 id="time-monotonic-time-tai-1"><code>time-monotonic-&gt;time-tai!</code></h4>
<h4 id="time-monotonic-time-utc"><code>time-monotonic-&gt;time-utc</code></h4>
<h4 id="time-monotonic-time-utc-1"><code>time-monotonic-&gt;time-utc!</code></h4>
<h4 id="time-tai-date"><code>time-tai-&gt;date</code></h4>
<h4 id="time-tai-julian-day"><code>time-tai-&gt;julian-day</code></h4>
<h4 id="time-tai-modified-julian-day"><code>time-tai-&gt;modified-julian-day</code></h4>
<h4 id="time-tai-time-monotonic"><code>time-tai-&gt;time-monotonic</code></h4>
<h4 id="time-tai-time-monotonic-1"><code>time-tai-&gt;time-monotonic!</code></h4>
<h4 id="time-tai-time-utc"><code>time-tai-&gt;time-utc</code></h4>
<h4 id="time-tai-time-utc-1"><code>time-tai-&gt;time-utc!</code></h4>
<h4 id="time-utc-date"><code>time-utc-&gt;date</code></h4>
<h4 id="time-utc-julian-day"><code>time-utc-&gt;julian-day</code></h4>
<h4 id="time-utc-modified-julian-day"><code>time-utc-&gt;modified-julian-day</code></h4>
<h4 id="time-utc-time-monotonic"><code>time-utc-&gt;time-monotonic</code></h4>
<h4 id="time-utc-time-monotonic-1"><code>time-utc-&gt;time-monotonic!</code></h4>
<h4 id="time-utc-time-tai"><code>time-utc-&gt;time-tai</code></h4>
<h4 id="time-utc-time-tai-1"><code>time-utc-&gt;time-tai!</code></h4>
<h4 id="date-string"><code>date-&gt;string</code></h4>
<h4 id="string-date"><code>string-&gt;date</code></h4>
<h2 id="srfi-srfi-23"><code>(srfi srfi-23)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-23/">SRFI-23</a>.</p>
<h3 id="abstract-11">Abstract</h3>
<p>A mechanism is proposed to allow Scheme code to report errors and abort execution. The proposed mechanism is already implemented in several Scheme systems and can be implemented, albeit imperfectly, in any R5RS conforming Scheme.</p>
<h3 id="reference-11">Reference</h3>
<h4 id="error-reason-arg-..."><code>(error &lt;reason&gt; [arg ...])</code></h4>
<h2 id="srfi-srfi-25"><code>(srfi srfi-25)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-25/">SRFI-25</a>.</p>
<h3 id="abstract-12">Abstract</h3>
<p>A core set of procedures for creating and manipulating heterogeneous multidimensional arrays is proposed. The design is consistent with the rest of Scheme and independent of other container data types. It provides easy sharing of parts of an array as other arrays without copying, encouraging a declarative style of programming.</p>
<h3 id="reference-12">Reference</h3>
<p>TODO ## <code>(srfi srfi-26)</code></p>
<p>This is based on <a href="https://srfi.schemers.org/srfi-26/">SRFI-26</a>.</p>
<h3 id="abstract-13">Abstract</h3>
<p>When programming in functional style, it is frequently necessary to specialize some of the parameters of a multi-parameter procedure. For example, from the binary operation cons one might want to obtain the unary operation (lambda (x) (cons 1 x)). This specialization of parameters is also known as “partial application”, “operator section” or “projection”.</p>
<h3 id="reference-13">Reference</h3>
<h4 id="cut-...-syntax"><code>(cut ...)</code> syntax</h4>
<h4 id="cute-...-syntax"><code>(cute ...)</code> syntax</h4>
<h2 id="srfi-srfi-28"><code>(srfi srfi-28)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-28/">SRFI-28</a>.</p>
<h3 id="abstract-14">Abstract</h3>
<p>A method of interpreting a Scheme string which contains a number of escape sequences that are replaced with other string data according to the semantics of each sequence. Also called string interpolation.</p>
<h3 id="reference-14">Reference</h3>
<h4 id="format-format-string-obj-..."><code>(format format-string [obj ...])</code></h4>
<p>Accepts a message template (a Scheme string), and processes it, replacing any escape sequences in order with one or more characters, the characters themselves dependent on the semantics of the escape sequence encountered.</p>
<p>An escape sequence is a two character sequence in the string where the first character is a tilde ‘~’. Each escape code’s meaning is as follows:</p>
<ul>
<li><p><code>~a</code> The corresponding value is inserted into the string as if printed with display.</p></li>
<li><p><code>~s</code> The corresponding value is inserted into the string as if printed with write.</p></li>
<li><p><code>~%</code> A newline is inserted.</p></li>
<li><p><code>~~</code> A tilde <code>~</code> is inserted.</p></li>
</ul>
<p><code>~a</code> and <code>~s</code>, when encountered, require a corresponding Scheme value to be present after the format string. The values provided as operands are used by the escape sequences in order. It is an error if fewer values are provided than escape sequences that require them.</p>
<p><code>~%</code> and <code>~~</code> require no corresponding value.</p>
<p><strong>Examples:</strong></p>
<div class="sourceCode" id="cb81"><pre class="sourceCode scheme"><code class="sourceCode scheme"><a class="sourceLine" id="cb81-1" title="1">(format <span class="st">&quot;Hello, ~a&quot;</span> <span class="st">&quot;World!&quot;</span>)</a>
<a class="sourceLine" id="cb81-2" title="2"><span class="co">;; =&gt; &quot;Hello, World!&quot;</span></a>
<a class="sourceLine" id="cb81-3" title="3"></a>
<a class="sourceLine" id="cb81-4" title="4">(format <span class="st">&quot;Error, list is too short: ~s~%&quot;</span> &#39;(one <span class="st">&quot;two&quot;</span> <span class="dv">3</span>))</a>
<a class="sourceLine" id="cb81-5" title="5"><span class="co">;; =&gt; &quot;Error, list is too short: (one \&quot;two\&quot; 3))&quot;</span></a></code></pre></div>
<h2 id="srfi-srfi-29"><code>(srfi srfi-29)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-29/">SRFI-29</a>.</p>
<h3 id="abstract-15">Abstract</h3>
<p>An interface to retrieving and displaying locale sensitive messages. A Scheme program can register one or more translations of templated messages, and then write Scheme code that can transparently retrieve the appropriate message for the locale under which the Scheme system is running.</p>
<h3 id="reference-15">Reference</h3>
<h4 id="current-language"><code>current-language</code></h4>
<h4 id="current-country"><code>current-country</code></h4>
<h4 id="current-locale-details"><code>current-locale-details</code></h4>
<h4 id="declare-bundle"><code>declare-bundle!</code></h4>
<h4 id="store-bundle"><code>store-bundle</code></h4>
<h4 id="store-bundle-1"><code>store-bundle!</code></h4>
<h4 id="load-bundle"><code>load-bundle!</code></h4>
<h4 id="localized-template"><code>localized-template</code></h4>
<h2 id="srfi-srfi-31"><code>(srfi srfi-31)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-31/">SRFI-31</a>.</p>
<h3 id="abstract-16">Abstract</h3>
<p>TODO</p>
<h3 id="reference-16">Reference</h3>
<p>TODO ## <code>(srfi srfi-34)</code></p>
<p>This is based on <a href="https://srfi.schemers.org/srfi-34/">SRFI-34</a>.</p>
<h3 id="abstract-17">Abstract</h3>
<p>TODO</p>
<h3 id="reference-17">Reference</h3>
<h4 id="with-exception-handler"><code>with-exception-handler</code></h4>
<h4 id="guard"><code>guard</code></h4>
<h4 id="raise"><code>raise</code></h4>
<h2 id="srfi-srfi-35"><code>(srfi srfi-35)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-35/">SRFI-35</a>.</p>
<h3 id="abstract-18">Abstract</h3>
<p>Defines constructs for creating and inspecting condition types and values. A condition value encapsulates information about an exceptional situation, or exception. This SRFI also defines a few basic condition types.</p>
<h3 id="reference-18">Reference</h3>
<h4 id="make-condition-type"><code>make-condition-type</code></h4>
<h4 id="condition-type"><code>condition-type?</code></h4>
<h4 id="condition-has-type"><code>condition-has-type?</code></h4>
<h4 id="condition-ref"><code>condition-ref</code></h4>
<h4 id="make-compound-condition"><code>make-compound-condition</code></h4>
<h4 id="extract-condition"><code>extract-condition</code></h4>
<h4 id="define-condition-type"><code>define-condition-type</code></h4>
<h4 id="condition"><code>&amp;condition</code></h4>
<h4 id="make-condition"><code>make-condition</code></h4>
<h4 id="condition-1"><code>condition?</code></h4>
<h4 id="condition-2"><code>condition</code></h4>
<h4 id="serious"><code>&amp;serious</code></h4>
<h4 id="serious-condition"><code>serious-condition?</code></h4>
<h4 id="error"><code>&amp;error</code></h4>
<h4 id="error-1"><code>error?</code></h4>
<h4 id="message"><code>&amp;message</code></h4>
<h4 id="message-condition"><code>message-condition?</code></h4>
<h4 id="condition-message"><code>condition-message</code></h4>
<h2 id="srfi-srfi-37"><code>(srfi srfi-37)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-37/">SRFI-37</a>.</p>
<h3 id="abstract-19">Abstract</h3>
<p>Many operating systems make the set of argument strings used to invoke a program available (often following the program name string in an array called argv). Most programs need to parse and process these argument strings in one way or another. This SRFI describes a set of procedures that support processing program arguments according to POSIX and GNU C Library Reference Manual guidelines.</p>
<h3 id="reference-19">Reference</h3>
<h4 id="args-fold"><code>args-fold</code></h4>
<h4 id="option"><code>option</code></h4>
<h4 id="option-1"><code>option?</code></h4>
<h4 id="option-names"><code>option-names</code></h4>
<h4 id="option-required-arg"><code>option-required-arg?</code></h4>
<h4 id="option-optional-arg"><code>option-optional-arg?</code></h4>
<h4 id="option-processor"><code>option-processor</code></h4>
<h2 id="srfi-srfi-38"><code>(srfi srfi-38)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-38/">SRFI-38</a>.</p>
<h3 id="abstract-20">Abstract</h3>
<p>TODO</p>
<h3 id="reference-20">Reference</h3>
<h4 id="write-with-shared-structure-obj-port-optarg"><code>(write-with-shared-structure obj [port [optarg]])</code></h4>
<h4 id="read-with-shared-structure-port"><code>(read-with-shared-structure [port])</code></h4>
<h2 id="srfi-srfi-39"><code>(srfi srfi-39)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-39/">SRFI-39</a>.</p>
<h3 id="abstract-21">Abstract</h3>
<p>This SRFI defines parameter objects, the procedure make-parameter to create parameter objects and the parameterize special form to dynamically bind parameter objects. In the dynamic environment, each parameter object is bound to a cell containing the value of the parameter. When a procedure is called the called procedure inherits the dynamic environment from the caller. The parameterize special form allows the binding of a parameter object to be changed for the dynamic extent of its body.</p>
<h3 id="reference-21">Reference</h3>
<h4 id="make-parameter"><code>make-parameter</code></h4>
<h4 id="parameterize"><code>parameterize</code></h4>
<h2 id="srfi-srfi-41"><code>(srfi srfi-41)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-41/">SRFI-41</a>.</p>
<h3 id="abstract-22">Abstract</h3>
<p>Streams, sometimes called lazy lists, are a sequential data structure containing elements computed only on demand. A stream is either null or is a pair with a stream in its cdr. Since elements of a stream are computed only when accessed, streams can be infinite. Once computed, the value of a stream element is cached in case it is needed again.</p>
<h3 id="reference-22">Reference</h3>
<h5 id="stream-null"><code>stream-null</code></h5>
<h5 id="stream-cons"><code>stream-cons</code></h5>
<h5 id="stream"><code>stream?</code></h5>
<h5 id="stream-null-1"><code>stream-null?</code></h5>
<h5 id="stream-pair"><code>stream-pair?</code></h5>
<h5 id="stream-car"><code>stream-car</code></h5>
<h5 id="stream-cdr"><code>stream-cdr</code></h5>
<h5 id="stream-lambda"><code>stream-lambda</code></h5>
<h5 id="define-stream"><code>define-stream</code></h5>
<h5 id="list-stream"><code>list-&gt;stream</code></h5>
<h5 id="port-stream"><code>port-&gt;stream</code></h5>
<h5 id="stream-1"><code>stream</code></h5>
<h5 id="stream-list"><code>stream-&gt;list</code></h5>
<h5 id="stream-append"><code>stream-append</code></h5>
<h5 id="stream-concat"><code>stream-concat</code></h5>
<h5 id="stream-constant"><code>stream-constant</code></h5>
<h5 id="stream-drop"><code>stream-drop</code></h5>
<h5 id="stream-drop-while"><code>stream-drop-while</code></h5>
<h5 id="stream-filter"><code>stream-filter</code></h5>
<h5 id="stream-fold"><code>stream-fold</code></h5>
<h5 id="stream-for-each"><code>stream-for-each</code></h5>
<h5 id="stream-from"><code>stream-from</code></h5>
<h5 id="stream-iterate"><code>stream-iterate</code></h5>
<h5 id="stream-length"><code>stream-length</code></h5>
<h5 id="stream-let"><code>stream-let</code></h5>
<h5 id="stream-map"><code>stream-map</code></h5>
<h5 id="stream-match"><code>stream-match</code></h5>
<h5 id="stream-of"><code>stream-of</code></h5>
<h5 id="stream-range"><code>stream-range</code></h5>
<h5 id="stream-ref"><code>stream-ref</code></h5>
<h5 id="stream-reverse"><code>stream-reverse</code></h5>
<h5 id="stream-scan"><code>stream-scan</code></h5>
<h5 id="stream-take"><code>stream-take</code></h5>
<h5 id="stream-take-while"><code>stream-take-while</code></h5>
<h5 id="stream-unfold"><code>stream-unfold</code></h5>
<h5 id="stream-unfolds"><code>stream-unfolds</code></h5>
<h5 id="stream-zip"><code>stream-zip</code></h5>
<h2 id="srfi-srfi-42"><code>(srfi srfi-42)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-42/">SRFI-42</a>.</p>
<h3 id="abstract-23">Abstract</h3>
<p>TODO</p>
<h3 id="reference-23">Reference</h3>
<h4 id="do-ec"><code>do-ec</code></h4>
<h4 id="list-ec"><code>list-ec</code></h4>
<h4 id="append-ec"><code>append-ec</code></h4>
<h4 id="string-ec"><code>string-ec</code></h4>
<h4 id="string-append-ec"><code>string-append-ec</code></h4>
<h4 id="vector-ec"><code>vector-ec</code></h4>
<h4 id="vector-of-length-ec"><code>vector-of-length-ec</code></h4>
<h4 id="sum-ec"><code>sum-ec</code></h4>
<h4 id="product-ec"><code>product-ec</code></h4>
<h4 id="min-ec"><code>min-ec</code></h4>
<h4 id="max-ec"><code>max-ec</code></h4>
<h4 id="any-ec"><code>any?-ec</code></h4>
<h4 id="every-ec"><code>every?-ec</code></h4>
<h4 id="first-ec"><code>first-ec</code></h4>
<h4 id="last-ec"><code>last-ec</code></h4>
<h4 id="fold-ec"><code>fold-ec</code></h4>
<h4 id="fold3-ec"><code>fold3-ec</code></h4>
<h4 id="section"><code>:</code></h4>
<h4 id="list"><code>:list</code></h4>
<h4 id="string-8"><code>:string</code></h4>
<h4 id="vector"><code>:vector</code></h4>
<h4 id="integers"><code>:integers</code></h4>
<h4 id="range"><code>:range</code></h4>
<h4 id="real-range"><code>:real-range</code></h4>
<h4 id="char-range"><code>:char-range</code></h4>
<h4 id="port"><code>:port</code></h4>
<h4 id="dispatched"><code>:dispatched</code></h4>
<h4 id="do"><code>:do</code></h4>
<h4 id="let"><code>:let</code></h4>
<h4 id="parallel"><code>:parallel</code></h4>
<h4 id="while"><code>:while</code></h4>
<h4 id="until"><code>:until</code></h4>
<h4 id="dispatch-ref"><code>:-dispatch-ref</code></h4>
<h4 id="dispatch-set"><code>:-dispatch-set!</code></h4>
<h4 id="make-initial--dispatch"><code>make-initial-:-dispatch</code></h4>
<h4 id="dispatch-union"><code>dispatch-union</code></h4>
<h4 id="generator-proc"><code>:generator-proc</code></h4>
<h2 id="srfi-srfi-43"><code>(srfi srfi-43)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-43/">SRFI-43</a>.</p>
<h3 id="abstract-24">Abstract</h3>
<p>TODO</p>
<h3 id="reference-24">Reference</h3>
<p>TODO ## <code>(srfi srfi-45)</code></p>
<p>This is based on <a href="https://srfi.schemers.org/srfi-45/">SRFI-45</a>.</p>
<h3 id="abstract-25">Abstract</h3>
<p>TODO</p>
<h3 id="reference-25">Reference</h3>
<h4 id="delay"><code>delay</code></h4>
<h4 id="lazy"><code>lazy</code></h4>
<h4 id="force"><code>force</code></h4>
<h4 id="eager"><code>eager</code></h4>
<h2 id="srfi-srfi-48"><code>(srfi srfi-48)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-48/">SRFI-48</a>.</p>
<h3 id="abstract-26">Abstract</h3>
<p>TODO</p>
<h3 id="reference-26">Reference</h3>
<p>TODO ## <code>(srfi srfi-51)</code></p>
<p>This is based on <a href="https://srfi.schemers.org/srfi-51/">SRFI-51</a>.</p>
<h3 id="abstract-27">Abstract</h3>
<p>TODO</p>
<h3 id="reference-27">Reference</h3>
<p>TODO ## <code>(srfi srfi-54)</code></p>
<p>This is based on <a href="https://srfi.schemers.org/srfi-54/">SRFI-54</a>.</p>
<h3 id="abstract-28">Abstract</h3>
<p>TODO</p>
<h3 id="reference-28">Reference</h3>
<p>TODO ## <code>(srfi srfi-60)</code></p>
<p>This is based on <a href="https://srfi.schemers.org/srfi-60/">SRFI-60</a>.</p>
<h3 id="abstract-29">Abstract</h3>
<p>TODO</p>
<h3 id="reference-29">Reference</h3>
<h4 id="logand">logand</h4>
<h4 id="bitwise-and">bitwise-and</h4>
<h4 id="logior">logior</h4>
<h4 id="bitwise-ior">bitwise-ior</h4>
<h4 id="logxor">logxor</h4>
<h4 id="bitwise-xor">bitwise-xor</h4>
<h4 id="lognot">lognot</h4>
<h4 id="bitwise-not">bitwise-not</h4>
<h4 id="bitwise-if">bitwise-if</h4>
<h4 id="bitwise-merge">bitwise-merge</h4>
<h4 id="logtest">logtest</h4>
<h4 id="any-bits-set">any-bits-set?</h4>
<h4 id="logcount">logcount</h4>
<h4 id="bit-count">bit-count</h4>
<h4 id="integer-length">integer-length</h4>
<h4 id="log2-binary-factors">log2-binary-factors</h4>
<h4 id="first-set-bit">first-set-bit</h4>
<h4 id="logbit">logbit?</h4>
<h4 id="bit-set">bit-set?</h4>
<h4 id="copy-bit">copy-bit</h4>
<h4 id="bit-field">bit-field</h4>
<h4 id="copy-bit-field">copy-bit-field</h4>
<h4 id="ash">ash</h4>
<h4 id="arithmetic-shift">arithmetic-shift</h4>
<h4 id="rotate-bit-field">rotate-bit-field</h4>
<h4 id="reverse-bit-field">reverse-bit-field</h4>
<h4 id="integer-list">integer-&gt;list</h4>
<h4 id="integer-list-1">integer-&gt;list</h4>
<h4 id="list-integer">list-&gt;integer</h4>
<h4 id="booleans-integer">booleans-&gt;integer</h4>
<h2 id="srfi-srfi-61"><code>(srfi srfi-61)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-61/">SRFI-61</a>.</p>
<h3 id="abstract-30">Abstract</h3>
<p>TODO</p>
<h3 id="reference-30">Reference</h3>
<p>TODO ## <code>(srfi srfi-67)</code></p>
<p>This is based on <a href="https://srfi.schemers.org/srfi-67/">SRFI-67</a>.</p>
<h3 id="abstract-31">Abstract</h3>
<p>TODO</p>
<h3 id="reference-31">Reference</h3>
<p>TODO ## <code>(srfi srfi-69)</code></p>
<p>This is based on <a href="https://srfi.schemers.org/srfi-69/">SRFI-69</a>.</p>
<h3 id="abstract-32">Abstract</h3>
<p>TODO</p>
<h3 id="reference-32">Reference</h3>
<p>TODO ## <code>(srfi srfi-98)</code></p>
<p>This is based on <a href="https://srfi.schemers.org/srfi-98/">SRFI-98</a>.</p>
<h3 id="abstract-33">Abstract</h3>
<p>TODO</p>
<h3 id="reference-33">Reference</h3>
<p>TODO ## <code>(srfi srfi-101)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-101/">SRFI-101</a>.</p>
<h3 id="abstract-34">Abstract</h3>
<p>TODO</p>
<h3 id="reference-34">Reference</h3>
<p>TODO ## <code>(srfi srfi-111)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-111/">SRFI-111</a>.</p>
<h3 id="abstract-35">Abstract</h3>
<p>Boxes are objects with a single mutable state. Several Schemes have them, sometimes called cells. A constructor, predicate, accessor, and mutator are provided.</p>
<h3 id="reference-35">Reference</h3>
<h4 id="box-value"><code>(box value)</code></h4>
<p>Constructor. Returns a newly allocated box initialized to value.</p>
<h4 id="box-object"><code>(box? object)</code></h4>
<p>Predicate. Returns <code>#t</code> if object is a box, and <code>#f</code> otherwise.</p>
<h4 id="unbox-box"><code>(unbox box)</code></h4>
<p>Accessor. Returns the current value of box.</p>
<h4 id="set-box-box-value"><code>(set-box! box value)</code></h4>
<p>Mutator. Changes box to hold value. ## <code>(srfi srfi-113)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-113/">SRFI-113</a>.</p>
<h3 id="abstract-36">Abstract</h3>
<p>Sets and bags (also known as multisets) are unordered collections that can contain any Scheme object. Sets enforce the constraint that no two elements can be the same in the sense of the set’s associated equality predicate; bags do not.</p>
<h3 id="reference-36">Reference</h3>
<p>TODO</p>
<h4 id="set">Set</h4>
<h5 id="set-1">set</h5>
<h5 id="set-unfold">set-unfold</h5>
<h5 id="set-2">set?</h5>
<h5 id="set-contains">set-contains?</h5>
<h5 id="set-empty">set-empty?</h5>
<h5 id="set-disjoint">set-disjoint?</h5>
<h5 id="set-member">set-member</h5>
<h5 id="set-element-comparator">set-element-comparator</h5>
<h5 id="set-adjoin">set-adjoin</h5>
<h5 id="set-adjoin-1">set-adjoin!</h5>
<h5 id="set-replace">set-replace</h5>
<h5 id="set-replace-1">set-replace!</h5>
<h5 id="set-delete">set-delete</h5>
<h5 id="set-delete-1">set-delete!</h5>
<h5 id="set-delete-all">set-delete-all</h5>
<h5 id="set-delete-all-1">set-delete-all!</h5>
<h5 id="set-search">set-search!</h5>
<h5 id="set-size">set-size</h5>
<h5 id="set-find">set-find</h5>
<h5 id="set-count">set-count</h5>
<h5 id="set-any">set-any?</h5>
<h5 id="set-every">set-every?</h5>
<h5 id="set-map">set-map</h5>
<h5 id="set-for-each">set-for-each</h5>
<h5 id="set-fold">set-fold</h5>
<h5 id="set-filter">set-filter</h5>
<h5 id="set-remove">set-remove</h5>
<h5 id="set-remove-1">set-remove</h5>
<h5 id="set-partition">set-partition</h5>
<h5 id="set-filter-1">set-filter!</h5>
<h5 id="set-remove-2">set-remove!</h5>
<h5 id="set-partition-1">set-partition!</h5>
<h5 id="set-copy">set-copy</h5>
<h5 id="set-list">set-&gt;list</h5>
<h5 id="list-set">list-&gt;set</h5>
<h5 id="list-set-1">list-&gt;set!</h5>
<h5 id="set-3">set=?</h5>
<h5 id="set-4">set&lt;?</h5>
<h5 id="set-5">set&gt;?</h5>
<h5 id="set-6">set&lt;=?</h5>
<h5 id="set-7">set&gt;=?</h5>
<h5 id="set-union">set-union</h5>
<h5 id="set-intersection">set-intersection</h5>
<h5 id="set-difference">set-difference</h5>
<h5 id="set-xor">set-xor</h5>
<h5 id="set-union-1">set-union!</h5>
<h5 id="set-intersection-1">set-intersection!</h5>
<h5 id="set-difference-1">set-difference!</h5>
<h5 id="set-xor-1">set-xor!</h5>
<h5 id="set-comparator">set-comparator</h5>
<h4 id="bag">Bag</h4>
<h5 id="bag-1">bag</h5>
<h5 id="bag-unfold">bag-unfold</h5>
<h5 id="bag-2">bag?</h5>
<h5 id="bag-contains">bag-contains?</h5>
<h5 id="bag-empty">bag-empty?</h5>
<h5 id="bag-disjoint">bag-disjoint?</h5>
<h5 id="bag-member">bag-member</h5>
<h5 id="bag-element-comparator">bag-element-comparator</h5>
<h5 id="bag-adjoin">bag-adjoin</h5>
<h5 id="bag-adjoin-1">bag-adjoin!</h5>
<h5 id="bag-replace">bag-replace</h5>
<h5 id="bag-replace-1">bag-replace!</h5>
<h5 id="bag-delete">bag-delete</h5>
<h5 id="bag-delete-1">bag-delete!</h5>
<h5 id="bag-delete-all">bag-delete-all</h5>
<h5 id="bag-delete-all-1">bag-delete-all!</h5>
<h5 id="bag-search">bag-search!</h5>
<h5 id="bag-size">bag-size</h5>
<h5 id="bag-find">bag-find</h5>
<h5 id="bag-count">bag-count</h5>
<h5 id="bag-any">bag-any?</h5>
<h5 id="bag-every">bag-every?</h5>
<h5 id="bag-map">bag-map</h5>
<h5 id="bag-for-each">bag-for-each</h5>
<h5 id="bag-fold">bag-fold</h5>
<h5 id="bag-filter">bag-filter</h5>
<h5 id="bag-remove">bag-remove</h5>
<h5 id="bag-partition">bag-partition</h5>
<h5 id="bag-filter-1">bag-filter!</h5>
<h5 id="bag-remove-1">bag-remove!</h5>
<h5 id="bag-partition-1">bag-partition!</h5>
<h5 id="bag-copy">bag-copy</h5>
<h5 id="bag-list">bag-&gt;list</h5>
<h5 id="list-bag">list-&gt;bag</h5>
<h5 id="list-bag-1">list-&gt;bag!</h5>
<h5 id="bag-3">bag=?</h5>
<h5 id="bag-4">bag&lt;?</h5>
<h5 id="bag-5">bag&gt;?</h5>
<h5 id="bag-6">bag&lt;=?</h5>
<h5 id="bag-7">bag&gt;=?</h5>
<h5 id="bag-union">bag-union</h5>
<h5 id="bag-intersection">bag-intersection</h5>
<h5 id="bag-difference">bag-difference</h5>
<h5 id="bag-xor">bag-xor</h5>
<h5 id="bag-union-1">bag-union!</h5>
<h5 id="bag-intersection-1">bag-intersection!</h5>
<h5 id="bag-difference-1">bag-difference!</h5>
<h5 id="bag-xor-1">bag-xor!</h5>
<h5 id="bag-comparator">bag-comparator</h5>
<h5 id="bag-sum">bag-sum</h5>
<h5 id="bag-sum-1">bag-sum!</h5>
<h5 id="bag-product">bag-product</h5>
<h5 id="bag-product-1">bag-product!</h5>
<h5 id="bag-unique-size">bag-unique-size</h5>
<h5 id="bag-element-count">bag-element-count</h5>
<h5 id="bag-for-each-unique">bag-for-each-unique</h5>
<h5 id="bag-fold-unique">bag-fold-unique</h5>
<h5 id="bag-increment">bag-increment!</h5>
<h5 id="bag-decrement">bag-decrement!</h5>
<h5 id="bag-set">bag-&gt;set</h5>
<h5 id="set-bag">set-&gt;bag</h5>
<h5 id="set-bag-1">set-&gt;bag!</h5>
<h5 id="bag-alist">bag-&gt;alist</h5>
<h5 id="alist-bag">alist-&gt;bag</h5>
<h2 id="srfi-srfi-115"><code>(srfi srfi-115)</code></h2>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-115/">SRFI-115</a>.</p>
<h3 id="abstract-37">Abstract</h3>
<p>TODO</p>
<h3 id="reference-37">Reference</h3>
<p>TODO ## <code>(srfi srfi-116)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-116/">SRFI-116</a>.</p>
<h3 id="abstract-38">Abstract</h3>
<p>TODO</p>
<h3 id="reference-38">Reference</h3>
<p>TODO ## <code>(srfi srfi-117)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-117/">SRFI-117</a>.</p>
<h3 id="abstract-39">Abstract</h3>
<p>TODO</p>
<h3 id="reference-39">Reference</h3>
<p>TODO ## <code>(srfi srfi-124)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-124/">SRFI-124</a>.</p>
<h3 id="abstract-40">Abstract</h3>
<p>TODO</p>
<h3 id="reference-40">Reference</h3>
<h4 id="ephemeron-obj"><code>(ephemeron? obj)</code></h4>
<h4 id="make-ephemeron"><code>make-ephemeron</code></h4>
<h4 id="ephemeron-broken"><code>ephemeron-broken?</code></h4>
<h4 id="ephemeron-key"><code>ephemeron-key</code></h4>
<h4 id="ephemeron-value"><code>ephemeron-value</code></h4>
<h2 id="srfi-srfi-125"><code>(srfi srfi-125)</code></h2>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-125/">srfi-125</a>.</p>
<p>The library doesn’t implement deprecated features. Application must rely on <code>(scheme comparator)</code> to specify equal predicate and hash function.</p>
<h3 id="abstract-41">Abstract</h3>
<p>This SRFI defines an interface to hash tables, which are widely recognized as a fundamental data structure for a wide variety of applications. A hash table is a data structure that:</p>
<ul>
<li>Is disjoint from all other types.</li>
<li><p>Provides a mapping from objects known as keys to corresponding objects known as values.</p>
<ul>
<li>Keys may be any Scheme objects in some kinds of hash tables, but are restricted in other kinds.</li>
<li>Values may be any Scheme objects.</li>
</ul></li>
<li>Has no intrinsic order for the key-value associations it contains.</li>
<li>Provides an equality predicate which defines when a proposed key is the same as an existing key. No table may contain more than one value for a given key.</li>
<li>Provides a hash function which maps a candidate key into a non-negative exact integer.</li>
<li>Supports mutation as the primary means of setting the contents of a table.</li>
<li>Provides key lookup and destructive update in (expected) amortized constant time, provided a satisfactory hash function is available.</li>
<li><p>Does not guarantee that whole-table operations work in the presence of concurrent mutation of the whole hash table (values may be safely mutated).</p></li>
</ul>
<h3 id="reference-41">Reference</h3>
<h4 id="constructors-2">Constructors</h4>
<h5 id="make-hash-table-comparator-.-args"><code>(make-hash-table comparator . args)</code></h5>
<p>Returns a newly allocated hash table using <code>(scheme comparator)</code> object <code>COMPARATOR</code>. For the time being, <code>ARGS</code> is ignored.</p>
<h5 id="hash-table-comparator-key-value-..."><code>(hash-table comparator [key value] ...)</code></h5>
<p>Returns a newly allocated hash table using <code>(scheme comparator)</code> object <code>COMPARATOR</code>. For each pair of arguments, an association is added to the new hash table with key as its key and value as its value. If the same key (in the sense of the equality predicate) is specified more than once, it is an error.</p>
<h5 id="hash-table-unfold-stop-mapper-successor-seed-comparator-args-..."><code>(hash-table-unfold stop? mapper successor seed comparator args ...)</code></h5>
<p>Create a new hash table as if by <code>make-hash-table</code> using <code>comparator</code> and the <code>args</code>. If the result of applying the predicate <code>stop?</code> to <code>seed</code> is true, return the hash table. Otherwise, apply the procedure <code>mapper</code> to <code>seed</code>. <code>mapper</code> returns two values, which are inserted into the hash table as the key and the value respectively. Then get a new <code>seed</code> by applying the procedure <code>successor</code> to <code>seed</code>, and repeat this algorithm.</p>
<h5 id="alist-hash-table-alist-comparator-arg-..."><code>(alist-&gt;hash-table alist comparator arg ...)</code></h5>
<p>Returns a newly allocated hash-table as if by <code>make-hash-table</code> using <code>comparator</code> and the <code>args</code>. It is then initialized from the associations of <code>alist</code>. Associations earlier in the list take precedence over those that come later.</p>
<h4 id="predicates-2">Predicates</h4>
<h5 id="hash-table-obj"><code>(hash-table? obj)</code></h5>
<p>Returns #t if obj is a hash table, and #f otherwise</p>
<h5 id="hash-table-contains-hash-table-key"><code>(hash-table-contains? hash-table key)</code></h5>
<p>Returns #t if there is any association to key in hash-table, and #f otherwise.</p>
<h5 id="hash-table-empty-hash-table"><code>(hash-table-empty? hash-table)</code></h5>
<p>Returns #t if hash-table contains no associations, and #f otherwise.</p>
<h5 id="hash-table-value-comparator-hash-table1-hash-table2"><code>(hash-table=? value-comparator hash-table1 hash-table2)</code></h5>
<p>Returns #t if hash-table1 and hash-table2 have the same keys (in the sense of their common equality predicate) and each key has the same value (in the sense of value-comparator), and #f otherwise.</p>
<h5 id="hash-table-mutable-hash-table"><code>(hash-table-mutable? hash-table)</code></h5>
<p>Returns #t if the hash table is mutable.</p>
<h4 id="accessors">Accessors</h4>
<p>The following procedures, given a key, return the corresponding value.</p>
<h5 id="hash-table-ref-hash-table-key-failure-success"><code>(hash-table-ref hash-table key [failure [success]])</code></h5>
<p>Extracts the value associated to key in hash-table, invokes the procedure success on it, and returns its result; if success is not provided, then the value itself is returned. If key is not contained in hash-table and failure is supplied, then failure is invoked on no arguments and its result is returned.</p>
<h5 id="hash-table-refdefault-hash-table-key-default"><code>(hash-table-ref/default hash-table key default)</code></h5>
<p>TODO</p>
<h4 id="mutators">Mutators</h4>
<p>The following procedures alter the associations in a hash table either unconditionally, or conditionally on the presence or absence of a specified key. It is an error to add an association to a hash table whose key does not satisfy the type test predicate of the comparator used to create the hash table.</p>
<h5 id="hash-table-set-hash-table-key-value-..."><code>(hash-table-set! hash-table key value ...)</code></h5>
<p>Repeatedly mutates hash-table, creating new associations in it by processing the arguments from left to right. The args alternate between keys and values. Whenever there is a previous association for a key, it is deleted. It is an error if the type check procedure of the comparator of hash-table, when invoked on a key, does not return #t. Likewise, it is an error if a key is not a valid argument to the equality predicate of hash-table. Returns an unspecified value.</p>
<h5 id="hash-table-delete-hash-table-key-..."><code>(hash-table-delete! hash-table key ...)</code></h5>
<p>Deletes any association to each key in hash-table and returns the number of keys that had associations.</p>
<h5 id="hash-table-intern-hash-table-key-failure"><code>(hash-table-intern! hash-table key failure)</code></h5>
<p>Effectively invokes hash-table-ref with the given arguments and returns what it returns. If key was not found in hash-table, its value is set to the result of calling failure.</p>
<h5 id="hash-table-update-hash-table-key-updater-failure-success"><code>(hash-table-update! hash-table key updater [failure [success]])</code></h5>
<p>TODO:</p>
<h5 id="hash-table-pop-hash-table"><code>(hash-table-pop! hash-table)</code></h5>
<p>Chooses an arbitrary association from hash-table and removes it, returning the key and value as two values.</p>
<p>It is an error if hash-table is empty.</p>
<h5 id="hash-table-clear-hash-table"><code>(hash-table-clear! hash-table)</code></h5>
<p>Delete all the associations from hash-table.</p>
<h4 id="the-whole-hash-table">The whole hash table</h4>
<p>These procedures process the associations of the hash table in an unspecified order.</p>
<h5 id="hash-table-size-hash-table"><code>(hash-table-size hash-table)</code></h5>
<p>Returns the number of associations in hash-table as an exact integer.</p>
<h5 id="hash-table-keys-hash-table"><code>(hash-table-keys hash-table)</code></h5>
<p>Returns a newly allocated list of all the keys in hash-table.</p>
<h5 id="hash-table-values-hash-table"><code>(hash-table-values hash-table)</code></h5>
<p>Returns a newly allocated list of all the keys in hash-table.</p>
<h5 id="hash-table-entries-hash-table"><code>(hash-table-entries hash-table)</code></h5>
<p>Returns two values, a newly allocated list of all the keys in hash-table and a newly allocated list of all the values in hash-table in the corresponding order.</p>
<h5 id="hash-table-find-proc-hash-table-failure"><code>(hash-table-find proc hash-table failure)</code></h5>
<p>For each association of hash-table, invoke proc on its key and value. If proc returns true, then hash-table-find returns what proc returns. If all the calls to proc return #f, return the result of invoking the thunk failure.</p>
<h5 id="hash-table-count-pred-hash-table"><code>(hash-table-count pred hash-table)</code></h5>
<p>For each association of hash-table, invoke pred on its key and value. Return the number of calls to pred which returned true.</p>
<h4 id="mapping-and-folding">Mapping and folding</h4>
<p>These procedures process the associations of the hash table in an unspecified order.</p>
<h5 id="hash-table-map-proc-comparator-hash-table"><code>(hash-table-map proc comparator hash-table)</code></h5>
<p>Returns a newly allocated hash table as if by <code>(make-hash-table comparator)</code>. Calls <code>PROC</code> for every association in <code>hash-table</code> with the value of the association. The key of the association and the result of invoking <code>proc</code> are entered into the new hash table. Note that this is not the result of lifting mapping over the domain of hash tables, but it is considered more useful.</p>
<p>If comparator recognizes multiple keys in the hash-table as equivalent, any one of such associations is taken.</p>
<h5 id="hash-table-for-each-proc-hash-table"><code>(hash-table-for-each proc hash-table)</code></h5>
<p>Calls proc for every association in hash-table with two arguments: the key of the association and the value of the association. The value returned by proc is discarded. Returns an unspecified value.</p>
<h5 id="hash-table-map-proc-hash-table"><code>(hash-table-map! proc hash-table)</code></h5>
<p>Calls proc for every association in hash-table with two arguments: the key of the association and the value of the association. The value returned by proc is used to update the value of the association. Returns an unspecified value.</p>
<h5 id="hash-table-map-list-proc-hash-table"><code>(hash-table-map-&gt;list proc hash-table)</code></h5>
<p>Calls proc for every association in hash-table with two arguments: the key of the association and the value of the association. The values returned by the invocations of proc are accumulated into a list, which is returned.</p>
<h5 id="hash-table-fold-proc-seed-hash-table"><code>(hash-table-fold proc seed hash-table)</code></h5>
<p>Calls proc for every association in hash-table with three arguments: the key of the association, the value of the association, and an accumulated value val. Val is seed for the first invocation of procedure, and for subsequent invocations of proc, the returned value of the previous invocation. The value returned by hash-table-fold is the return value of the last invocation of proc.</p>
<h5 id="hash-table-prune-proc-hash-table"><code>(hash-table-prune! proc hash-table)</code></h5>
<p>Calls proc for every association in hash-table with two arguments, the key and the value of the association, and removes all associations from hash-table for which proc returns true. Returns an unspecified value.</p>
<h4 id="copying-and-conversion">Copying and conversion</h4>
<h5 id="hash-table-copy-hash-table-mutable"><code>(hash-table-copy hash-table [mutable?])</code></h5>
<p>Returns a newly allocated hash table with the same properties and associations as hash-table. If the second argument is present and is true, the new hash table is mutable. Otherwise it is immutable provided that the implementation supports immutable hash tables.</p>
<h5 id="hash-table-empty-copy-hash-table"><code>(hash-table-empty-copy hash-table)</code></h5>
<p>Returns a newly allocated mutable hash table with the same properties as hash-table, but with no associations.</p>
<h5 id="hash-table-alist-hash-table"><code>(hash-table-&gt;alist hash-table)</code></h5>
<p>Returns an alist with the same associations as hash-table in an unspecified order.</p>
<h4 id="hash-tables-as-sets">Hash tables as sets</h4>
<h5 id="hash-table-union-hash-table1-hash-table2"><code>(hash-table-union! hash-table1 hash-table2)</code></h5>
<p>Adds the associations of hash-table2 to hash-table1 and returns hash-table1. If a key appears in both hash tables, its value is set to the value appearing in hash-table1. Returns hash-table1.</p>
<h5 id="hash-table-intersection-hash-table1-hash-table2"><code>(hash-table-intersection! hash-table1 hash-table2)</code></h5>
<p>Deletes the associations from hash-table1 whose keys don’t also appear in hash-table2 and returns hash-table1.</p>
<h5 id="hash-table-difference-hash-table1-hash-table2"><code>(hash-table-difference! hash-table1 hash-table2)</code></h5>
<p>Deletes the associations of hash-table1 whose keys are also present in hash-table2 and returns hash-table1.</p>
<h5 id="hash-table-xor-hash-table1-hash-table2"><code>(hash-table-xor! hash-table1 hash-table2)</code></h5>
<p>Deletes the associations of hash-table1 whose keys are also present in hash-table2, and then adds the associations of hash-table2 whose keys are not present in hash-table1 to hash-table1. Returns hash-table1. ## <code>(srfi srfi-127)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-127/">SRFI-127</a>.</p>
<h3 id="abstract-42">Abstract</h3>
<p>TODO</p>
<h3 id="reference-42">Reference</h3>
<p>TODO ## <code>(srfi srfi-128)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-128/">SRFI-128</a>.</p>
<h3 id="abstract-43">Abstract</h3>
<p>A comparator is an object of a disjoint type. It is a bundle of procedures that are useful for comparing two objects either for equality or for ordering. There are four procedures in the bundle:</p>
<ul>
<li><p>The type test predicate returns #t if its argument has the correct type to be passed as an argument to the other three procedures, and #f otherwise.</p></li>
<li><p>The equality predicate returns #t if the two objects are the same in the sense of the comparator, and #f otherwise. It is the programmer’s responsibility to ensure that it is reflexive, symmetric, transitive, and can handle any arguments that satisfy the type test predicate.</p></li>
<li><p>The comparison procedure returns -1, 0, or 1 if the first object precedes the second, is equal to the second, or follows the second, respectively, in a total order defined by the comparator. It is the programmer’s responsibility to ensure that it is reflexive, weakly antisymmetric, transitive, can handle any arguments that satisfy the type test predicate, and returns 0 iff the equality predicate returns #t.</p></li>
<li><p>The hash function takes one argument, and returns an exact non-negative integer. It is the programmer’s responsibility to ensure that it can handle any argument that satisfies the type test predicate, and that it returns the same value on two objects if the equality predicate says they are the same (but not necessarily the converse).</p></li>
</ul>
<p>It is also the programmer’s responsibility to ensure that all four procedures provide the same result whenever they are applied to the same object(s) (in the sense of eqv?), unless the object(s) have been mutated since the last invocation. In particular, they must not depend in any way on memory addresses in implementations where the garbage collector can move objects in memory.</p>
<p><strong>Limitations</strong></p>
<p>The comparator objects defined in this library are not applicable to circular structure or to NaNs or objects containing them. Attempts to pass any such objects to any procedure defined here, or to any procedure that is part of a comparator defined here, is an error except as otherwise noted.</p>
<h3 id="reference-43">Reference</h3>
<h4 id="predicates-3">Predicates</h4>
<h5 id="comparator-obj"><code>(comparator? obj)</code></h5>
<p>Returns #t if obj is a comparator, and #f otherwise.</p>
<h5 id="comparator-comparison-procedure-comparator"><code>(comparator-comparison-procedure? comparator)</code></h5>
<p>Returns #t if comparator has a supplied comparison procedure, and #f otherwise.</p>
<h5 id="comparator-hash-function-comparator"><code>(comparator-hash-function? comparator)</code></h5>
<p>Returns #t if comparator has a supplied hash function, and #f otherwise.</p>
<h4 id="standard-comparators">Standard comparators</h4>
<h5 id="boolean-comparator"><code>boolean-comparator</code></h5>
<p>Compares booleans using the total order #f &lt; #t.</p>
<h5 id="char-comparator"><code>char-comparator</code></h5>
<p>Compares characters using the total order implied by char&lt;?. On R6RS and R7RS systems, this is Unicode codepoint order.</p>
<h5 id="char-ci-comparator"><code>char-ci-comparator</code></h5>
<p>Compares characters using the total order implied by char-ci&lt;? On R6RS and R7RS systems, this is Unicode codepoint order after the characters have been folded to lower case.</p>
<h5 id="string-comparator"><code>string-comparator</code></h5>
<p>Compares strings using the total order implied by string&lt;?. Note that this order is implementation-dependent.</p>
<h5 id="string-ci-comparator"><code>string-ci-comparator</code></h5>
<p>Compares strings using the total order implied by string-ci&lt;?. Note that this order is implementation-dependent.</p>
<h5 id="symbol-comparator"><code>symbol-comparator</code></h5>
<p>Compares symbols using the total order implied by applying symbol-&gt;string to the symbols and comparing them using the total order implied by string&lt;?. It is not a requirement that the hash function of symbol-comparator be consistent with the hash function of string-comparator, however.</p>
<h5 id="exact-integer-comparator"><code>exact-integer-comparator</code></h5>
<h5 id="integer-comparator"><code>integer-comparator</code></h5>
<h5 id="rational-comparator"><code>rational-comparator</code></h5>
<h5 id="real-comparator"><code>real-comparator</code></h5>
<h5 id="complex-comparator"><code>complex-comparator</code></h5>
<h5 id="number-comparator"><code>number-comparator</code></h5>
<p>These comparators compare exact integers, integers, rational numbers, real numbers, complex numbers, and any numbers using the total order implied by &lt;. They must be compatible with the R5RS numerical tower in the following sense: If S is a subtype of the numerical type T and the two objects are members of S , then the equality predicate and comparison procedures (but not necessarily the hash function) of S-comparator and T-comparator compute the same results on those objects.</p>
<p>Since non-real numbers cannot be compared with &lt;, the following least-surprising ordering is defined: If the real parts are &lt; or &gt;, so are the numbers; otherwise, the numbers are ordered by their imaginary parts. This can still produce surprising results if one real part is exact and the other is inexact.</p>
<h5 id="pair-comparator"><code>pair-comparator</code></h5>
<p>This comparator compares pairs using default-comparator (see below) on their cars. If the cars are not equal, that value is returned. If they are equal, default-comparator is used on their cdrs and that value is returned.</p>
<h5 id="list-comparator"><code>list-comparator</code></h5>
<p>This comparator compares lists lexicographically, as follows:</p>
<ul>
<li>The empty list compares equal to itself.</li>
<li>The empty list compares less than any non-empty list.</li>
<li>Two non-empty lists are compared by comparing their cars. If the cars are not equal when compared using default-comparator (see below), then the result is the result of that comparison. Otherwise, the cdrs are compared using list-comparator.</li>
</ul>
<h5 id="vector-comparator"><code>vector-comparator</code></h5>
<h5 id="bytevector-comparator"><code>bytevector-comparator</code></h5>
<p>These comparators compare vectors and bytevectors by comparing their lengths. A shorter argument is always less than a longer one. If the lengths are equal, then each element is compared in turn using default-comparator (see below) until a pair of unequal elements is found, in which case the result is the result of that comparison. If all elements are equal, the arguments are equal.</p>
<p>If the implementation does not support bytevectors, bytevector-comparator has a type testing procedure that always returns #f.</p>
<h4 id="the-default-comparator">The default comparator</h4>
<h5 id="default-comparator"><code>default-comparator</code></h5>
<p>This is a comparator that accepts any two Scheme values (with the exceptions listed in the Limitations section) and orders them in some implementation-defined way, subject to the following conditions:</p>
<ul>
<li><p>The following ordering between types must hold: the empty list precedes pairs, which precede booleans, which precede characters, which precede strings, which precede symbols, which precede numbers, which precede vectors, which precede bytevectors, which precede all other objects.</p></li>
<li><p>When applied to pairs, booleans, characters, strings, symbols, numbers, vectors, or bytevectors, its behavior must be the same as pair-comparator, boolean-comparator, character-comparator, string-comparator, symbol-comparator, number-comparator, vector-comparator, and bytevector-comparator respectively. The same should be true when applied to an object or objects of a type for which a standard comparator is defined elsewhere.</p></li>
<li><p>Given disjoint types a and b, one of three conditions must hold:</p>
<ul>
<li>All objects of type a compare less than all objects of type b.</li>
<li>All objects of type a compare greater than all objects of type b.</li>
<li>All objects of either type a or type b compare equal to each other. This is not permitted for any of the standard types mentioned above.</li>
</ul></li>
</ul>
<h4 id="comparator-constructors">Comparator constructors</h4>
<h5 id="make-comparator-type-test-equality-compare-hash"><code>(make-comparator type-test equality compare hash)</code></h5>
<p>Returns a comparator which bundles the type-test, equality, compare, and hash procedures provided. As a convenience, the following additional values are accepted:</p>
<ul>
<li>If type-test is #t, a type-test procedure that accepts any arguments is provided.</li>
<li>If equality is #t, an equality predicate is provided that returns #t iff compare returns 0.</li>
<li>If compare or hash is #f, a procedure is provided that signals an error on application. The predicates comparator-comparison-procedure? and/or comparator-hash-function?, respectively, will return #f in these cases.</li>
</ul>
<h5 id="make-inexact-real-comparator-epsilon-rounding-nan-handling"><code>(make-inexact-real-comparator epsilon rounding nan-handling)</code></h5>
<p>Returns a comparator that compares inexact real numbers including NaNs as follows: if after rounding to the nearest epsilon they are the same, they compare equal; otherwise they compare as specified by &lt;. The direction of rounding is specified by the rounding argument, which is either a procedure accepting two arguments (the number and epsilon, or else one of the symbols floor, ceiling, truncate, or round.</p>
<p>The argument nan-handling specifies how to compare NaN arguments to non-NaN arguments. If it is a procedure, the procedure is invoked on the other argument if either argument is a NaN. If it is the symbol min, NaN values precede all other values; if it is the symbol max, they follow all other values, and if it is the symbol error, an error is signaled if a NaN value is compared. If both arguments are NaNs, however, they always compare as equal.</p>
<h5 id="make-list-comparator-element-comparator"><code>(make-list-comparator element-comparator)</code></h5>
<h5 id="make-vector-comparator-element-comparator"><code>(make-vector-comparator element-comparator)</code></h5>
<h5 id="make-bytevector-comparator-element-comparator"><code>(make-bytevector-comparator element-comparator)</code></h5>
<p>These procedures return comparators which compare two lists, vectors, or bytevectors in the same way as list-comparator, vector-comparator, and bytevector-comparator respectively, but using element-comparator rather than default-comparator.</p>
<p>If the implementation does not support bytevectors, the result of invoking make-bytevector-comparator is a comparator whose type testing procedure always returns #f.</p>
<h5 id="make-listwise-comparator-type-test-element-comparator-empty-head-tail"><code>(make-listwise-comparator type-test element-comparator empty? head tail)</code></h5>
<p>Returns a comparator which compares two objects that satisfy type-test as if they were lists, using the empty? procedure to determine if an object is empty, and the head and tail procedures to access particular elements.</p>
<h5 id="make-vectorwise-comparator-type-test-element-comparator-length-ref"><code>(make-vectorwise-comparator type-test element-comparator length ref)</code></h5>
<p>Returns a comparator which compares two objects that satisfy type-test as if they were vectors, using the length procedure to determine the length of the object, and the ref procedure to access a particular element.</p>
<h5 id="make-car-comparator-comparator"><code>(make-car-comparator comparator)</code></h5>
<p>Returns a comparator that compares pairs on their cars alone using comparator.</p>
<h5 id="make-cdr-comparator-comparator"><code>(make-cdr-comparator comparator)</code></h5>
<p>Returns a comparator that compares pairs on their cdrs alone using comparator.</p>
<h5 id="make-pair-comparator-car-comparator-cdr-comparator"><code>(make-pair-comparator car-comparator cdr-comparator)</code></h5>
<p>Returns a comparator that compares pairs first on their cars using car-comparator. If the cars are equal, it compares the cdrs using cdr-comparator.</p>
<h5 id="make-improper-list-comparator-element-comparator"><code>(make-improper-list-comparator element-comparator)</code></h5>
<p>Returns a comparator that compares arbitrary objects as follows: the empty list precedes all pairs, which precede all other objects. Pairs are compared as if with (make-pair-comparator element-comparator element-comparator). All other objects are compared using element-comparator.</p>
<h5 id="make-selecting-comparator-comparator1-comparator2-..."><code>(make-selecting-comparator comparator1 comparator2 ...)</code></h5>
<p>Returns a comparator whose procedures make use of the comparators as follows:</p>
<p>The type test predicate passes its argument to the type test predicates of comparators in the sequence given. If any of them returns #t, so does the type test predicate; otherwise, it returns #f.</p>
<p>The arguments of the equality, compare, and hash functions are passed to the type test predicate of each comparator in sequence. The first comparator whose type test predicate is satisfied on all the arguments is used when comparing those arguments. All other comparators are ignored. If no type test predicate is satisfied, an error is signaled.</p>
<h5 id="make-refining-comparator-comparator1-comparator2-..."><code>(make-refining-comparator comparator1 comparator2 ...)</code></h5>
<p>Returns a comparator that makes use of the comparators in the same way as make-selecting-comparator, except that its procedures can look past the first comparator whose type test predicate is satisfied. If the comparison procedure of that comparator returns zero, then the next comparator whose type test predicate is satisfied is tried in place of it until one returns a non-zero value. If there are no more such comparators, then the comparison procedure returns zero. The equality predicate is defined in the same way. If no type test predicate is satisfied, an error is signaled.</p>
<p>The hash function of the result returns a value which depends, in an implementation-defined way, on the results of invoking the hash functions of the comparators whose type test predicates are satisfied on its argument. In particular, it may depend solely on the first or last such hash function. If no type test predicate is satisfied, an error is signaled.</p>
<p>This procedure is analogous to the expression type refine-compare from SRFI 67.</p>
<h5 id="make-reverse-comparator-comparator"><code>(make-reverse-comparator comparator)</code></h5>
<p>Returns a comparator that behaves like comparator, except that the compare procedure returns 1, 0, and -1 instead of -1, 0, and 1 respectively. This allows ordering in reverse.</p>
<h5 id="make-debug-comparator-comparator"><code>(make-debug-comparator comparator)</code></h5>
<p>Returns a comparator that behaves exactly like comparator, except that whenever any of its procedures are invoked, it verifies all the programmer responsibilities (except stability), and an error is signaled if any of them are violated. Because it requires three arguments, transitivity is not tested on the first call to a debug comparator; it is tested on all future calls using an arbitrarily chosen argument from the previous invocation. Note that this may cause unexpected storage leaks.</p>
<h4 id="wrapped-equality-predicates">Wrapped equality predicates</h4>
<h5 id="eq-comparator"><code>eq-comparator</code></h5>
<h5 id="eqv-comparator"><code>eqv-comparator</code></h5>
<h5 id="equal-comparator"><code>equal-comparator</code></h5>
<p>The equality predicates of these comparators are eq?, eqv?, and equal? respectively. When their comparison procedures are applied to non-equal objects, their behavior is implementation-defined. The type test predicates always return #t.</p>
<p>These comparators accept circular structure (in the case of equal-comparator, provided the implementation’s equal does so) and NaNs.</p>
<h4 id="accessors-1">Accessors</h4>
<h5 id="comparator-type-test-procedure-comparator"><code>(comparator-type-test-procedure comparator)</code></h5>
<p>Returns the type test predicate of comparator.</p>
<h5 id="comparator-equality-predicate-comparator"><code>(comparator-equality-predicate comparator)</code></h5>
<p>Returns the equality predicate of comparator.</p>
<h5 id="comparator-comparison-procedure-comparator-1"><code>(comparator-comparison-procedure comparator)</code></h5>
<p>Returns the comparison procedure of comparator.</p>
<h5 id="comparator-hash-function-comparator-1"><code>(comparator-hash-function comparator)</code></h5>
<p>Returns the hash function of comparator.</p>
<h4 id="primitive-applicators">Primitive applicators</h4>
<h5 id="comparator-test-type-comparator-obj"><code>(comparator-test-type comparator obj)</code></h5>
<p>Invokes the type test predicate of comparator on obj and returns what it returns.</p>
<h5 id="comparator-check-type-comparator-obj"><code>(comparator-check-type comparator obj)</code></h5>
<p>Invokes the type test predicate of comparator on obj and returns true if it returns true and signals an error otherwise.</p>
<h5 id="comparator-equal-comparator-obj1-obj2"><code>(comparator-equal? comparator obj1 obj2)</code></h5>
<p>Invokes the equality predicate of comparator on obj1 and obj2 and returns what it returns.</p>
<h5 id="comparator-compare-comparator-obj1-obj2"><code>(comparator-compare comparator obj1 obj2)</code></h5>
<p>Invokes the comparison procedure of comparator on obj1 and obj2 and returns what it returns.</p>
<h5 id="comparator-hash-comparator-obj"><code>(comparator-hash comparator obj)</code></h5>
<p>Invokes the hash function of comparator on obj and returns what it returns.</p>
<h4 id="comparison-procedure-constructors">Comparison procedure constructors</h4>
<h5 id="make-comparison-lt-pred"><code>(make-comparison&lt; lt-pred)</code></h5>
<h5 id="make-comparison-gt-pred"><code>(make-comparison&gt; gt-pred)</code></h5>
<h5 id="make-comparison-le-pred"><code>(make-comparison&lt;= le-pred)</code></h5>
<h5 id="make-comparison-ge-pred"><code>(make-comparison&gt;= ge-pred)</code></h5>
<h5 id="make-comparison-eq-pred-lt-pred"><code>(make-comparison=/&lt; eq-pred lt-pred)</code></h5>
<h5 id="make-comparison-eq-pred-gt-pred"><code>(make-comparison=/&gt; eq-pred gt-pred)</code></h5>
<p>These procedures return a comparison procedure, given a less-than predicate, a greater-than predicate, a less-than-or-equal-to predicate, a greater-than-or-equal-to predicate, or the combination of an equality predicate and either a less-than or a greater-than predicate.</p>
<h4 id="comparison-syntax">Comparison syntax</h4>
<p>The following expression types allow the convenient use of comparison procedures.</p>
<h5 id="if3-expr-less-equal-greater"><code>(if3 &lt;expr&gt; &lt;less&gt; &lt;equal&gt; &lt;greater&gt;)</code></h5>
<p>The expression <code>&lt;expr&gt;</code> is evaluated; it will typically, but not necessarily, be a call on a comparison procedure. If the result is -1, <code>&lt;less&gt;</code> is evaluated and its value(s) are returned; if the result is 0, <code>&lt;equal&gt;</code> is evaluated and its value(s) are returned; if the result is 1, <code>&lt;greater&gt;</code> is evaluated and its value(s) are returned. Otherwise an error is signaled.</p>
<h5 id="if-expr-consequent-alternate"><code>(if=? &lt;expr&gt; &lt;consequent&gt; [ &lt;alternate&gt; ])</code></h5>
<h5 id="if-expr-consequent-alternate-1"><code>(if&lt;? &lt;expr&gt; &lt;consequent&gt; [ &lt;alternate&gt; ])</code></h5>
<h5 id="if-expr-consequent-alternate-2"><code>(if&gt;? &lt;expr&gt; &lt;consequent&gt; [ &lt;alternate&gt; ])</code></h5>
<h5 id="if-expr-consequent-alternate-3"><code>(if&lt;=? &lt;expr&gt; &lt;consequent&gt; [ &lt;alternate&gt; ])</code></h5>
<h5 id="if-expr-consequent-alternate-4"><code>(if&gt;=? &lt;expr&gt; &lt;consequent&gt; [ &lt;alternate&gt; ])</code></h5>
<h5 id="if-not-expr-consequent-alternate"><code>(if-not=? &lt;expr&gt; &lt;consequent&gt; [ &lt;alternate&gt; ])</code></h5>
<p>The expression <code>&lt;expr&gt;</code> is evaluated; it will typically, but not necessarily, be a call on a comparison procedure. It is an error if its value is not -1, 0, or 1. If the value is consistent with the specified relation, <code>&lt;consequent&gt;</code> is evaluated and its value(s) are returned. Otherwise, if <code>&lt;alternate&gt;</code> is present, it is evaluated and its value(s) are returned; if it is absent, an unspecified value is returned.</p>
<h4 id="comparison-predicates">Comparison predicates</h4>
<h5 id="comparator-object1-object2-object3-..."><code>(=? comparator object1 object2 object3 ...)</code></h5>
<h5 id="comparator-object1-object2-object3-...-1"><code>(&lt;? comparator object1 object2 object3 ...)</code></h5>
<h5 id="comparator-object1-object2-object3-...-2"><code>(&gt;? comparator object1 object2 object3 ...)</code></h5>
<h5 id="comparator-object1-object2-object3-...-3"><code>(&lt;=? comparator object1 object2 object3 ...)</code></h5>
<h5 id="comparator-object1-object2-object3-...-4"><code>(&gt;=? comparator object1 object2 object3 ...)</code></h5>
<p>These procedures are analogous to the number, character, and string comparison predicates of Scheme. They allow the convenient use of comparators in situations where the expression types are not usable. They are also analogous to the similarly named procedures SRFI 67, but handle arbitrary numbers of arguments, which in SRFI 67 requires the use of the variants whose names begin with chain.</p>
<p>These procedures apply the comparison procedure of comparator to the objects as follows. If the specified relation returns #t for all objecti and objectj where n is the number of objects and 1 &lt;= i &lt; j &lt;= n, then the procedures return #t, but otherwise #f.</p>
<p>The order in which the values are compared is unspecified. Because the relations are transitive, it suffices to compare each object with its successor.</p>
<h4 id="comparison-predicate-constructors">Comparison predicate constructors</h4>
<h5 id="make-comparator"><code>(make=? comparator)</code></h5>
<h5 id="make-comparator-1"><code>(make&lt;? comparator)</code></h5>
<h5 id="make-comparator-2"><code>(make&gt;? comparator)</code></h5>
<h5 id="make-comparator-3"><code>(make&lt;=? comparator)</code></h5>
<h5 id="make-comparator-4"><code>(make&gt;=? comparator)</code></h5>
<p>These procedures return predicates which, when applied to two or more arguments, return #t if comparing obj1 and obj2 using the equality or comparison procedures of comparator shows that the objects bear the specified relation to one another. Such predicates can be used in contexts that do not understand or expect comparators.</p>
<h4 id="interval-ternary-comparison-predicates">Interval (ternary) comparison predicates</h4>
<p>These procedures return true or false depending on whether an object is contained in an open, closed, or half-open interval. All comparisons are done in the sense of comparator, which is default-comparator if omitted.</p>
<h5 id="in-open-interval-comparator-obj1-obj2-obj3"><code>(in-open-interval? [comparator] obj1 obj2 obj3)</code></h5>
<p>Return #t if obj1 is less than obj2, which is less thanobj3, and #f otherwise.</p>
<h5 id="in-closed-interval-comparator-obj1-obj2-obj3"><code>(in-closed-interval? [comparator] obj1 obj2 obj3)</code></h5>
<p>Returns #t if obj1 is less than or equal to obj2, which is less than or equal to obj3, and #f otherwise.</p>
<h5 id="in-open-closed-interval-comparator-obj1-obj2-obj3"><code>(in-open-closed-interval? [comparator] obj1 obj2 obj3)</code></h5>
<p>Returns #t if obj1 is less than obj2, which is less than or equal to obj3, and #f otherwise.</p>
<h5 id="in-closed-open-interval-comparator-obj1-obj2-obj3"><code>(in-closed-open-interval? [comparator] obj1 obj2 obj3)</code></h5>
<p>Returns #t if obj1 is less than or equal to obj2, which is less than obj3, and #f otherwise.</p>
<h4 id="minmax-comparison-procedures">Min/max comparison procedures</h4>
<h5 id="comparator-min-comparator-object1-object2-..."><code>(comparator-min comparator object1 object2 ...)</code></h5>
<h5 id="comparator-max-comparator-object1-object2-..."><code>(comparator-max comparator object1 object2 ...)</code></h5>
<p>These procedures are analogous to min and max respectively. They apply the comparison procedure of comparator to the objects to find and return a minimal (or maximal) object. The order in which the values are compared is unspecified. ## <code>(srfi srfi-132)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-132/">SRFI-132</a>.</p>
<h3 id="abstract-44">Abstract</h3>
<p>TODO</p>
<h3 id="reference-44">Reference</h3>
<p>TODO ## <code>(srfi srfi-133)</code></p>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-133/">SRFI-133</a>.</p>
<h3 id="abstract-45">Abstract</h3>
<p>TODO</p>
<h3 id="reference-45">Reference</h3>
<p>TODO</p>
