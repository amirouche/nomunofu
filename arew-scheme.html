<h1 id="nomunofu">nomunofu</h1>
<p><strong>status: wip</strong></p>
<p>Querying wikidata made easy</p>
<div class="figure">
<img src="https://raw.githubusercontent.com/amirouche/nomunofu/wip-chez/origami-frogs.jpg" alt="two origami frogs, one on top of the other" />
<p class="caption">two origami frogs, one on top of the other</p>
</div>
<p>nomunofu is database server written in Scheme programming language that is powered by WiredTiger ordered key-value store, based on <a href="https://srfi.schemers.org/srfi-167/">SRFI-167</a> and <a href="https://srfi.schemers.org/srfi-168/">SRFI-168</a>.</p>
<p>It allows to store and query triples, quads <strong>and more</strong>. The goal is to make it much easier, definitely faster to query as much as possible tuples. To achieve that goal, the server part of the database is made very simple, and it only knows how to do pattern matching and count, sum and average aggregation. Also, it is possible to swap the storage engine to something that is horizontally scalable and resilient (read: <a href="https://apple.github.io/foundationdb/">FoundationDB</a>).</p>
<p>The <em>thin server</em>, <em>thick client</em> paradigm was choosen to allow the end-user to more easily workaround bugs in the data, and it also allows to offload the servers hosting the data from heavy computations.</p>
<p>Happy hacking!</p>
<p><a href="mailto:amirouche@hyper.dev">Amirouche</a> ~ zig ~ https://hyper.dev</p>
<h2 id="scheme-base"><code>(scheme base)</code></h2>
<h3 id="section"><code>_</code></h3>
<p>TODO (missing in r7rs?)</p>
<h3 id="section-1"><code>...</code></h3>
<p>It is called ellipsis. It signify that a pattern must be repeated.</p>
<h3 id="section-2"><code>=&gt;</code></h3>
<p>TODO</p>
<h3 id="else"><code>else</code></h3>
<p>Used in <code>cond</code> and <code>case</code> form as in the last clause as a fallback.</p>
<h3 id="number-..."><code>(* number ...)</code></h3>
<p>Multiplication procedure.</p>
<h3 id="number-...-1"><code>(+ number ...)</code></h3>
<p>Addition procedure.</p>
<h3 id="number-...-2"><code>(- number ...)</code></h3>
<p>Substraction procedure.</p>
<h3 id="number-number-..."><code>(/ number number ...)</code></h3>
<p>Division procedure. Raise <code>'numerical-overflow</code> condition in case where denominator is zero.</p>
<h3 id="number-number-...-1"><code>(&lt; number number ...)</code></h3>
<p>Less than procedure. Return a boolean.</p>
<h3 id="number-number-...-2"><code>(&lt;= number number ...)</code></h3>
<p>Less than or equal procedure. Return a boolean.</p>
<h3 id="number-number-...-3"><code>(= number number ...)</code></h3>
<p>Return <code>#t</code> if the numbers passed as parameters are equal. And <code>#f</code> otherwise.</p>
<h3 id="number-number-...-4"><code>(&gt; number number ...)</code></h3>
<p>Greater than procedure. Return a boolean.</p>
<h3 id="number-number-...-5"><code>(&gt;= number number ...)</code></h3>
<p>Greater than or equal. Return a boolean.</p>
<h3 id="abs-number"><code>(abs number)</code></h3>
<p>Return the absolute value of <code>NUMBER</code>.</p>
<h3 id="and-test1-...-syntax"><code>(and test1 ...)</code> syntax</h3>
<p>The <code>test</code> expressions are evaluated from left to right, and if any expression evaluates to <code>#f</code>, then #f is returned. Any remaining expressions are not evaluated. If all the expressions evaluate to true values, the values of the last expression are returned. If there are no expressions, then <code>#t</code> is returned.</p>
<h3 id="append-lst-..."><code>(append lst ...)</code></h3>
<p>Return the list made of the list passed as parameters in the same order.</p>
<h3 id="apply-proc-arg1-...-args"><code>(apply proc arg1 ... args)</code></h3>
<p>The apply procedure calls proc with the elements of the list <code>(append (list arg1 ...) args)</code> as the actual arguments.</p>
<h3 id="assoc-obj-alist"><code>(assoc obj alist)</code></h3>
<p>Return the first pair which <code>car</code> is equal to <code>OBJ</code> according to the predicate <code>equal?</code>. Or it returns <code>#f</code>.</p>
<h3 id="assq-obj-alist"><code>(assq obj alist)</code></h3>
<p>Return the first pair which <code>car</code> is equal to <code>OBJ</code> according to the predicate <code>eq?</code>. Or it returns <code>#f</code>.</p>
<h3 id="assv-obj-alist"><code>(assv obj alist)</code></h3>
<p>Return the first pair which <code>car</code> is equal to <code>OBJ</code> according to the predicate <code>eqv?</code>. Or it returns <code>#f</code>.</p>
<h3 id="begin-syntax"><code>begin</code> syntax</h3>
<p>There is two uses of <code>begin</code>.</p>
<h4 id="begin-expression-or-definition-..."><code>(begin expression-or-definition ...)</code></h4>
<p>This form of begin can appear as part of a body, or at the outermost level of a program, or at the REPL, or directly nested in a begin that is itself of this form. It causes the contained expressions and definitions to be evaluated exactly as if the enclosing begin construct were not present.</p>
<p>TODO: example</p>
<h4 id="begin-expression1-expression2-..."><code>(begin expression1 expression2 ...)</code></h4>
<p>This form of begin can be used as an ordinary expression. The expressions are evaluated sequentially from left to right, and the values of the last expression are returned. This expression type is used to sequence side effects such as assignments or input and output.</p>
<p>TODO: example</p>
<h3 id="binary-port"><code>binary-port?</code></h3>
<p>TODO: not implemented</p>
<h3 id="boolean-obj-..."><code>(boolean=? obj ...)</code></h3>
<p>Return <code>#t</code> if the scheme objects passed as arguments are the same boolean. Otherwise it return <code>#f</code>.</p>
<h3 id="boolean-obj"><code>(boolean? obj)</code></h3>
<p>Return <code>#t</code> if <code>OBJ</code> is a boolean. Otherwise <code>#f</code>.</p>
<h3 id="bytevector-byte-..."><code>(bytevector byte ...)</code></h3>
<p>Returns a newly allocated bytevector containing its arguments.</p>
<h3 id="bytevector-append-bytevector-..."><code>(bytevector-append bytevector ...)</code></h3>
<p>Returns a newly allocated bytevector whose elements arethe concatenation of the elements in the given bytevectors.</p>
<h3 id="bytevector-copy-bytevector-start-end"><code>(bytevector-copy bytevector [start [end]])</code></h3>
<p>Returns a newly allocated bytevector containing the bytes in bytevector between start and end.</p>
<h3 id="bytevector-copy-to-at-from-start-end"><code>(bytevector-copy! to at from [start [end]])</code></h3>
<p>Copies the bytes of bytevector <code>from</code> between <code>start</code> and <code>end</code> to bytevector <code>TO</code>, starting at <code>at</code>. The order in which bytes are copied is unspecified, except that if the source and destination overlap, copying takes place as if the source is first copied into a temporary bytevector and then into the destination. This can be achieved without allocating storage by making sure to copy in the correct direction in such circumstances.</p>
<h3 id="bytevector-length-bytevector"><code>(bytevector-length bytevector)</code></h3>
<p>Returns the length of bytevector in bytes as an exact integer.</p>
<h3 id="bytevector-u8-ref-bytevector-index"><code>(bytevector-u8-ref bytevector index)</code></h3>
<p>Returns the <code>K</code>th byte of <code>BYTEVECTOR</code>. It is an error if <code>K</code> is not a valid index of <code>BYTEVECTOR</code>.</p>
<h3 id="bytevector-u8-set-bytevector-index-byte"><code>(bytevector-u8-set! bytevector index byte)</code></h3>
<p>Stores <code>BYTE</code> as the <code>K</code>th byte of <code>BYTEVECTOR</code>.</p>
<p>It is an error if <code>K</code> is not a valid index of <code>BYTEVECTOR</code>.</p>
<h3 id="bytevector-obj"><code>(bytevector? obj)</code></h3>
<p>Returns <code>#t</code> if <code>OBJ</code> is a bytevector. Otherwise, <code>#f</code> is returned.</p>
<h3 id="caar-obj"><code>(caar obj)</code></h3>
<p>TODO</p>
<h3 id="cadr-obj"><code>(cadr obj)</code></h3>
<p>TODO</p>
<h3 id="call-with-current-continuation-proc"><code>(call-with-current-continuation proc)</code></h3>
<p>It is an error if <code>PROC</code> does not accept one argument.</p>
<p>The procedure call-with-current-continuation (or its equivalent abbreviation <code>call/cc</code>) packages the current continuation (see the rationale below) as an “escape procedure” and passes it as an argument to proc. The escape procedure is a Scheme procedure that, if it is later called, will abandon whatever continuation is in effect at that later time and will instead use the continuation that was in effect when the escape procedure was created. Calling the escape procedure will cause the invocation of before and after thunks installed using dynamic-wind.</p>
<p>The escape procedure accepts the same number of arguments as the continuation to the original call to call-with-current-continuation. Most continuations take only one value. Continuations created by the call-with-values procedure (including the initialization expressions of define-values, let-values, and let<em>-values expressions), take the number of values that the consumer expects. The continuations of all non-final expressions within a sequence of expressions, such as in lambda, case-lambda, begin, let, let</em>, letrec, letrec<em>, let-values, let</em>-values, let-syntax, letrec-syntax, parameterize, guard, case, cond, when, and unless expressions, take an arbitrary number of values because they discard the values passed to them in any event. The effect of passing no values or more than one value to continuations that were not created in one of these ways is unspecified.</p>
<p>The escape procedure that is passed to proc has unlimited extent just like any other procedure in Scheme. It can be stored in variables or data structures and can be called as many times as desired. However, like the raise and error procedures, it never returns to its caller.</p>
<p>TODO: example</p>
<h3 id="call-with-port-port-proc"><code>(call-with-port port proc)</code></h3>
<p>The <code>call-with-port</code> procedure calls <code>PROC</code> with <code>PORT</code> as an argument. If <code>PROC</code> returns, then the <code>PORT</code> is closed automatically and the values yielded by the <code>PROC</code> are returned. If <code>PROC</code> does not return, then the <code>PORT</code> must not be closed automatically unless it is possible to prove that the port will never again be used for a read or write operation.</p>
<p>It is an error if <code>PROC</code> does not accept one argument.</p>
<h3 id="call-with-values-producer-consumer"><code>(call-with-values producer consumer)</code></h3>
<p>Calls its producer argument with no arguments and a continuation that, when passed some values, calls the consumer procedure with those values as arguments. The continuation for the call to consumer is the continuation of the call to <code>call-with-values</code>.</p>
<h3 id="callcc-proc"><code>(call/cc proc)</code></h3>
<p>Abbreviation for <code>call-with-continuation</code>.</p>
<h3 id="car-obj"><code>(car obj)</code></h3>
<p>Returns the contents of the car field ofpair. Note that it is an error to take the <code>car</code> of the empty list.</p>
<h3 id="case-key-clause1-clause2-...-syntax"><code>(case &lt;key&gt; &lt;clause1&gt; &lt;clause2&gt; ...)</code> syntax</h3>
<p>TODO</p>
<h3 id="cdar-obj"><code>(cdar obj)</code></h3>
<p>TODO</p>
<h3 id="cddr-obj"><code>(cddr obj)</code></h3>
<p>TODO</p>
<h3 id="cdr-obj"><code>(cdr obj)</code></h3>
<p>Returns the contents of the <code>cdr</code> field of pair. Note that it is an error to take the <code>cdr</code> of the empty list.</p>
<h3 id="ceiling-x"><code>(ceiling x)</code></h3>
<p>The ceiling procedure returns the smallest integer not smaller than x.</p>
<h3 id="char-integer-char"><code>(char-&gt;integer char)</code></h3>
<p>Given a Unicode character, <code>char-&gt;integer</code> returns an exact integer between 0 and #xD7FF or between #xE000 and #x10FFFF which is equal to the Unicode scalar value of that character. Given a non-Unicode character, it returns an exact integer greater than #x10FFFF.</p>
<h3 id="char-ready-port"><code>(char-ready? [port])</code></h3>
<p>Returns #t if a character is ready on the textual input port and returns #f otherwise. If char-ready returns #t then the next read-char operation on the given port is guaranteed not to hang. If the port is at end of file then char-ready? returns #t.</p>
<h3 id="char-char1-char2"><code>(char&lt;=? char1 char2)</code></h3>
<p>TODO</p>
<h3 id="char-char1-char2-1"><code>(char&lt;? char1 char2)</code></h3>
<p>TODO</p>
<h3 id="char-char1-char2-2"><code>(char=? char1 char2)</code></h3>
<p>TODO</p>
<h3 id="char-char1-char2-3"><code>(char&gt;=? char1 char2)</code></h3>
<p>TODO</p>
<h3 id="char-char1-char2-4"><code>(char&gt;? char1 char2)</code></h3>
<p>TODO</p>
<h3 id="char-obj"><code>(char? obj)</code></h3>
<p>Returns #t if obj is a character, otherwise returns #f.</p>
<h3 id="close-input-port-port"><code>(close-input-port port)</code></h3>
<p>Closes the resource associated with port, rendering the port incapable of delivering or accepting data.</p>
<h3 id="close-output-port-port"><code>(close-output-port port)</code></h3>
<p>Closes the resource associated with port, rendering the port incapable of delivering or accepting data.</p>
<h3 id="close-port-port"><code>(close-port port)</code></h3>
<p>Closes the resource associated with port, rendering the port incapable of delivering or accepting data.</p>
<h3 id="complex-obj"><code>(complex? obj)</code></h3>
<p>Returns #t if obj is a complex number, otherwise returns #f.</p>
<h3 id="cond-clause1-..."><code>(cond &lt;clause1&gt; ...)</code></h3>
<p>TODO</p>
<h3 id="cond-expand"><code>cond-expand</code></h3>
<p>TODO: not implemented</p>
<h3 id="cons-obj1-obj2"><code>(cons obj1 obj2)</code></h3>
<p>Returns a newly allocated pair whose car is obj1 and whose cdr is obj2. The pair is guaranteed to be different (in the sense of eqv?) from every existing object.</p>
<h3 id="current-error-port-port"><code>(current-error-port [port])</code></h3>
<p>Returns the current default error port (an output port). That procedure is also a parameter object, which can be overridden with <code>parameterize</code>.</p>
<h3 id="current-input-port-port"><code>(current-input-port [port])</code></h3>
<p>Returns the current default input port. That procedure is also a parameter object, which can be overridden with <code>parameterize</code>.</p>
<h3 id="current-output-port"><code>current-output-port</code></h3>
<p>Returns the current default output port. That procedure is also a parameter object, which can be overridden with <code>parameterize</code>.</p>
<h3 id="define-name-expr-syntax"><code>(define &lt;name&gt; &lt;expr&gt;)</code> syntax</h3>
<p>TODO</p>
<h3 id="define-name-variable-...-expr-...-syntax"><code>(define (&lt;name&gt; &lt;variable&gt; ...) &lt;expr&gt; ...)</code> syntax</h3>
<p>TODO</p>
<h3 id="define-record-type-syntax"><code>define-record-type</code> syntax</h3>
<p>TODO</p>
<h3 id="define-syntax-syntax"><code>define-syntax</code> syntax</h3>
<p>TODO</p>
<h3 id="define-values-var1-...-expr-syntax"><code>(define-values var1 ... expr)</code> syntax</h3>
<p>creates multiple definitions from a single expression returning multiple values. It is allowed wherever define is allowed.</p>
<h3 id="denominator-q"><code>(denominator q)</code></h3>
<p>Return the denominator of their argument; the result is computed as if the argument was represented as a fraction in lowest terms. The denominator is always positive. The denominator of 0 is defined to be 1.</p>
<h3 id="do"><code>do</code></h3>
<p>TODO</p>
<h3 id="dynamic-wind-before-thunk-after"><code>(dynamic-wind before thunk after)</code></h3>
<p>TODO</p>
<h3 id="eof-object"><code>(eof-object)</code></h3>
<p>Returns an end-of-file object, not necessarily unique.</p>
<h3 id="eof-object-obj"><code>(eof-object? obj)</code></h3>
<p>Returns #t if obj is an end-of-file object, otherwise returns #f. A end-of-file object will ever be an object that can be read in using read.</p>
<h3 id="eq-obj1-obj2"><code>(eq? obj1 obj2)</code></h3>
<p>The eq? procedure is similar to eqv? except that in some cases it is capable of discerning distinctions finer than those detectable by eqv?. It must always return #f when eqv? also would, but may return #f in some cases where eqv? would return #t.</p>
<p>On symbols, booleans, the empty list, pairs, and records, and also on non-empty strings, vectors, and bytevectors, eq? and eqv? are guaranteed to have the same behavior. On procedures, eq? must return true if the arguments’ location tags are equal. On numbers and characters, eq?’s behavior is implementation-dependent, but it will always return either true or false. On empty strings, empty vectors, and empty bytevectors, eq? may also behave differently from eqv?.</p>
<h3 id="equal-obj1-obj2"><code>(equal? obj1 obj2)</code></h3>
<p>The equal? procedure, when applied to pairs, vectors, strings and bytevectors, recursively compares them, returning #t when the unfoldings of its arguments into (possibly infinite) trees are equal (in the sense of equal?) as ordered trees, and #f otherwise. It returns the same as eqv? when applied to booleans, symbols, numbers, characters, ports, procedures, and the empty list. If two objects are eqv?, they must be equal? as well. In all other cases, equal? may return either #t or #f.</p>
<p>Even if its arguments are circular data structures, equal? must always terminate.</p>
<h3 id="eqv-obj1-obj2"><code>(eqv? obj1 obj2)</code></h3>
<p>The eqv? procedure defines a useful equivalence relation on objects. Briefly, it returns #t if obj1 and obj2 are normally regarded as the same object.</p>
<p>TODO: complete based on r7rs small and guile.</p>
<h3 id="error-who-message-.-irritants"><code>(error [who] message . irritants)</code></h3>
<p>Raises an exception as if by calling raise on a newly allocated implementation-defined object which encapsulates the information provided by message, as well as any objs, known as the irritants. The procedure error-object? must return #t on such objects.</p>
<h3 id="error-object-irritants-error"><code>(error-object-irritants error)</code></h3>
<p>Returns a list of the irritants encapsulated by error.</p>
<h3 id="error-object-message-error"><code>(error-object-message error)</code></h3>
<p>Returns the message encapsulated by error.</p>
<h3 id="error-object-obj"><code>(error-object? obj)</code></h3>
<p>Returns #t if obj is an object created by <code>error</code> or one of an implementation-defined set of objects. Otherwise, it returns #f. The objects used to signal errors, including those which satisfy the predicates <code>file-error?</code> and <code>read-error?</code>, may or may not satisfy <code>error-object?</code>.</p>
<h3 id="even-number"><code>(even? number)</code></h3>
<p>Return <code>#t</code> if <code>NUMBER</code> is even. Otherwise <code>#f</code>.</p>
<h3 id="exact-z"><code>(exact z)</code></h3>
<p>TODO: FIXME</p>
<p>The procedure exact returns an exact representation of z. The value returned is the exact number that is numerically closest to the argument. For exact arguments, the result is the same as the argument. For inexact non-integral real arguments, the implementation may return a rational approximation, or may report an implementation violation. For inexact complex arguments, the result is a complex number whose real and imaginary parts are the result of applying exact to the real and imaginary parts of the argument, respectively. If an inexact argument has no reasonably close exact equivalent, (in the sense of <code>=</code>), then a violation of an implementation restriction may be reported.</p>
<h3 id="exact-integer-sqrt-k"><code>(exact-integer-sqrt k)</code></h3>
<p>TODO</p>
<h3 id="exact-integer-z"><code>(exact-integer? z)</code></h3>
<p>Returns #t if z is both exact and an integer; otherwise returns #f.</p>
<h3 id="exact-z-1"><code>(exact? z)</code></h3>
<p>Return <code>#t</code> if <code>Z</code> is exact. Otherwise <code>#f</code>.</p>
<h3 id="expt-z1-z2"><code>(expt z1 z2)</code></h3>
<p>Returns <code>z1</code> raised to the power <code>z2</code>.</p>
<h3 id="features"><code>features</code></h3>
<p>TODO</p>
<h3 id="file-error-error"><code>(file-error? error)</code></h3>
<p>TODO</p>
<h3 id="floor-x"><code>(floor x)</code></h3>
<p>The floor procedure returns the largest integer not larger than x.</p>
<h3 id="floor-quotient"><code>(floor-quotient)</code></h3>
<p>TODO</p>
<h3 id="floor-remainder"><code>(floor-remainder)</code></h3>
<p>TODO</p>
<h3 id="floor"><code>(floor/)</code></h3>
<p>TODO</p>
<h3 id="flush-output-port-port"><code>(flush-output-port [port])</code></h3>
<p>Flushes any buffered output from the buffer of output-port to the underlying file or device and returns an unspecified value.</p>
<h3 id="for-each-proc-list1-..."><code>(for-each proc list1 ...)</code></h3>
<p>It is an error if proc does not accept as many arguments as there are lists.</p>
<p>The arguments to for-each are like the arguments to map, but for-each calls proc for its side effects rather than for its values. Unlike map, for-each is guaranteed to call proc on the elements of the lists in order from the first element(s) to the last, and the value returned by for-each is unspecified. If more than one list is given and not all lists have the same length, for-each terminates when the shortest list runs out. The lists can be circular, but it is an error if all of them are circular.</p>
<h3 id="gcd-n1-..."><code>(gcd n1 ...)</code></h3>
<p>Return the greatest common divisor.</p>
<h3 id="get-output-bytevector-port"><code>(get-output-bytevector port)</code></h3>
<p>It is an error if port was not created with <code>open-output-bytevector</code>.</p>
<p>Returns a bytevector consisting of the bytes that have been output to the port so far in the order they were output.</p>
<h3 id="get-output-string-port"><code>(get-output-string port)</code></h3>
<p>It is an error if port was not created with open-output-string.</p>
<p>Returns a string consisting of the characters that have been output to the port so far in the order they were output.</p>
<h3 id="guard-clause-...-syntax"><code>(guard &lt;clause&gt; ...)</code> syntax</h3>
<p>TODO</p>
<h3 id="if-expr-then-else"><code>(if &lt;expr&gt; &lt;then&gt; [&lt;else&gt;])</code></h3>
<p>TODO</p>
<h3 id="include"><code>include</code></h3>
<p>TODO</p>
<h3 id="include-ci"><code>include-ci</code></h3>
<p>TODO: not implemented</p>
<h3 id="inexact-z"><code>(inexact z)</code></h3>
<p>The procedure inexact returns an inexact representation of z. The value returned is the inexact number that is numerically closest to the argument. For inexact arguments, the result is the same as the argument. For exact complex numbers, the result is a complex number whose real and imaginary parts are the result of applying inexact to the real and imaginary parts of the argument, respectively. If an exact argument has no reasonably close inexact equivalent (in the sense of <code>=</code>), then a violation of an implementation restriction may be reported.</p>
<h3 id="inexact-z-1"><code>(inexact? z)</code></h3>
<p>Return <code>#t</code> if <code>Z</code> is inexact. Otherwise <code>#f</code>.</p>
<h3 id="input-port-open-port"><code>(input-port-open? port)</code></h3>
<p>Returns #t if port is still open and capable of performing input, and #f otherwise.</p>
<h3 id="input-port-obj"><code>(input-port? obj)</code></h3>
<p>Return <code>#t</code> if obj is an input port. Otherwise it return <code>#f</code>.</p>
<h3 id="integer-char-integer"><code>(integer-&gt;char integer)</code></h3>
<p>Given an exact integer that is the value returned by a character when char-&gt;integer is applied to it, integer-&gt;char returns that character.</p>
<h3 id="integer-obj"><code>(integer? obj)</code></h3>
<p>Return <code>#t</code> if <code>OBJ</code> is an integer. Otherwise <code>#f</code>.</p>
<h3 id="lambda-formals-expr-..."><code>(lambda &lt;formals&gt; &lt;expr&gt; ...)</code></h3>
<p>TODO</p>
<h3 id="lcm-n1-..."><code>(lcm n1 ...)</code></h3>
<p>Return the least common multiple of its arguments.</p>
<h3 id="length-list"><code>(length list)</code></h3>
<p>Returns the length of list.</p>
<h3 id="let-syntax"><code>let</code> syntax</h3>
<p>TODO</p>
<h3 id="let-syntax-1"><code>let*</code> syntax</h3>
<p>TODO</p>
<h3 id="let-values-syntax"><code>let*-values</code> syntax</h3>
<p>TODO</p>
<h3 id="let-syntax-syntax"><code>let-syntax</code> syntax</h3>
<p>TODO</p>
<h3 id="let-values-syntax-1"><code>let-values</code> syntax</h3>
<p>TODO</p>
<h3 id="letrec-syntax"><code>letrec</code> syntax</h3>
<p>TODO</p>
<h3 id="letrec-syntax-1"><code>letrec*</code> syntax</h3>
<p>TODO</p>
<h3 id="letrec-syntax-syntax"><code>letrec-syntax</code> syntax</h3>
<p>TODO</p>
<h3 id="list-obj-..."><code>(list obj ...)</code></h3>
<p>Returns a newly allocated list of its arguments.</p>
<h3 id="list-string-list"><code>(list-&gt;string list)</code></h3>
<p>It is an error if any element of list is not a character.</p>
<p>list-&gt;string returns a newly allocated string formed from the elements in the list list.</p>
<h3 id="list-vector-list"><code>(list-&gt;vector list)</code></h3>
<p>The list-&gt;vector procedure returns a newly created vector initialized to the elements of the list list.</p>
<h3 id="list-copy-obj"><code>(list-copy obj)</code></h3>
<p>Returns a newly allocated copy of the given obj if it is a list. Only the pairs themselves are copied; the cars of the result are the same (in the sense of eqv?) as the cars of list. If obj is an improper list, so is the result, and the final cdrs are the same in the sense of eqv?. An obj which is not a list is returned unchanged. It is an error if obj is a circular list.</p>
<h3 id="list-ref-list-k"><code>(list-ref list k)</code></h3>
<p>The list argument can be circular, but it is an error if list has fewer than k elements.</p>
<p>Returns the kth element of list. (This is the same as the car of (list-tail list k).)</p>
<h3 id="list-set-list-k-obj"><code>(list-set! list k obj)</code></h3>
<p>It is an error if k is not a valid index of list.</p>
<p>The list-set! procedure stores obj in element k of list.</p>
<h3 id="list-tail-list-k"><code>(list-tail list k)</code></h3>
<p>It is an error if list has fewer than k elements.</p>
<p>Returns the sublist of list obtained by omitting the first k elements.</p>
<h3 id="list-obj"><code>(list? obj)</code></h3>
<p>Return <code>#t</code> if <code>OBJ</code> is a list. Otherwise <code>#f</code>.</p>
<h3 id="make-bytevector-k-byte"><code>(make-bytevector k [byte])</code></h3>
<p>he make-bytevector procedure returns a newly allocated bytevector of length k. If byte is given, then all elements of the bytevector are initialized to byte, otherwise the contents of each element are unspecified.</p>
<h3 id="make-list-k-fill"><code>(make-list k [fill])</code></h3>
<p>Returns a newly allocated list of k elements. If a second argument is given, then each element is initialized to fill. Otherwise the initial contents of each element is unspecified.</p>
<h3 id="make-parameter-init-converter"><code>(make-parameter init [converter])</code></h3>
<p>Returns a newly allocated parameter object, which is a procedure that accepts zero arguments and returns the value associated with the parameter object. Initially, this value is the value of (converter init), or of init if the conversion procedure converter is not specified. The associated value can be temporarily changed using parameterize, which is described below.</p>
<h3 id="make-string-k-char"><code>(make-string k [char])</code></h3>
<p>The make-string procedure returns a newly allocated string of length k. If char is given, then all the characters of the string are initialized to char, otherwise the contents of the string are unspecified.</p>
<h3 id="make-vector-k-fill"><code>(make-vector k [fill])</code></h3>
<p>Returns a newly allocated vector of k elements. If a second argument is given, then each element is initialized to fill. Otherwise the initial contents of each element is unspecified.</p>
<h3 id="map-proc-list1-..."><code>(map proc list1 ...)</code></h3>
<p>It is an error if proc does not accept as many arguments as there are lists and return a single value.</p>
<p>The map procedure applies proc element-wise to the elements of the lists and returns a list of the results, in order. If more than one list is given and not all lists have the same length, map terminates when the shortest list runs out. The lists can be circular, but it is an error if all of them are circular. It is an error for proc to mutate any of the lists. The dynamic order in which proc is applied to the elements of the lists is unspecified. If multiple returns occur from map, the values returned by earlier returns are not mutated.</p>
<h3 id="max-x1-..."><code>(max x1 ...)</code></h3>
<p>Return the maximum of its arguments.</p>
<h3 id="member-obj-list-compare"><code>(member obj list [compare])</code></h3>
<p>Return the first sublist of list whose <code>car</code> is <code>obj</code>, where the sublists of list are the non-empty lists returned by (list-tail list k) for k less than the length of list. If <code>obj</code> does not occur in <code>list</code>, then <code>#f</code> (not the empty list) is returned.</p>
<p>Uses <code>compare</code>, if given, and <code>equal?</code> otherwise.</p>
<h3 id="memq-obj-list"><code>(memq obj list)</code></h3>
<p>Return the first sublist of list whose <code>car</code> is <code>obj</code>, where the sublists of list are the non-empty lists returned by (list-tail list k) for k less than the length of list. If <code>obj</code> does not occur in <code>list</code>, then <code>#f</code> (not the empty list) is returned.</p>
<p>Use <code>eq?</code> for comparison.</p>
<h3 id="memv-obj-list"><code>(memv obj list)</code></h3>
<p>Return the first sublist of list whose <code>car</code> is <code>obj</code>, where the sublists of list are the non-empty lists returned by (list-tail list k) for k less than the length of list. If <code>obj</code> does not occur in <code>list</code>, then <code>#f</code> (not the empty list) is returned.</p>
<p>Uses <code>eqv?</code> for comparison.</p>
<h3 id="min-x1-..."><code>(min x1 ...)</code></h3>
<p>Return the minimum of its arguments.</p>
<h3 id="modulo-n1-n2"><code>(modulo n1 n2)</code></h3>
<p><code>modulo</code> is equivalent to <code>floor-remainder</code>. Provided for backward compatibility.</p>
<h3 id="negative-x"><code>(negative? x)</code></h3>
<p>Return <code>#t</code> if <code>X</code> is negative. Otherwise <code>#f</code>.</p>
<h3 id="newline-port"><code>(newline [port])</code></h3>
<p>Writes an end of line to output port.</p>
<h3 id="not-obj"><code>(not obj)</code></h3>
<p>The not procedure returns #t if obj is false, and returns #f otherwise.</p>
<h3 id="null-obj"><code>(null? obj)</code></h3>
<p>Returns #t if obj is the empty list, otherwise returns #f.</p>
<h3 id="number-string-z-radix"><code>(number-&gt;string z [radix])</code></h3>
<p>It is an error if radix is not one of 2, 8, 10, or 16.</p>
<h3 id="number-obj"><code>(number? obj)</code></h3>
<p>Return <code>#t</code> if <code>OBJ</code> is a number. Otherwise <code>#f</code>.</p>
<h3 id="numerator-q"><code>(numerator q)</code></h3>
<p>TODO</p>
<h3 id="odd-number"><code>(odd? number)</code></h3>
<p>Return <code>#t</code> if <code>NUMBER</code> is odd. Otherwise <code>#f</code>.</p>
<h3 id="open-input-bytevector-bytevector"><code>(open-input-bytevector bytevector)</code></h3>
<p>Takes a bytevector and returns a binary input port that delivers bytes from the bytevector.</p>
<h3 id="open-input-string-string"><code>(open-input-string string)</code></h3>
<p>Takes a string and returns a textual input port that delivers characters from the string. If the string is modified, the effect is unspecified.</p>
<h3 id="open-output-bytevector"><code>(open-output-bytevector)</code></h3>
<p>Returns a binary output port that will accumulate bytes for retrieval by <code>get-output-bytevector</code>.</p>
<h3 id="open-output-string"><code>(open-output-string)</code></h3>
<p>Returns a textual output port that will accumulate characters for retrieval by <code>get-output-string</code>.</p>
<h3 id="or-test1-...-syntax"><code>(or test1 ...)</code> syntax</h3>
<p>The <code>test</code> expressions are evaluated from left to right, and the value of the first expression that evaluates to a true value is returned. Any remaining expressions are not evaluated. If all expressions evaluate to #f or if there are no expressions, then #f is returned.</p>
<h3 id="output-port-open-port"><code>(output-port-open? port)</code></h3>
<p>Returns #t if port is still open and capable of performing output, and #f otherwise.</p>
<h3 id="output-port-obj"><code>(output-port? obj)</code></h3>
<p>Return #t if obj is an output port. Otherwise return #f.</p>
<h3 id="pair-obj"><code>(pair? obj)</code></h3>
<p>The pair? predicate returns #t if obj is a pair, and otherwise returns #f.</p>
<h3 id="parameterize-param1-value1-...-expr-..."><code>(parameterize ((param1 value1) ...) expr ...)</code></h3>
<p>A parameterize expression is used to change the values returned by specified parameter objects during the evaluation of the body.</p>
<p>The param and value expressions are evaluated in an unspecified order. The body is evaluated in a dynamic environment in which calls to the parameters return the results of passing the corresponding values to the conversion procedure specified when the parameters were created. Then the previous values of the parameters are restored without passing them to the conversion procedure. The results of the last expression in the body are returned as the results of the entire parameterize expression.</p>
<p>Note: If the conversion procedure is not idempotent, the results of (parameterize ((x (x))) ...), which appears to bind the parameter x to its current value, might not be what the user expects.</p>
<p>If an implementation supports multiple threads of execution, then parameterize must not change the associated values of any parameters in any thread other than the current thread and threads created inside body.</p>
<p>Parameter objects can be used to specify configurable settings for a computation without the need to pass the value to every procedure in the call chain explicitly.</p>
<h3 id="peek-char-port"><code>(peek-char [port])</code></h3>
<p>Returns the next character available from the textual input port, but without updating the port to point to the following character. If no more characters are available, an end-of-file object is returned.</p>
<p>Note: The value returned by a call to peek-char is the same as the value that would have been returned by a call to read-char with the same port. The only difference is that the very next call to read-char or peek-char on that port will return the value returned by the preceding call to peek-char. In particular, a call to peek-char on an interactive port will hang waiting for input whenever a call to read-char would have hung.</p>
<h3 id="peek-u8-port"><code>(peek-u8 [port])</code></h3>
<p>Returns the next byte available from the binary input port, but without updating the port to point to the following byte. If no more bytes are available, an end-of-file object is returned.</p>
<h3 id="port-obj"><code>(port? obj)</code></h3>
<p>Return <code>#t</code> if <code>OBJ</code> is port. Otherwise <code>#f</code>.</p>
<h3 id="positive-x"><code>(positive? x)</code></h3>
<p>Return <code>#t</code> if <code>X</code> is positive. Otherwise <code>#f</code>.</p>
<h3 id="procedure-obj"><code>(procedure? obj)</code></h3>
<p>Return <code>#t</code> if <code>OBJ</code> is a procedure. Otherwise <code>#f</code>.</p>
<h3 id="quasiquote-syntax"><code>quasiquote</code> syntax</h3>
<p>TODO</p>
<h3 id="quote-syntax"><code>quote</code> syntax</h3>
<p>TODO</p>
<h3 id="quotient"><code>(quotient)</code></h3>
<p>TODO</p>
<h3 id="raise-obj"><code>(raise obj)</code></h3>
<p>Raises an exception by invoking the current exception handler on obj. The handler is called with the same dynamic environment as that of the call to raise, except that the current exception handler is the one that was in place when the handler being called was installed. If the handler returns, a secondary exception is raised in the same dynamic environment as the handler. The relationship between obj and the object raised by the secondary exception is unspecified.</p>
<h3 id="raise-continuable-obj"><code>(raise-continuable obj)</code></h3>
<p>Raises an exception by invoking the current exception handler on obj. The handler is called with the same dynamic environment as the call to raise-continuable, except that: (1) the current exception handler is the one that was in place when the handler being called was installed, and (2) if the handler being called returns, then it will again become the current exception handler. If the handler returns, the values it returns become the values returned by the call to raise-continuable.</p>
<h3 id="rational-obj"><code>(rational? obj)</code></h3>
<p>Return <code>#t</code> if <code>OBJ</code> is a rational number. Otherwise <code>#f</code>.</p>
<h3 id="rationalize-x-y"><code>(rationalize x y)</code></h3>
<p>The rationalize procedure returns the simplest rational number differing from x by no more than y.</p>
<h3 id="read-bytevector-k-port"><code>(read-bytevector k [port])</code></h3>
<p>Reads the next k bytes, or as many as are available before the end of file, from the binary input port into a newly allocated bytevector in left-to-right order and returns the bytevector. If no bytes are available before the end of file, an end-of-file object is returned.</p>
<h3 id="read-bytevector-bytevector-port-start-end"><code>(read-bytevector! bytevector [port [start [end]]])</code></h3>
<p>Reads the next end - start bytes, or as many as are available before the end of file, from the binary input port into bytevector in left-to-right order beginning at the start position. If end is not supplied, reads until the end of bytevector has been reached. If start is not supplied, reads beginning at position 0. Returns the number of bytes read. If no bytes are available, an end-of-file object is returned.</p>
<h3 id="read-char-port"><code>(read-char [port])</code></h3>
<p>Returns the next character available from the textual input port, updating the port to point to the following character. If no more characters are available, an end-of-file object is returned.</p>
<h3 id="read-error-obj"><code>(read-error? obj)</code></h3>
<p>Error type predicates. Returns #t if obj is an object raised by the read procedure. Otherwise, it returns #f.</p>
<h3 id="read-line-port"><code>(read-line [port])</code></h3>
<p>Returns the next line of text available from the textual input port, updating the port to point to the following character. If an end of line is read, a string containing all of the text up to (but not including) the end of line is returned, and the port is updated to point just past the end of line. If an end of file is encountered before any end of line is read, but some characters have been read, a string containing those characters is returned. If an end of file is encountered before any characters are read, an end-of-file object is returned. For the purpose of this procedure, an end of line consists of either a linefeed character, a carriage return character, or a sequence of a carriage return character followed by a linefeed character. Implementations may also recognize other end of line characters or sequences.</p>
<h3 id="read-string-k-port"><code>(read-string k [port])</code></h3>
<p>Reads the next k characters, or as many as are available before the end of file, from the textual input port into a newly allocated string in left-to-right order and returns the string. If no characters are available before the end of file, an end-of-file object is returned.</p>
<h3 id="read-u8-port"><code>(read-u8 [port])</code></h3>
<p>Returns the next byte available from the binary input port, updating the port to point to the following byte. If no more bytes are available, an end-of-file object is returned.</p>
<h3 id="real-obj"><code>(real? obj)</code></h3>
<p>Return #t if <code>OBJ</code> is real number. Otherwise <code>#f</code>.</p>
<h3 id="remainder-n1-n2"><code>(remainder n1 n2)</code></h3>
<p>TODO</p>
<h3 id="reverse-list"><code>(reverse list)</code></h3>
<p>Returns a newly allocated list consisting of the elements of list in reverse order.</p>
<h3 id="round-x"><code>(round x)</code></h3>
<p>TODO</p>
<h3 id="set-variable-expression-syntax"><code>(set! &lt;variable&gt; &lt;expression&gt;)</code> syntax</h3>
<p>Expression is evaluated, and the resulting value is stored in the location to which variable is bound. It is an error if variable is not bound either in some region enclosing the set! expression or else globally. The result of the set! expression is unspecified.</p>
<h3 id="set-car-pair-obj"><code>(set-car! pair obj)</code></h3>
<p>Stores <code>obj</code> in the car field of <code>pair</code>.</p>
<h3 id="set-cdr-pair-obj"><code>(set-cdr! pair obj)</code></h3>
<p>Stores obj in the cdr field of pair.</p>
<h3 id="square-z"><code>(square z)</code></h3>
<p>Returns the square of z. This is equivalent to (* z z).</p>
<h3 id="string-char-..."><code>(string char ...)</code></h3>
<p>Returns a newly allocated string composed of the arguments. It is analogous to list.</p>
<h3 id="string-list-straing-start-end"><code>(string-&gt;list straing [start [end]])</code></h3>
<p>The string-&gt;list procedure returns a newly allocated list of the characters of string between start and end.</p>
<h3 id="string-number-string-radix"><code>(string-&gt;number string [radix])</code></h3>
<p>Returns a number of the maximally precise representation expressed by the given string. It is an error if radix is not 2, 8, 10, or 16.</p>
<p>If supplied, radix is a default radix that will be overridden if an explicit radix prefix is present in string (e.g. &quot;#o177&quot;). If radix is not supplied, then the default radix is 10. If string is not a syntactically valid notation for a number, or would result in a number that the implementation cannot represent, then string-&gt;number returns #f. An error is never signaled due to the content of string.</p>
<h3 id="string-symbol-string"><code>(string-&gt;symbol string)</code></h3>
<p>Returns the symbol whose name is string. This procedure can create symbols with names containing special characters that would require escaping when written, but does not interpret escapes in its input.</p>
<h3 id="string-utf8-string-start-end"><code>(string-&gt;utf8 string [start [end]])</code></h3>
<p>The string-&gt;utf8 procedure encodes the characters of a string between start and end and returns the corresponding bytevector.</p>
<h3 id="string-vector-string-start-end"><code>(string-&gt;vector string [start [end]])</code></h3>
<p>The string-&gt;vector procedure returns a newly created vector initialized to the elements of the string string between start and end.</p>
<h3 id="string-append-string-..."><code>(string-append string ...)</code></h3>
<p>Returns a newly allocated string whose characters are the concatenation of the characters in the given strings.</p>
<h3 id="string-copy-string-start-end"><code>(string-copy string [start [end]])</code></h3>
<p>Returns a newly allocated copy of the part of the given string between start and end.</p>
<h3 id="string-copy-to-at-from-start-end"><code>(string-copy! to at from [start [end]])</code></h3>
<p>It is an error if at is less than zero or greater than the length of to. It is also an error if (- (string-length to) at) is less than (- end start).</p>
<p>Copies the characters of string from between start and end to string to, starting at at. The order in which characters are copied is unspecified, except that if the source and destination overlap, copying takes place as if the source is first copied into a temporary string and then into the destination. This can be achieved without allocating storage by making sure to copy in the correct direction in such circumstances.</p>
<h3 id="string-fill-string-fill-start-end"><code>(string-fill! string fill [start [end]])</code></h3>
<p>It is an error if fill is not a character.</p>
<p>The string-fill! procedure stores fill in the elements of string between start and end.</p>
<h3 id="string-for-each-proc-string1-..."><code>(string-for-each proc string1 ...)</code></h3>
<p>It is an error if proc does not accept as many arguments as there are strings.</p>
<p>The arguments to string-for-each are like the arguments to string-map, but string-for-each calls proc for its side effects rather than for its values. Unlike string-map, string-for-each is guaranteed to call proc on the elements of the lists in order from the first element(s) to the last, and the value returned by string-for-each is unspecified. If more than one string is given and not all strings have the same length, string-for-each terminates when the shortest string runs out. It is an error for proc to mutate any of the strings.</p>
<h3 id="string-length-string"><code>(string-length string)</code></h3>
<p>Returns the number of characters in the given string.</p>
<h3 id="string-map-proc-string1-..."><code>(string-map proc string1 ...)</code></h3>
<p>It is an error if proc does not accept as many arguments as there are strings and return a single character.</p>
<p>The string-map procedure applies proc element-wise to the elements of the strings and returns a string of the results, in order. If more than one string is given and not all strings have the same length, string-map terminates when the shortest string runs out. The dynamic order in which proc is applied to the elements of the strings is unspecified. If multiple returns occur from string-map, the values returned by earlier returns are not mutated.</p>
<h3 id="string-ref-string-k"><code>(string-ref string k)</code></h3>
<p>It is an error if k is not a valid index of string.</p>
<p>The string-ref procedure returns character k of string using zero-origin indexing. There is no requirement for this procedure to execute in constant time.</p>
<h3 id="string-set-string-k-char"><code>(string-set! string k char)</code></h3>
<p>It is an error if k is not a valid index of string.</p>
<p>The string-set! procedure stores char in element k of string. There is no requirement for this procedure to execute in constant time.</p>
<h3 id="string"><code>string&lt;=?</code></h3>
<p>TODO</p>
<h3 id="string-1"><code>string&lt;?</code></h3>
<p>TODO</p>
<h3 id="string-string1-string2-..."><code>(string=? string1 string2 ...)</code></h3>
<p>Returns #t if all the strings are the same length and contain exactly the same characters in the same positions, otherwise returns #f.</p>
<h3 id="string-2"><code>string&gt;=?</code></h3>
<p>TODO</p>
<h3 id="string-3"><code>string&gt;?</code></h3>
<p>TODO</p>
<h3 id="string-obj"><code>(string? obj)</code></h3>
<p>Return <code>#t</code> if <code>OBJ</code> is string. Otherwise <code>#f</code>.</p>
<h3 id="substring-string-start-end"><code>(substring string start end)</code></h3>
<p>The substring procedure returns a newly allocated string formed from the characters of string beginning with index start and ending with index end. This is equivalent to calling string-copy with the same arguments, but is provided for backward compatibility and stylistic flexibility.</p>
<h3 id="symbol-string-symbol"><code>(symbol-&gt;string symbol)</code></h3>
<p>Returns the name of symbol as a string, but without adding escapes. It is an error to apply mutation procedures like string-set! to strings returned by this procedure.</p>
<h3 id="symbol-symbol1-symbol2-..."><code>(symbol=? symbol1 symbol2 ...)</code></h3>
<p>Returns #t if all the arguments are symbols and all have the same names in the sense of string=?.</p>
<h3 id="symbol-obj"><code>(symbol? obj)</code></h3>
<p>Returns #t if obj is a symbol, otherwise returns #f.</p>
<h3 id="syntax-error"><code>syntax-error</code></h3>
<p>TODO</p>
<h3 id="syntax-rules"><code>syntax-rules</code></h3>
<p>TODO</p>
<h3 id="textual-port-obj"><code>(textual-port? obj)</code></h3>
<p>TODO</p>
<h3 id="truncate-x"><code>(truncate x)</code></h3>
<p>TODO</p>
<h3 id="truncate-quotient"><code>(truncate-quotient)</code></h3>
<p>TODO</p>
<h3 id="truncate-remainder"><code>(truncate-remainder)</code></h3>
<p>TODO</p>
<h3 id="truncate"><code>(truncate/)</code></h3>
<p>TODO</p>
<h3 id="u8-ready-port"><code>(u8-ready? [port])</code></h3>
<p>Returns #t if a byte is ready on the binary input port and returns #f otherwise. If u8-ready? returns #t then the next read-u8 operation on the given port is guaranteed not to hang. If the port is at end of file then u8-ready? returns #t.</p>
<h3 id="unless-test-expr-...-syntax"><code>(unless &lt;test&gt; &lt;expr&gt; ...)</code> syntax</h3>
<p>The test is evaluated, and if it evaluates to #f, the expressions are evaluated in order. The result of the unless expression is unspecified.</p>
<h3 id="unquote-syntax"><code>unquote</code> syntax</h3>
<p>TODO</p>
<h3 id="unquote-splicing-syntax"><code>unquote-splicing</code> syntax</h3>
<p>TODO</p>
<h3 id="utf8-string-bytevector-start-end"><code>(utf8-&gt;string bytevector [start [end]])</code></h3>
<p>It is an error for bytevector to contain invalid UTF-8 byte sequences.</p>
<p>The utf8-&gt;string procedure decodes the bytes of a bytevector between start and end and returns the corresponding string</p>
<h3 id="values-obj-..."><code>(values obj ...)</code></h3>
<p>Delivers all of its arguments to its continuation.</p>
<h3 id="vector-obj-..."><code>(vector obj ...)</code></h3>
<p>Returns a newly allocated vector whose elements contain the given arguments. It is analogous to list.</p>
<h3 id="vector-list-vector-start-end"><code>(vector-&gt;list vector [start [end]])</code></h3>
<p>The vector-&gt;list procedure returns a newly allocated list of the objects contained in the elements of vector between start and end. The list-&gt;vector procedure returns a newly created vector initialized to the elements of the list list.</p>
<h3 id="vector-string-vector-start-end"><code>(vector-&gt;string vector [start [end]])</code></h3>
<p>It is an error if any element of vector between start and end is not a character.</p>
<p>The vector-&gt;string procedure returns a newly allocated string of the objects contained in the elements of vector between start and end. The string-&gt;vector procedure returns a newly created vector initialized to the elements of the string string between start and end.</p>
<h3 id="vector-append-vector-..."><code>(vector-append vector ...)</code></h3>
<p>Returns a newly allocated vector whose elements are the concatenation of the elements of the given vectors.</p>
<h3 id="vector-copy-vector-start-end"><code>(vector-copy vector [start [end]])</code></h3>
<p>Returns a newly allocated copy of the elements of the given vector between start and end. The elements of the new vector are the same (in the sense of eqv?) as the elements of the old.</p>
<h3 id="vector-copy-to-at-from-start-end"><code>(vector-copy! to at from [start [end]])</code></h3>
<p>It is an error if at is less than zero or greater than the length of to. It is also an error if (- (vector-length to) at) is less than (- end start).</p>
<p>Copies the elements of vector from between start and end to vector to, starting at at. The order in which elements are copied is unspecified, except that if the source and destination overlap, copying takes place as if the source is first copied into a temporary vector and then into the destination. This can be achieved without allocating storage by making sure to copy in the correct direction in such circumstances.</p>
<h3 id="vector-fill-vector-fill-start-end"><code>(vector-fill! vector fill [start [end]])</code></h3>
<p>The vector-fill! procedure stores fill in the elements of vector between start and end.</p>
<h3 id="vector-for-each-proc-vector1-..."><code>(vector-for-each proc vector1 ...)</code></h3>
<p>It is an error if proc does not accept as many arguments as there are vectors.</p>
<p>The arguments to vector-for-each are like the arguments to vector-map, but vector-for-each calls proc for its side effects rather than for its values. Unlike vector-map, vector-for-each is guaranteed to call proc on the elements of the vectors in order from the first element(s) to the last, and the value returned by vector-for-each is unspecified. If more than one vector is given and not all vectors have the same length, vector-for-each terminates when the shortest vector runs out. It is an error for proc to mutate any of the vectors.</p>
<h3 id="vector-length-vector"><code>(vector-length vector)</code></h3>
<p>Returns the number of elements in vector as an exact integer.</p>
<h3 id="vector-map-proc-vector1-..."><code>(vector-map proc vector1 ...)</code></h3>
<p>It is an error if proc does not accept as many arguments as there are vectors and return a single value.</p>
<p>The vector-map procedure applies proc element-wise to the elements of the vectors and returns a vector of the results, in order. If more than one vector is given and not all vectors have the same length, vector-map terminates when the shortest vector runs out. The dynamic order in which proc is applied to the elements of the vectors is unspecified. If multiple returns occur from vector-map, the values returned by earlier returns are not mutated.</p>
<h3 id="vector-ref-vector-k"><code>(vector-ref vector k)</code></h3>
<p>It is an error if k is not a valid index of vector.</p>
<p>The vector-ref procedure returns the contents of element k of vector.</p>
<h3 id="vector-set-vector-k-obj"><code>(vector-set! vector k obj)</code></h3>
<p>It is an error if k is not a valid index of vector.</p>
<p>The vector-set! procedure stores obj in element k of vector.</p>
<h3 id="vector-obj"><code>(vector? obj)</code></h3>
<p>Returns #t if obj is a bytevector. Otherwise, #f is returned.</p>
<h3 id="when-test-expr-...-syntax"><code>(when &lt;test&gt; &lt;expr&gt; ...)</code> syntax</h3>
<p>The test is evaluated, and if it evaluates to a true value, the expressions are evaluated in order. The result of the when expression is unspecified.</p>
<h3 id="with-exception-handler"><code>with-exception-handler</code></h3>
<p>TODO</p>
<h3 id="write-bytevector-bytevector-port-start-end"><code>(write-bytevector bytevector [port [start [end]]])</code></h3>
<p>Writes the bytes of bytevector from start to end in left-to-right order to the binary output port.</p>
<h3 id="write-char-char-port"><code>(write-char char [port])</code></h3>
<p>Writes the character char (not an external representation of the character) to the given textual output port and returns an unspecified value.</p>
<h3 id="write-string-string-port-start-end"><code>(write-string string [port [start [end]]])</code></h3>
<p>Writes the characters of string from start to end in left-to-right order to the textual output port.</p>
<h3 id="write-u8-byte-port"><code>(write-u8 byte [port])</code></h3>
<p>Writes the byte to the given binary output port and returns an unspecified value.</p>
<h3 id="zero-z"><code>(zero? z)</code></h3>
<p>Return <code>#t</code> if z is zero. Otherwise <code>#f</code>.</p>
<h2 id="scheme-case-lambda"><code>(scheme case-lambda)</code></h2>
<h3 id="case-lambda-clause1-...-syntax"><code>(case-lambda &lt;clause1&gt; ...)</code> syntax</h3>
<p>Each clause is of the form <code>(&lt;formals&gt; &lt;body&gt;)</code>, where <code>&lt;formals&gt;</code> and <code>&lt;body&gt;</code> have the same syntax as in a lambda expression.</p>
<p>A case-lambda expression evaluates to a procedure that accepts a variable number of arguments and is lexically scoped in the same manner as a procedure resulting from a lambda expression. When the procedure is called, the first clause for which the arguments agree with <code>&lt;formals&gt;</code> is selected, where agreement is specified as for the <code>&lt;formals&gt;</code> of a lambda expression. The variables of <code>&lt;formals&gt;</code> are bound to fresh locations, the values of the arguments are stored in those locations, the <code>&lt;body&gt;</code> is evaluated in the extended environment, and the results of <code>&lt;body&gt;</code> are returned as the results of the procedure call.</p>
<p>It is an error for the arguments not to agree with the <code>&lt;formals&gt;</code> of any clause`.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> add1</span>
  (case-lambda
    ((a) (add1 a <span class="dv">0</span>))
    ((a b) (<span class="kw">+</span> <span class="dv">1</span> a b))))

(add1 <span class="dv">1</span>) <span class="co">;; =&gt; 2</span>
(add1 <span class="dv">1</span> <span class="dv">2</span>) <span class="co">;; =&gt; 4</span></code></pre></div>
<h2 id="scheme-char"><code>(scheme char)</code></h2>
<h3 id="char-alphabetic-char"><code>(char-alphabetic? char)</code></h3>
<p>TODO</p>
<h3 id="char-alphabetic-char-1"><code>(char-alphabetic? char)</code></h3>
<p>TODO</p>
<h3 id="char-ci-char"><code>(char-ci&lt;=? char)</code></h3>
<p>TODO</p>
<h3 id="char-ci-char-1"><code>(char-ci&lt;? char)</code></h3>
<p>TODO</p>
<h3 id="char-ci-char-2"><code>(char-ci=? char)</code></h3>
<p>TODO</p>
<h3 id="char-ci-char-3"><code>(char-ci&gt;=? char)</code></h3>
<p>TODO</p>
<h3 id="char-ci-char-4"><code>(char-ci&gt;? char)</code></h3>
<p>TODO</p>
<h3 id="char-downcase-char"><code>(char-downcase char)</code></h3>
<p>TODO</p>
<h3 id="char-foldcase-char"><code>(char-foldcase char)</code></h3>
<p>TODO</p>
<h3 id="char-lower-case-char"><code>(char-lower-case? char)</code></h3>
<p>TODO</p>
<h3 id="char-numeric-char"><code>(char-numeric? char)</code></h3>
<p>TODO</p>
<h3 id="char-upcase-char"><code>(char-upcase char)</code></h3>
<p>TODO</p>
<h3 id="char-upper-case-char"><code>(char-upper-case? char)</code></h3>
<p>TODO</p>
<h3 id="char-whitespace-char"><code>(char-whitespace? char)</code></h3>
<p>TODO</p>
<h3 id="string-ci-string1-string2-..."><code>(string-ci&lt;=? string1 string2 ...)</code></h3>
<p>TODO</p>
<h3 id="string-ci-string1-string2-...-1"><code>(string-ci&lt;? string1 string2 ...)</code></h3>
<p>TODO</p>
<h3 id="string-ci-string1-string2-...-2"><code>(string-ci=? string1 string2 ...)</code></h3>
<p>TODO</p>
<h3 id="string-ci-string1-string2-...-3"><code>(string-ci&gt;=? string1 string2 ...)</code></h3>
<p>TODO</p>
<h3 id="string-ci-string1-string2-...-4"><code>(string-ci&gt;? string1 string2 ...)</code></h3>
<p>TODO</p>
<h3 id="string-downcase-string"><code>(string-downcase string)</code></h3>
<p>TODO</p>
<h3 id="string-foldcase-string"><code>(string-foldcase string)</code></h3>
<p>TODO</p>
<h3 id="string-upcase-string"><code>(string-upcase string)</code></h3>
<p>TODO</p>
<h2 id="scheme-complex"><code>(scheme complex)</code></h2>
<h3 id="angle"><code>angle</code></h3>
<p>TODO</p>
<h3 id="imag-part"><code>imag-part</code></h3>
<p>TODO</p>
<h3 id="magnitude"><code>magnitude</code></h3>
<p>TODO</p>
<h3 id="make-polar"><code>make-polar</code></h3>
<p>TODO</p>
<h3 id="make-rectangular"><code>make-rectangular</code></h3>
<p>TODO</p>
<h3 id="real-part"><code>real-part</code></h3>
<p>TODO</p>
<h2 id="scheme-cxr"><code>(scheme cxr)</code></h2>
<p>Exports the following procedure which are the compositions of from three to four <code>car</code> and <code>cdr</code> operations. For example <code>caddar</code> could be defined:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> caddar</span>
  (<span class="kw">lambda</span> (x) (<span class="kw">car</span> (<span class="kw">cdr</span> (<span class="kw">cdr</span> (<span class="kw">car</span> x))))))</code></pre></div>
<p>Here is the full list:</p>
<ul>
<li><code>caaaar</code></li>
<li><code>caaadr</code></li>
<li><code>caaar</code></li>
<li><code>caadar</code></li>
<li><code>caaddr</code></li>
<li><code>caadr</code></li>
<li><code>cadaar</code></li>
<li><code>cadadr</code></li>
<li><code>cadar</code></li>
<li><code>caddar</code></li>
<li><code>cadddr</code></li>
<li><code>caddr</code></li>
<li><code>cdaaar</code></li>
<li><code>cdaadr</code></li>
<li><code>cdaar</code></li>
<li><code>cdadar</code></li>
<li><code>cdaddr</code></li>
<li><code>cdadr</code></li>
<li><code>cddaar</code></li>
<li><code>cddadr</code></li>
<li><code>cddar</code></li>
<li><code>cdddar</code></li>
<li><code>cddddr</code></li>
<li><code>cdddr</code></li>
</ul>
<h2 id="scheme-eval"><code>(scheme eval)</code></h2>
<h3 id="environment-list1-..."><code>(environment list1 ...)</code></h3>
<p>This procedure returns a specifier for the environment that results by starting with an empty environment and then importing each list, considered as an import set, into it. The bindings of the environment represented by the specifier are immutable, as is the environment itself.</p>
<h3 id="eval-expr-or-def-environment-specifier"><code>(eval expr-or-def environment-specifier)</code></h3>
<p>If <code>expr-or-def</code> is an expression, it is evaluated in the specified environment and its values are returned. If it is a definition, the specified identifier(s) are defined in the specified environment, provided the environment is not immutable. Implementations may extend <code>eval</code> to allow other objects.</p>
<h2 id="scheme-file"><code>(scheme file)</code></h2>
<h3 id="call-with-input-file"><code>(call-with-input-file)</code></h3>
<p>TODO</p>
<h3 id="call-with-output-file"><code>(call-with-output-file)</code></h3>
<p>TODO</p>
<h3 id="delete-file"><code>(delete-file)</code></h3>
<p>TODO</p>
<h3 id="file-exists"><code>(file-exists?)</code></h3>
<p>TODO</p>
<h3 id="open-input-file"><code>(open-input-file)</code></h3>
<p>TODO</p>
<h3 id="open-output-file"><code>(open-output-file)</code></h3>
<p>TODO</p>
<h3 id="with-input-from-file"><code>(with-input-from-file)</code></h3>
<p>TODO</p>
<h3 id="with-output-to-file"><code>(with-output-to-file)</code></h3>
<p>TODO</p>
<h3 id="open-binary-input-file"><code>(open-binary-input-file)</code></h3>
<p>TODO</p>
<h3 id="open-binary-output-file"><code>(open-binary-output-file)</code></h3>
<p>TODO</p>
<h2 id="scheme-inexact"><code>(scheme inexact)</code></h2>
<h3 id="acos-z"><code>(acos z)</code></h3>
<p>TODO</p>
<h3 id="asin-z"><code>(asin z)</code></h3>
<p>TODO</p>
<h3 id="atan-z"><code>(atan z)</code></h3>
<p>TODO</p>
<h3 id="cos-z"><code>(cos z)</code></h3>
<p>TODO</p>
<h3 id="exp-z-t"><code>(exp z t)</code></h3>
<p>TODO</p>
<h3 id="finite-z"><code>(finite? z)</code></h3>
<p>TODO</p>
<h3 id="infinite-z"><code>(infinite? z)</code></h3>
<p>TODO</p>
<h3 id="log-z"><code>(log z)</code></h3>
<p>TODO</p>
<h3 id="nan-z"><code>(nan? z)</code></h3>
<p>TODO</p>
<h3 id="sin-z">`(sin z)</h3>
<p>TODO</p>
<h3 id="sqrt-z"><code>(sqrt z)</code></h3>
<p>TODO</p>
<h3 id="tan-z"><code>(tan z)</code></h3>
<p>TODO</p>
<h2 id="scheme-lazy"><code>(scheme lazy)</code></h2>
<h3 id="delay-exp"><code>(delay exp)</code></h3>
<p>TODO</p>
<h3 id="force-promise"><code>(force promise)</code></h3>
<p>TODO</p>
<h3 id="delay-force-exp"><code>(delay-force exp)</code></h3>
<p>TODO</p>
<h3 id="promise-obj"><code>(promise? obj)</code></h3>
<p>TODO</p>
<h3 id="make-promise-exp"><code>(make-promise exp)</code></h3>
<p>TODO</p>
<h2 id="scheme-load"><code>(scheme load)</code></h2>
<h3 id="load-filename-environment"><code>(load filename [environment])</code></h3>
<p>It is an error if <code>FILENAME</code> is not a string.</p>
<p>An implementation-dependent operation is used to transform <code>FILENAME</code> into the name of an existing file containing Scheme source code. The <code>load</code> procedure reads expressions and definitions from the file and evaluates them sequentially in the environment specified by <code>ENVIRONMENT</code>. If <code>ENVIRONMENT</code> is omitted, <code>(interaction-environment)</code> is assumed.</p>
<p>It is unspecified whether the results of the expressions are printed. The <code>load</code> procedure does not affect the values returned by <code>current-input-port</code> and <code>current-output-port</code>. It returns an unspecified value.</p>
<h2 id="scheme-process-context"><code>(scheme process-context)</code></h2>
<h3 id="command-line"><code>(command-line)</code></h3>
<p>Returns the command line passed to the process as a list of strings. The first string corresponds to the command name, and is implementation-dependent. It is an error to mutate any of these strings.</p>
<h3 id="emergency-exit-obj"><code>(emergency-exit [obj])</code></h3>
<p>Terminates the program without running any outstanding dynamic-wind after procedures and communicates an exit value to the operating system in the same manner as exit.</p>
<h3 id="exit-obj"><code>(exit [obj])</code></h3>
<p>Runs all outstanding dynamic-wind after procedures, terminates the running program, and communicates an exit value to the operating system. If no argument is supplied, or if obj is #t, the exit procedure should communicate to the operating system that the program exited normally. If obj is #f, the exit procedure should communicate to the operating system that the program exited abnormally. Otherwise, exit should translate obj into an appropriate exit value for the operating system, if possible.</p>
<h3 id="get-environment-variable-name"><code>(get-environment-variable name)</code></h3>
<p>Many operating systems provide each running process with an environment consisting of environment variables. Both the name and value of an environment variable are strings. The procedure get-environment-variable returns the value of the environment variable name, or #f if the named environment variable is not found. It may use locale information to encode the name and decode the value of the environment variable. It is an error if get-environment-variable can’t decode the value. It is also an error to mutate the resulting string.</p>
<h3 id="get-environment-variables"><code>(get-environment-variables)</code></h3>
<p>Returns the names and values of all the environment variables as an alist, where the car of each entry is the name of an environment variable and the cdr is its value, both as strings. The order of the list is unspecified. It is an error to mutate any of these strings or the alist itself.</p>
<h2 id="scheme-r5rs"><code>(scheme r5rs)</code></h2>
<p>Thie library export <a href="https://bitbucket.org/cowan/r7rs/src/draft-10/rnrs/">R5RS</a> forms. It is based on the following libraries:</p>
<ul>
<li><code>(scheme base)</code></li>
<li><code>(scheme inexact)</code></li>
<li><code>(scheme complex)</code></li>
<li><code>(scheme cxr)</code></li>
<li><code>(scheme file)</code></li>
<li><code>(scheme char)</code></li>
<li><code>(scheme read)</code></li>
<li><code>(scheme write)</code></li>
<li><code>(scheme eval)</code></li>
<li><code>(scheme repl)</code></li>
<li><code>(scheme load)</code></li>
<li><code>(scheme lazy)</code>t</li>
</ul>
<p>It exports the following forms:</p>
<ul>
<li><code>*</code></li>
<li><code>+</code></li>
<li><code>-</code></li>
<li><code>/</code></li>
<li><code>&lt;</code></li>
<li><code>&lt;=</code></li>
<li><code>=</code></li>
<li><code>&gt;</code></li>
<li><code>&gt;=</code></li>
<li><code>abs</code></li>
<li><code>acos</code></li>
<li><code>and</code></li>
<li><code>angle</code></li>
<li><code>append</code></li>
<li><code>apply</code></li>
<li><code>asin</code></li>
<li><code>assoc</code></li>
<li><code>assq</code></li>
<li><code>assv</code></li>
<li><code>atan</code></li>
<li><code>begin</code></li>
<li><code>boolean?</code></li>
<li><code>caaaar</code></li>
<li><code>caaadr</code></li>
<li><code>caaar</code></li>
<li><code>caadar</code></li>
<li><code>caaddr</code></li>
<li><code>caadr</code></li>
<li><code>caar</code></li>
<li><code>cadaar</code></li>
<li><code>cadadr</code></li>
<li><code>cadar</code></li>
<li><code>caddar</code></li>
<li><code>cadddr</code></li>
<li><code>caddr</code></li>
<li><code>cadr</code></li>
<li><code>call-with-current-continuation</code></li>
<li><code>call-with-input-file</code></li>
<li><code>call-with-output-file</code></li>
<li><code>call-with-values</code></li>
<li><code>car</code></li>
<li><code>case</code></li>
<li><code>cdaaar</code></li>
<li><code>cdaadr</code></li>
<li><code>cdaar</code></li>
<li><code>cdadar</code></li>
<li><code>cdaddr</code></li>
<li><code>cdadr</code></li>
<li><code>cdar</code></li>
<li><code>cddaar</code></li>
<li><code>cddadr</code></li>
<li><code>cddar</code></li>
<li><code>cdddar</code></li>
<li><code>cddddr</code></li>
<li><code>cdddr</code></li>
<li><code>cddr</code></li>
<li><code>cdr</code></li>
<li><code>ceiling</code></li>
<li><code>char-&gt;integer</code></li>
<li><code>char-alphabetic?</code></li>
<li><code>char-ci&lt;=?</code></li>
<li><code>char-ci&lt;?</code></li>
<li><code>char-ci=?</code></li>
<li><code>char-ci&gt;=?</code></li>
<li><code>char-ci&gt;?</code></li>
<li><code>char-downcase</code></li>
<li><code>char-lower-case?</code></li>
<li><code>char-numeric?</code></li>
<li><code>char-ready?</code></li>
<li><code>char-upcase</code></li>
<li><code>char-upper-case?</code></li>
<li><code>char-whitespace?</code></li>
<li><code>char&lt;=?</code></li>
<li><code>char&lt;?</code></li>
<li><code>char=?</code></li>
<li><code>char&gt;=?</code></li>
<li><code>char&gt;?</code></li>
<li><code>char?</code></li>
<li><code>close-input-port</code></li>
<li><code>close-output-port</code></li>
<li><code>complex?</code></li>
<li><code>cond</code></li>
<li><code>cons</code></li>
<li><code>cos</code></li>
<li><code>current-input-port</code></li>
<li><code>current-output-port</code></li>
<li><code>define</code></li>
<li><code>define-syntax</code></li>
<li><code>delay</code></li>
<li><code>denominator</code></li>
<li><code>display</code></li>
<li><code>do</code></li>
<li><code>dynamic-wind</code></li>
<li><code>eof-object?</code></li>
<li><code>eq?</code></li>
<li><code>equal?</code></li>
<li><code>eqv?</code></li>
<li><code>eval</code></li>
<li><code>even?</code></li>
<li><code>exact-&gt;inexact</code></li>
<li><code>exact?</code></li>
<li><code>exp</code></li>
<li><code>expt</code></li>
<li><code>floor</code></li>
<li><code>for-each</code></li>
<li><code>force</code></li>
<li><code>gcd</code></li>
<li><code>if</code></li>
<li><code>imag-part</code></li>
<li><code>inexact-&gt;exact</code></li>
<li><code>inexact?</code></li>
<li><code>input-port?</code></li>
<li><code>integer-&gt;char</code></li>
<li><code>integer?</code></li>
<li><code>interaction-environment</code></li>
<li><code>lambda</code></li>
<li><code>lcm</code></li>
<li><code>length</code></li>
<li><code>let</code></li>
<li><code>let*</code></li>
<li><code>let-syntax</code></li>
<li><code>letrec</code></li>
<li><code>letrec-syntax</code></li>
<li><code>list</code></li>
<li><code>list-&gt;string</code></li>
<li><code>list-&gt;vector</code></li>
<li><code>list-ref</code></li>
<li><code>list-tail</code></li>
<li><code>list?</code></li>
<li><code>load</code></li>
<li><code>log</code></li>
<li><code>magnitude</code></li>
<li><code>make-polar</code></li>
<li><code>make-rectangular</code></li>
<li><code>make-string</code></li>
<li><code>make-vector</code></li>
<li><code>map</code></li>
<li><code>max</code></li>
<li><code>member</code></li>
<li><code>memq</code></li>
<li><code>memv</code></li>
<li><code>min</code></li>
<li><code>modulo</code></li>
<li><code>negative?</code></li>
<li><code>newline</code></li>
<li><code>not</code></li>
<li><code>null-environment</code></li>
<li><code>null?</code></li>
<li><code>number-&gt;string</code></li>
<li><code>number?</code></li>
<li><code>numerator</code></li>
<li><code>odd?</code></li>
<li><code>open-input-file</code></li>
<li><code>open-output-file</code></li>
<li><code>or</code></li>
<li><code>output-port?</code></li>
<li><code>pair?</code></li>
<li><code>peek-char</code></li>
<li><code>positive?</code></li>
<li><code>procedure?</code></li>
<li><code>quasiquote</code></li>
<li><code>quote</code></li>
<li><code>quotient</code></li>
<li><code>rational?</code></li>
<li><code>rationalize</code></li>
<li><code>read</code></li>
<li><code>read-char</code></li>
<li><code>real-part</code></li>
<li><code>real?</code></li>
<li><code>remainder</code></li>
<li><code>reverse</code></li>
<li><code>round</code></li>
<li><code>scheme-report-environment</code></li>
<li><code>set!</code></li>
<li><code>set-car!</code></li>
<li><code>set-cdr!</code></li>
<li><code>sin</code></li>
<li><code>sqrt</code></li>
<li><code>string</code></li>
<li><code>string-&gt;list</code></li>
<li><code>string-&gt;number</code></li>
<li><code>string-&gt;symbol</code></li>
<li><code>string-append</code></li>
<li><code>string-ci&lt;=?</code></li>
<li><code>string-ci&lt;?</code></li>
<li><code>string-ci=?</code></li>
<li><code>string-ci&gt;=?</code></li>
<li><code>string-ci&gt;?</code></li>
<li><code>string-copy</code></li>
<li><code>string-fill!</code></li>
<li><code>string-length</code></li>
<li><code>string-ref</code></li>
<li><code>string-set!</code></li>
<li><code>string&lt;=?</code></li>
<li><code>string&lt;?</code></li>
<li><code>string=?</code></li>
<li><code>string&gt;=?</code></li>
<li><code>string&gt;?</code></li>
<li><code>string?</code></li>
<li><code>substring</code></li>
<li><code>symbol-&gt;string</code></li>
<li><code>symbol?</code></li>
<li><code>syntax-rules</code></li>
<li><code>tan</code></li>
<li><code>truncate</code></li>
<li><code>values</code></li>
<li><code>vector</code></li>
<li><code>vector-&gt;list</code></li>
<li><code>vector-fill!</code></li>
<li><code>vector-length</code></li>
<li><code>vector-ref</code></li>
<li><code>vector-set!</code></li>
<li><code>vector?</code></li>
<li><code>with-input-from-file</code></li>
<li><code>with-output-to-file</code></li>
<li><code>write</code></li>
<li><code>write-char</code></li>
<li><code>zero?</code></li>
</ul>
<h2 id="scheme-read"><code>(scheme read)</code></h2>
<h3 id="read-port"><code>(read [port])</code></h3>
<p>The <code>read</code> procedure converts external representations of Scheme objects into the objects themselves. That is, it is a parser for the non-terminal datum. It returns the next object parsable from the given textual input port, updating port to point to the first character past the end of the external representation of the object.</p>
<p>The current implementation is not fully compatible with R7RS.</p>
<h2 id="scheme-repl"><code>(scheme repl)</code></h2>
<h3 id="interaction-environment"><code>(interaction-environment)</code></h3>
<p>This procedure returns a specifier for a mutable environment that contains an implementation-defined set of bindings, typically a superset of those exported by <code>(scheme base)</code>. The intent is that this procedure will return the environment in which the implementation would evaluate expressions entered by the user into a REPL.</p>
<h2 id="scheme-time"><code>(scheme time)</code></h2>
<h3 id="current-jiffy"><code>(current-jiffy)</code></h3>
<p>Returns the number of jiffies as an exact integer that have elapsed since an arbitrary, implementation-defined epoch. A jiffy is an implementation-defined fraction of a second which is defined by the return value of the jiffies-per-second procedure. The starting epoch is guaranteed to be constant during a run of the program, but may vary between runs.</p>
<h3 id="current-second"><code>(current-second)</code></h3>
<p>Returns an inexact number representing the current time on the International Atomic Time (TAI) scale. The value 0.0 represents midnight on January 1, 1970 TAI (equivalent to ten seconds before midnight Universal Time) and the value 1.0 represents one TAI second later. Neither high accuracy nor high precision are required; in particular, returning Coordinated Universal Time plus a suitable constant might be the best an implementation can do.</p>
<h3 id="jiffies-per-second"><code>(jiffies-per-second)</code></h3>
<p>Returns an exact integer representing the number of jiffies per SI second. This value is an implementation-specified constant.</p>
<h2 id="scheme-write"><code>(scheme write)</code></h2>
<h3 id="display-obj-port"><code>(display obj [port])</code></h3>
<p>Writes a representation of obj to the given textual output port. Strings that appear in the written representation are output as if by write-string instead of by write. Symbols are not escaped. Character objects appear in the representation as if written by write-char instead of by write.</p>
<h3 id="write-obj-port"><code>(write obj [port])</code></h3>
<p>Writes a representation of obj to the given textual output port. Strings that appear in the written representation are enclosed in quotation marks, and within those strings backslash and quotation mark characters are escaped by backslashes. Symbols that contain non-ASCII characters are escaped with vertical lines. Character objects are written using the # notation.</p>
<p>If obj contains cycles which would cause an infinite loop using the normal written representation, then at least the objects that form part of the cycle must be represented using datum labels as described in section 2.4. Datum labels must not be used if there are no cycles.</p>
<h3 id="write-simple-obj-port"><code>(write-simple obj [port])</code></h3>
<p>The write-simple procedure is the same as write, except that shared structure is never represented using datum labels. This can cause write-simple not to terminate if obj contains circular structure.</p>
<h3 id="write-shared-obj-port"><code>(write-shared obj [port])</code></h3>
<p>The write-shared procedure is the same as write, except that shared structure must be represented using datum labels for all pairs and vectors that appear more than once in the output.</p>
<h2 id="scheme-bitwise"><code>(scheme bitwise)</code></h2>
<p>Re-export SRFI-151.</p>
<h2 id="scheme-box"><code>(scheme box)</code></h2>
<p>Re-export SRFI-111.</p>
<h2 id="scheme-bytevector"><code>(scheme bytevector)</code></h2>
<p>This is based on <a href="http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-3.html#node_chap_2">R6RS bytevectors</a></p>
<h3 id="abstract">Abstract</h3>
<p>TODO</p>
<h3 id="reference">Reference</h3>
<h4 id="general-operations">General operations</h4>
<h5 id="endianness-endianess-symbol-syntax"><code>(endianness &lt;endianess symbol&gt;)</code> syntax</h5>
<h5 id="native-endianness"><code>(native-endianness)</code></h5>
<p>Returns the endianness symbol associated implementation's preferred endianness (usually that of the underlying machine architecture). This may be any <endianness symbol>, including a symbol other than big and little.</p>
<h5 id="bytevector-obj-1"><code>(bytevector? obj)</code></h5>
<p>Returns #t if obj is a bytevector, otherwise returns #f.</p>
<h5 id="make-bytevector-k-fill"><code>(make-bytevector k [fill])</code></h5>
<p>Returns a newly allocated bytevector of <code>K</code> bytes.</p>
<p>If the <code>FILL</code> argument is missing, the initial contents of the returned bytevector are unspecified.</p>
<p>If the <code>FILL</code> argument is present, it must be an exact integer object in the interval {-128, ... 255} that specifies the initial value for the bytes of the bytevector: If <code>FILL</code> is positive, it is interpreted as an octet; if it is negative, it is interpreted as a byte.</p>
<h5 id="bytevector-length-bytevector-1"><code>(bytevector-length bytevector)</code></h5>
<p>Returns, as an exact integer object, the number of bytes in bytevector.</p>
<h5 id="bytevector-bytevector1-bytevector2"><code>(bytevector=? bytevector1 bytevector2)</code></h5>
<p>Returns #t if bytevector1 and bytevector2 are equal-that is, if they have the same length and equal bytes at all valid indices. It returns #f otherwise.</p>
<h5 id="bytevector-fill-bytevector-fill"><code>(bytevector-fill! bytevector fill)</code></h5>
<p>The fill argument is as in the description of the make-bytevector procedure. The bytevector-fill! procedure stores fill in every element of bytevector and returns unspecified values. Analogous to vector-fill!.</p>
<h5 id="bytevector-copy-source-source-start-target-target-start-k"><code>(bytevector-copy! source source-start‌‌ target target-start k)</code></h5>
<h5 id="bytevector-copy-bytevector"><code>(bytevector-copy bytevector)‌‌</code></h5>
<p>Returns a newly allocated copy of bytevector.</p>
<h4 id="operations-on-bytes-and-octets">Operations on bytes and octets</h4>
<h5 id="bytevector-u8-ref-bytevector-k"><code>(bytevector-u8-ref bytevector k)‌‌</code></h5>
<p>The bytevector-u8-ref procedure returns the byte at index k of bytevector, as an octet.</p>
<h5 id="bytevector-s8-ref-bytevector-k"><code>(bytevector-s8-ref bytevector k)‌‌</code></h5>
<p>The bytevector-s8-ref procedure returns the byte at index k of bytevector, as a (signed) byte.</p>
<h5 id="bytevector-u8-set-bytevector-k-octet"><code>(bytevector-u8-set! bytevector k octet)‌‌</code></h5>
<p>The bytevector-u8-set! procedure stores octet in element k of bytevector.</p>
<h5 id="bytevector-s8-set-bytevector-k-byte"><code>(bytevector-s8-set! bytevector k byte)‌‌</code></h5>
<p>The bytevector-s8-set! procedure stores the two's-complement representation of byte in element k of bytevector.</p>
<h5 id="bytevector-u8-list-bytevector"><code>(bytevector-&gt;u8-list bytevector)‌‌</code></h5>
<p>The bytevector-&gt;u8-list procedure returns a newly allocated list of the octets of bytevector in the same order.</p>
<h5 id="u8-list-bytevector-list"><code>(u8-list-&gt;bytevector list)‌‌</code></h5>
<p>The u8-list-&gt;bytevector procedure returns a newly allocated bytevector whose elements are the elements of list list, in the same order. It is analogous to list-&gt;vector.</p>
<h4 id="operations-on-integers-of-arbitrary-size">Operations on integers of arbitrary size</h4>
<h5 id="bytevector-uint-ref-bytevector-k-endianness-size"><code>(bytevector-uint-ref bytevector k endianness size)‌‌</code></h5>
<h5 id="bytevector-sint-ref-bytevector-k-endianness-size"><code>(bytevector-sint-ref bytevector k endianness size)‌‌</code></h5>
<h5 id="bytevector-uint-set-bytevector-k-n-endianness-size"><code>(bytevector-uint-set! bytevector k n endianness size)‌‌</code></h5>
<h5 id="bytevector-sint-set-bytevector-k-n-endianness-size"><code>(bytevector-sint-set! bytevector k n endianness size)‌‌</code></h5>
<h5 id="bytevector-uint-list-bytevector-endianness-size"><code>(bytevector-&gt;uint-list bytevector endianness size)‌‌</code></h5>
<h5 id="bytevector-sint-list-bytevector-endianness-sizee"><code>(bytevector-&gt;sint-list bytevector endianness sizee‌‌</code></h5>
<h5 id="uint-list-bytevector-list-endianness-size"><code>(uint-list-&gt;bytevector list endianness size)‌‌</code></h5>
<h5 id="sint-list-bytevector-list-endianness-size"><code>(sint-list-&gt;bytevector list endianness size)‌‌</code></h5>
<h4 id="operations-on-16-bit-integers">Operations on 16-bit integers</h4>
<h5 id="bytevector-u16-ref-bytevector-k-endianness"><code>(bytevector-u16-ref bytevector k endianness)‌‌</code></h5>
<h5 id="bytevector-s16-ref-bytevector-k-endianness"><code>(bytevector-s16-ref bytevector k endianness)‌‌</code></h5>
<h5 id="bytevector-u16-native-ref-bytevector-k"><code>(bytevector-u16-native-ref bytevector k)‌‌</code></h5>
<h5 id="bytevector-s16-native-ref-bytevector-k"><code>(bytevector-s16-native-ref bytevector k)‌‌</code></h5>
<h5 id="bytevector-u16-set-bytevector-k-n-endianness"><code>(bytevector-u16-set! bytevector k n endianness)‌‌</code></h5>
<h5 id="bytevector-s16-set-bytevector-k-n-endianness"><code>(bytevector-s16-set! bytevector k n endianness)‌‌</code></h5>
<h5 id="bytevector-u16-native-set-bytevector-k-n"><code>(bytevector-u16-native-set! bytevector k n)‌‌</code></h5>
<h5 id="bytevector-s16-native-set-bytevector-k-n"><code>(bytevector-s16-native-set! bytevector k n)‌‌</code></h5>
<h4 id="operations-on-32-bit-integers">Operations on 32-bit integers</h4>
<h5 id="bytevector-u32-ref-bytevector-k-endianness"><code>(bytevector-u32-ref bytevector k endianness)‌‌</code></h5>
<h5 id="bytevector-s32-ref-bytevector-k-endianness"><code>(bytevector-s32-ref bytevector k endianness)‌‌</code></h5>
<h5 id="bytevector-u32-native-ref-bytevector-k"><code>(bytevector-u32-native-ref bytevector k)‌‌</code></h5>
<h5 id="bytevector-s32-native-ref-bytevector-k"><code>(bytevector-s32-native-ref bytevector k)‌‌</code></h5>
<h5 id="bytevector-u32-set-bytevector-k-n-endianness"><code>(bytevector-u32-set! bytevector k n endianness)‌‌</code></h5>
<h5 id="bytevector-s32-set-bytevector-k-n-endianness"><code>(bytevector-s32-set! bytevector k n endianness)‌‌</code></h5>
<h5 id="bytevector-u32-native-set-bytevector-k-n"><code>(bytevector-u32-native-set! bytevector k n)‌‌</code></h5>
<h5 id="bytevector-s32-native-set-bytevector-k-n"><code>(bytevector-s32-native-set! bytevector k n)‌‌</code></h5>
<h4 id="operations-on-64-bit-integers">Operations on 64-bit integers</h4>
<h5 id="bytevector-u64-ref-bytevector-k-endianness"><code>(bytevector-u64-ref bytevector k endianness)‌‌</code></h5>
<h5 id="bytevector-s64-ref-bytevector-k-endianness"><code>(bytevector-s64-ref bytevector k endianness)‌‌</code></h5>
<h5 id="bytevector-u64-native-ref-bytevector-k"><code>(bytevector-u64-native-ref bytevector k)‌‌</code></h5>
<h5 id="bytevector-s64-native-ref-bytevector-k"><code>(bytevector-s64-native-ref bytevector k)‌‌</code></h5>
<h5 id="bytevector-u64-set-bytevector-k-n-endianness"><code>(bytevector-u64-set! bytevector k n endianness)‌‌</code></h5>
<h5 id="bytevector-s64-set-bytevector-k-n-endianness"><code>(bytevector-s64-set! bytevector k n endianness)‌‌</code></h5>
<h5 id="bytevector-u64-native-set-bytevector-k-n"><code>(bytevector-u64-native-set! bytevector k n)‌‌</code></h5>
<h5 id="bytevector-s64-native-set-bytevector-k-n"><code>(bytevector-s64-native-set! bytevector k n)‌‌</code></h5>
<h4 id="operations-on-ieee-754-representations">Operations on IEEE-754 representations</h4>
<h5 id="bytevector-ieee-single-native-ref-bytevector-k"><code>(bytevector-ieee-single-native-ref bytevector k)‌‌</code></h5>
<h5 id="bytevector-ieee-single-ref-bytevector-k-endianness"><code>(bytevector-ieee-single-ref bytevector k endianness)‌‌</code></h5>
<h5 id="bytevector-ieee-double-native-ref-bytevector-k"><code>(bytevector-ieee-double-native-ref bytevector k)‌‌</code></h5>
<h5 id="bytevector-ieee-double-ref-bytevector-k-endianness"><code>(bytevector-ieee-double-ref bytevector k endianness)‌‌</code></h5>
<h5 id="bytevector-ieee-single-native-set-bytevector-k-x"><code>(bytevector-ieee-single-native-set! bytevector k x)‌‌</code></h5>
<h5 id="bytevector-ieee-single-set-bytevector-k-x-endianness"><code>(bytevector-ieee-single-set! bytevector ‌k x endianness)</code></h5>
<h5 id="bytevector-ieee-double-native-set-bytevector-k-x"><code>(bytevector-ieee-double-native-set! bytevector k x)‌‌</code></h5>
<h5 id="bytevector-ieee-double-set-bytevector-k-x-endianness"><code>(bytevector-ieee-double-set! bytevector k x endianness)‌</code></h5>
<h4 id="operations-on-strings">Operations on strings</h4>
<h5 id="string-utf8-string"><code>(string-&gt;utf8 string)‌‌</code></h5>
<h5 id="string-utf16-string"><code>(string-&gt;utf16 string)‌‌</code></h5>
<h5 id="string-utf16-string-endianness"><code>(string-&gt;utf16 string endianness)‌‌</code></h5>
<h5 id="string-utf32-string"><code>(string-&gt;utf32 string)‌‌</code></h5>
<h5 id="string-utf32-string-endianness"><code>(string-&gt;utf32 string endianness)‌‌</code></h5>
<h5 id="utf8-string-bytevector"><code>(utf8-&gt;string bytevector)‌‌</code></h5>
<h5 id="utf16-string-bytevector-endianness"><code>(utf16-&gt;string bytevector endianness)‌‌</code></h5>
<h5 id="utf16-string-bytevector-endianness-endianness-mandatory"><code>(utf16-&gt;string bytevector‌ endianness endianness-mandatory)</code></h5>
<h5 id="utf32-string-bytevector-endianness"><code>(utf32-&gt;string bytevector endianness)‌‌</code></h5>
<h5 id="utf32-string-bytevector-endianness-endianness-mandatory"><code>(utf32-&gt;string bytevector‌ endianness endianness-mandatory)</code></h5>
<h2 id="scheme-charset"><code>(scheme charset)</code></h2>
<p>Re-export SRFI-14.</p>
<h2 id="scheme-comparator"><code>(scheme comparator)</code></h2>
<p>Re-export SRFI-128.</p>
<h2 id="scheme-division"><code>(scheme division)</code></h2>
<p>Re-export SRFI-141.</p>
<h2 id="scheme-ephemeron"><code>(scheme ephemeron)</code></h2>
<p>Re-export SRFI-124.</p>
<h2 id="scheme-generator"><code>(scheme generator)</code></h2>
<p>Re-export SRFI-158.</p>
<h2 id="scheme-hash-table"><code>(scheme hash-table)</code></h2>
<p>Re-export SRFI-125.</p>
<h2 id="scheme-idque"><code>(scheme idque)</code></h2>
<p>Re-export SRFI-134.</p>
<h2 id="scheme-ilist"><code>(scheme ilist)</code></h2>
<p>Re-export SRFI-116.</p>
<h2 id="scheme-list-queue"><code>(scheme list-queue)</code></h2>
<p>Re-export SRFI-117.</p>
<h2 id="scheme-list"><code>(scheme list)</code></h2>
<p>Re-export SRFI-1.</p>
<h2 id="scheme-lseq"><code>(scheme lseq)</code></h2>
<p>Re-export SRFI-127.</p>
<h2 id="scheme-mapping"><code>(scheme mapping)</code></h2>
<p>Re-export SRFI-146.</p>
<h2 id="scheme-mapping-hash"><code>(scheme mapping hash)</code></h2>
<p>Re-export SRFI-146.</p>
<h2 id="scheme-regex"><code>(scheme regex)</code></h2>
<p>Re-export SRFI-115.</p>
<h2 id="scheme-rlist"><code>(scheme rlist)</code></h2>
<p>Re-export SRFI-101.</p>
<h2 id="scheme-set"><code>(scheme set)</code></h2>
<p>Re-export SRFI-113.</p>
<h2 id="scheme-show"><code>(scheme show)</code></h2>
<p>Re-export SRFI-159.</p>
<h2 id="scheme-sort"><code>(scheme sort)</code></h2>
<p>Re-export SRFI-132.</p>
<h2 id="scheme-stream"><code>(scheme stream)</code></h2>
<p>Re-export SRFI-41.</p>
<h2 id="scheme-text"><code>(scheme text)</code></h2>
<p>Re-export SRFI-135.</p>
<h2 id="scheme-vector"><code>(scheme vector)</code></h2>
<p>Re-export SRFI-160.</p>
<h2 id="scheme-vector-1"><code>(scheme vector @)</code></h2>
<p>Re-export SRFI-160.</p>
<h2 id="srfi-srfi-1"><code>(srfi srfi-1)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-1/">SRFI-1</a>.</p>
<h3 id="abstract-1">Abstract</h3>
<p>TODO</p>
<h3 id="reference-1">Reference</h3>
<h4 id="constructors">Constructors</h4>
<h5 id="cons-a-d"><code>(cons a d)</code></h5>
<p>The primitive constructor. Returns a newly allocated pair whose <code>car</code> is <code>a</code> and whose <code>cdr</code> is <code>d</code>. The pair is guaranteed to be different (in the sense of <code>eqv?</code>) from every existing object.</p>
<h5 id="list-object-..."><code>(list object ...)</code></h5>
<p>Returns a newly allocated list of its arguments.</p>
<h5 id="xcons-d-a"><code>(xcons d a)</code></h5>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">lambda</span> (d a) (<span class="kw">cons</span> a d))</code></pre></div>
<p>Of utility only as a value to be conveniently passed to higher-order procedures.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(xcons &#39;(b c) &#39;a) <span class="co">;; =&gt; (a b c)</span></code></pre></div>
<p>The name stands for &quot;eXchanged CONS.&quot;</p>
<h5 id="cons-obj-...-tail"><code>(cons* obj ... tail)</code></h5>
<p>Like list, but the last argument provides the tail of the constructed list.</p>
<h5 id="make-list-n-fill"><code>(make-list n [fill])</code></h5>
<p>Returns an n-element list, whose elements are all the value fill. If the fill argument is not given, the elements of the list may be arbitrary values.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(make-list <span class="dv">4</span> &#39;c) <span class="kw">=&gt;</span> (c c c c)</code></pre></div>
<h5 id="list-tabulate-n-init-proc"><code>(list-tabulate n init-proc)</code></h5>
<p>Returns an n-element list. Element i of the list, where 0 &lt;= i &lt; n, is produced by (init-proc i). No guarantee is made about the dynamic order in which init-proc is applied to these indices.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(list-tabulate <span class="dv">4</span> <span class="kw">values</span>) <span class="kw">=&gt;</span> (<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)</code></pre></div>
<h5 id="list-copy-flist"><code>(list-copy flist)</code></h5>
<p>Copies the spine of the argument.</p>
<h5 id="circular-list-elt1-elt2-..."><code>(circular-list elt1 elt2 ...)</code></h5>
<p>Constructs a circular list of the elements.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(circular-list &#39;z &#39;q) <span class="kw">=&gt;</span> (z q z q z q ...)</code></pre></div>
<h5 id="iota-count-start-step"><code>(iota count [start step])</code></h5>
<p>Returns a list containing the elements:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(start start+step ... start+(count<span class="dv">-1</span>)*step)</code></pre></div>
<p>The start and step parameters default to 0 and 1, respectively.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(iota <span class="dv">5</span>) <span class="kw">=&gt;</span> (<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>)
(iota <span class="dv">5</span> <span class="dv">0</span> <span class="fl">-0.1</span>) <span class="kw">=&gt;</span> (<span class="dv">0</span> <span class="fl">-0.1</span> <span class="fl">-0.2</span> <span class="fl">-0.3</span> <span class="fl">-0.4</span>)</code></pre></div>
<h4 id="predicates">Predicates</h4>
<h5 id="proper-list-x"><code>(proper-list? x)</code></h5>
<p>Returns true iff x is a proper list -- a finite, nil-terminated list.</p>
<p>More carefully: The empty list is a proper list. A pair whose cdr is a proper list is also a proper list. The opposite of proper is improper.</p>
<h5 id="circular-list-x"><code>(circular-list? x)</code></h5>
<p>True if x is a circular list. A circular list is a value such that for every n &gt;= 0, cdrn(x) is a pair.</p>
<p>Terminology: The opposite of circular is finite.</p>
<h5 id="dotted-list-x">`(dotted-list? x)</h5>
<p>True if x is a finite, non-nil-terminated list. That is, there exists an n &gt;= 0 such that cdrn(x) is neither a pair nor (). This includes non-pair, non-() values (e.g. symbols, numbers), which are considered to be dotted lists of length 0.</p>
<h5 id="pair-obj-1"><code>(pair? obj)</code></h5>
<p>Returns #t if object is a pair; otherwise, #f.</p>
<h5 id="null-obj-1"><code>(null? obj)</code></h5>
<p>Returns #t if object is the empty list; otherwise, #f.</p>
<h5 id="null-list-list"><code>(null-list? list)</code></h5>
<p>List is a proper or circular list. This procedure returns true if the argument is the empty list (), and false otherwise. It is an error to pass this procedure a value which is not a proper or circular list. This procedure is recommended as the termination condition for list-processing procedures that are not defined on dotted lists.</p>
<h5 id="not-pair-x">`(not-pair? x)</h5>
<p>Provided as a procedure as it can be useful as the termination condition for list-processing procedures that wish to handle all finite lists, both proper and dotted.</p>
<h5 id="list-elt-list1-..."><code>(list= elt= list1 ...)</code></h5>
<p>Determines list equality, given an element-equality procedure.</p>
<h4 id="selectors">Selectors</h4>
<h5 id="car-pair">(car pair)</h5>
<h5 id="cdr-pair">(cdr pair)</h5>
<p>These functions return the contents of the car and cdr field of their argument, respectively. Note that it is an error to apply them to the empty list.</p>
<p>Also the following selectors are defined:</p>
<ul>
<li><code>caar</code></li>
<li><code>cadr</code></li>
<li><code>cdar</code></li>
<li><code>cddr</code></li>
<li><code>caaar</code></li>
<li><code>caadr</code></li>
<li><code>cadar</code></li>
<li><code>caddr</code></li>
<li><code>cdaar</code></li>
<li><code>cdadr</code></li>
<li><code>cddar</code></li>
<li><code>cdddr</code></li>
<li><code>caaaar</code></li>
<li><code>caaadr</code></li>
<li><code>caadar</code></li>
<li><code>caaddr</code></li>
<li><code>cadaar</code></li>
<li><code>cadadr</code></li>
<li><code>caddar</code></li>
<li><code>cadddr</code></li>
<li><code>cdaaar</code></li>
<li><code>cdaadr</code></li>
<li><code>cdadar</code></li>
<li><code>cdaddr</code></li>
<li><code>cddaar</code></li>
<li><code>cddadr</code></li>
<li><code>cdddar</code></li>
<li><code>cddddr</code></li>
</ul>
<h5 id="list-ref-clist-i"><code>(list-ref clist i)</code></h5>
<p>Returns the ith element of clist. (This is the same as the car of (drop clist i).) It is an error if i &gt;= n, where n is the length of clist.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">list-ref</span> &#39;(a b c d) <span class="dv">2</span>) <span class="kw">=&gt;</span> c</code></pre></div>
<h5 id="first-pair"><code>(first pair)</code></h5>
<h5 id="second-pair"><code>(second pair)</code></h5>
<h5 id="third-pair"><code>(third pair)</code></h5>
<h5 id="fourth-pair"><code>(fourth pair)</code></h5>
<h5 id="fifth-pair"><code>(fifth pair)</code></h5>
<h5 id="sixth-pair"><code>(sixth pair)</code></h5>
<h5 id="seventh-pair"><code>(seventh pair)</code></h5>
<h5 id="eighth-pair"><code>(eighth pair)</code></h5>
<h5 id="ninth-pair"><code>(ninth pair)</code></h5>
<h5 id="tenth-pair"><code>(tenth pair)</code></h5>
<p>Synonyms for <code>car</code>, <code>cadr</code>, <code>caddr</code>, ...</p>
<h5 id="carcdr-pair"><code>(car+cdr pair)</code></h5>
<p>The fundamental pair deconstructor:</p>
<pre><code>(lambda (p) (values (car p) (cdr p)))</code></pre>
<p>This can, of course, be implemented more efficiently by a compiler.</p>
<h5 id="take-lst-i"><code>(take lst i)</code></h5>
<h5 id="drop-lst-i"><code>(drop lst i)</code></h5>
<p><code>take</code> returns the first <code>I</code> elements of list <code>LST</code>. <code>drop</code> returns all but the first i elements of list <code>LST</code>.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(take &#39;(a b c d e) <span class="dv">2</span>) <span class="co">;; =&gt; (a b)</span>
(drop &#39;(a b c d e) <span class="dv">2</span>) <span class="co">;; =&gt; (c d e)</span></code></pre></div>
<p><code>LST</code> may be any value -- a proper, circular, or dotted list:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(take &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> . d) <span class="dv">2</span>) <span class="co">;; =&gt; (1 2)</span>
(drop &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> . d) <span class="dv">2</span>) <span class="co">;; =&gt; (3 . d)</span>
(take &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> . d) <span class="dv">3</span>) <span class="co">;; =&gt; (1 2 3)</span>
(drop &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> . d) <span class="dv">3</span>) <span class="co">;; =&gt; d</span></code></pre></div>
<p>For a legal <code>I</code>, <code>take</code> and <code>drop</code> partition the list in a manner which can be inverted with append:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">equal?</span> (<span class="kw">append</span> (take lst i) (drop x i)) lst)</code></pre></div>
<p><code>drop</code> is exactly equivalent to performing <code>i</code> <code>cdr</code> operations on <code>LST</code>; the returned value shares a common tail with <code>LST</code>. If the argument is a list of non-zero length, <code>take</code> is guaranteed to return a freshly-allocated list, even in the case where the entire list is taken, e.g. <code>(take lst (length lst))</code>.</p>
<h5 id="take-right-flist-i"><code>(take-right flist i)</code></h5>
<h5 id="drop-right-flist-i"><code>(drop-right flist i)</code></h5>
<p><code>take-right</code> returns the last <code>I</code> elements of <code>FLIST</code>. <code>drop-right</code> returns all but the last <code>I</code> elements of <code>FLIST</code>.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(take-right &#39;(a b c d e) <span class="dv">2</span>) <span class="kw">=&gt;</span> (d e)
(drop-right &#39;(a b c d e) <span class="dv">2</span>) <span class="kw">=&gt;</span> (a b c)</code></pre></div>
<p>The returned list may share a common tail with the argument list.</p>
<p><code>FLIST</code> may be any finite list, either proper or dotted:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(take-right &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> . d) <span class="dv">2</span>) <span class="kw">=&gt;</span> (<span class="dv">2</span> <span class="dv">3</span> . d)
(drop-right &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> . d) <span class="dv">2</span>) <span class="kw">=&gt;</span> (<span class="dv">1</span>)
(take-right &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> . d) <span class="dv">0</span>) <span class="kw">=&gt;</span> d
(drop-right &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> . d) <span class="dv">0</span>) <span class="kw">=&gt;</span> (<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)</code></pre></div>
<p>For a legal <code>I</code>, <code>take-right</code> and <code>drop-right</code> partition the list in a manner which can be inverted with <code>append</code>:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">equal?</span> (<span class="kw">append</span> (take flist i) (drop flist i)) flist)</code></pre></div>
<p><code>take-right</code>'s return value is guaranteed to share a common tail with <code>FLIST</code>. If the argument is a list of non-zero length, <code>drop-right</code> is guaranteed to return a freshly-allocated list, even in the case where nothing is dropped, e.g. <code>(drop-right flist 0)</code>.</p>
<h5 id="take-x-i"><code>(take! x i)</code></h5>
<h5 id="drop-right-flist-i-1"><code>(drop-right! flist i)</code></h5>
<p><code>take!</code> and <code>drop-right!</code> are &quot;linear-update&quot; variants of <code>take</code> and <code>drop-right</code>: the procedure is allowed, but not required, to alter the argument list to produce the result.</p>
<p>If <code>x</code> is circular, <code>take!</code> may return a shorter-than-expected list:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(take! (circular-list <span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span>) <span class="dv">8</span>) <span class="kw">=&gt;</span> (<span class="dv">1</span> <span class="dv">3</span>)
(take! (circular-list <span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span>) <span class="dv">8</span>) <span class="kw">=&gt;</span> (<span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">1</span> <span class="dv">3</span> <span class="dv">5</span> <span class="dv">1</span> <span class="dv">3</span>)</code></pre></div>
<h5 id="split-at-x-i"><code>(split-at  x i)</code></h5>
<h5 id="split-at-x-i-1"><code>(split-at! x i)</code></h5>
<p><code>split-at</code> splits the list <code>x</code> at index <code>i</code>, returning a list of the first <code>i</code> elements, and the remaining tail. It is equivalent to:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">values</span> (take x i) (drop x i))</code></pre></div>
<p><code>split-at!</code> is the linear-update variant. It is allowed, but not required, to alter the argument list to produce the result.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(split-at &#39;(a b c d e f g h) <span class="dv">3</span>) <span class="co">;; =&gt; (a b c) and (d e f g h)</span></code></pre></div>
<h5 id="last-pair"><code>(last pair)</code></h5>
<h5 id="last-pair-pair"><code>(last-pair pair)</code></h5>
<p><code>last</code> returns the last element of the non-empty, finite list <code>pair</code>. <code>last-pair</code> returns the last pair in the non-empty, finite list <code>pair</code>:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(last &#39;(a b c)) <span class="co">;; =&gt; c</span>
(last-pair &#39;(a b c)) <span class="co">;; =&gt; (c)</span></code></pre></div>
<h4 id="miscellaneous">Miscellaneous</h4>
<h5 id="length-list-1"><code>(length list)</code></h5>
<h5 id="length-clist"><code>(length+ clist)</code></h5>
<p>Both <code>length</code> and <code>length+</code> return the length of the argument. It is an error to pass a value to length which is not a proper list (finite and nil-terminated). In particular, this means an implementation may diverge or signal an error when length is applied to a circular list.</p>
<p><code>length+</code>, on the other hand, returns <code>#f</code> when applied to a circular list.</p>
<p>The length of a proper list is a non-negative integer <code>n</code> such that <code>cdr</code> applied <code>n</code> times to the list produces the empty list.</p>
<h5 id="append-list1-..."><code>(append  list1 ...)</code></h5>
<h5 id="append-list1-...-1"><code>(append! list1 ...)</code></h5>
<p><code>append</code> returns a list consisting of the elements of <code>list1</code> followed by the elements of the other list parameters.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">append</span> &#39;(x) &#39;(y))        <span class="kw">=&gt;</span>  (x y)
(<span class="kw">append</span> &#39;(a) &#39;(b c d))    <span class="kw">=&gt;</span>  (a b c d)
(<span class="kw">append</span> &#39;(a (b)) &#39;((c)))  <span class="kw">=&gt;</span>  (a (b) (c))</code></pre></div>
<p>The resulting list is always newly allocated, except that it shares structure with the final list argument. This last argument may be any value at all; an improper list results if it is not a proper list. All other arguments must be proper lists.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">append</span> &#39;(a b) &#39;(c . d))  <span class="kw">=&gt;</span>  (a b c . d)
(<span class="kw">append</span> &#39;() &#39;a)           <span class="kw">=&gt;</span>  a
(<span class="kw">append</span> &#39;(x y))           <span class="kw">=&gt;</span>  (x y)
(<span class="kw">append</span>)                  <span class="kw">=&gt;</span>  ()</code></pre></div>
<p><code>append!</code> is the &quot;linear-update&quot; variant of append -- it is allowed, but not required, to alter <code>cons</code> cells in the argument lists to construct the result list. The last argument is never altered; the result list shares structure with this parameter.</p>
<h5 id="concatenate-list-of-lists"><code>(concatenate  list-of-lists)</code></h5>
<h5 id="concatenate-list-of-lists-1"><code>(concatenate! list-of-lists)</code></h5>
<p>These functions append the elements of their argument together. That is, <code>concatenate</code> returns:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(apply <span class="kw">append</span> list-of-lists)</code></pre></div>
<p>Or, equivalently,</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(reduce-right <span class="kw">append</span> &#39;() list-of-lists)</code></pre></div>
<p><code>concatenate!</code> is the linear-update variant, defined in terms of <code>append!</code> instead of <code>append</code>.</p>
<p>As with <code>append</code> and <code>append!</code>, the last element of the input list may be any value at all.</p>
<h5 id="reverse-list-1"><code>(reverse list)</code></h5>
<h5 id="reverse-list-2"><code>(reverse! list)</code></h5>
<p><code>reverse</code> returns a newly allocated list consisting of the elements of list in reverse order.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">reverse</span> &#39;(a b c)) <span class="co">;; =&gt;  (c b a)</span>
(<span class="kw">reverse</span> &#39;(a (b c) d (e (f)))) <span class="co">;; =&gt;  ((e (f)) d (b c) a)</span></code></pre></div>
<p><code>reverse!</code> is the linear-update variant of reverse. It is permitted, but not required, to alter the argument's <code>cons</code> cells to produce the reversed list.</p>
<h5 id="append-reverse-rev-head-tail"><code>(append-reverse rev-head tail)</code></h5>
<h5 id="append-reverse-rev-head-tail-1"><code>(append-reverse! rev-head tail)</code></h5>
<p><code>append-reverse</code> returns <code>(append (reverse rev-head) tail)</code>. It is provided because it is a common operation -- a common list-processing style calls for this exact operation to transfer values accumulated in reverse order onto the front of another list, and because the implementation is significantly more efficient than the simple composition it replaces. (But note that this pattern of iterative computation followed by a <code>reverse</code> can frequently be rewritten as a recursion, dispensing with the <code>reverse</code> and <code>append-reverse</code> steps, and shifting temporary, intermediate storage from the heap to the stack, which is typically a win for reasons of cache locality and eager storage reclamation.)</p>
<p><code>append-reverse!</code> is just the linear-update variant -- it is allowed, but not required, to alter rev-head's <code>cons</code> cells to construct the result.</p>
<h5 id="zip-clist1-clist2-..."><code>(zip clist1 clist2 ...)</code></h5>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">lambda</span> lists (apply map <span class="kw">list</span> lists))</code></pre></div>
<p>If <code>zip</code> is passed n lists, it returns a list as long as the shortest of these lists, each element of which is an n-element list comprised of the corresponding elements from the parameter lists.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(zip &#39;(one two three)
     &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)
     &#39;(odd even odd even odd even odd even))
     <span class="co">;; =&gt; ((one 1 odd) (two 2 even) (three 3 odd))</span>

(zip &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>)) <span class="kw">=&gt;</span> ((<span class="dv">1</span>) (<span class="dv">2</span>) (<span class="dv">3</span>))</code></pre></div>
<h5 id="unzip1-list"><code>(unzip1 list)</code></h5>
<h5 id="unzip2-list"><code>(unzip2 list)</code></h5>
<h5 id="unzip3-list"><code>(unzip3 list)</code></h5>
<h5 id="unzip4-list"><code>(unzip4 list)</code></h5>
<h5 id="unzip5-list"><code>(unzip5 list)</code></h5>
<p><code>unzip1</code> takes a list of lists, where every list must contain at least one element, and returns a list containing the initial element of each such list. That is, it returns <code>(map car lists)</code>. <code>unzip2</code> takes a list of lists, where every list must contain at least two elements, and returns two values: a list of the first elements, and a list of the second elements. <code>unzip3</code> does the same for the first three elements of the lists, and so forth.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(unzip2 &#39;((<span class="dv">1</span> one) (<span class="dv">2</span> two) (<span class="dv">3</span> three))) <span class="co">;; =&gt; &#39;((1 2 3) (one two three))</span></code></pre></div>
<h5 id="count-pred-clist1-..."><code>(count pred clist1 ...)</code></h5>
<p><code>pred</code> is a procedure taking as many arguments as there are lists and returning a single value. It is applied element-wise to the elements of the lists, and a count is tallied of the number of elements that produce a true value. This count is returned. <code>count</code> is &quot;iterative&quot; in that it is guaranteed to apply <code>pred</code> to the list elements in a left-to-right order. The counting stops when the shortest list expires.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(count <span class="kw">even?</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span> <span class="dv">5</span> <span class="dv">6</span>)) <span class="kw">=&gt;</span> <span class="dv">3</span>
(count <span class="kw">&lt;</span> &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">4</span> <span class="dv">8</span>) &#39;(<span class="dv">2</span> <span class="dv">4</span> <span class="dv">6</span> <span class="dv">8</span> <span class="dv">10</span> <span class="dv">12</span> <span class="dv">14</span> <span class="dv">16</span>)) <span class="kw">=&gt;</span> <span class="dv">3</span></code></pre></div>
<p>At least one of the argument lists must be finite:</p>
<pre><code>(count &lt; &#39;(3 1 4 1) (circular-list 1 10)) =&gt; 2</code></pre>
<h4 id="fold-unfold-map">Fold, unfold &amp; map</h4>
<h5 id="fold-kons-knil-list1-..."><code>(fold kons knil list1 ...)</code></h5>
<p>TODO</p>
<h5 id="fold-right-kons-knil-list1-..."><code>(fold-right kons knil list1 ...)</code></h5>
<p>TODO</p>
<h5 id="pair-fold-kons-knil-list1-..."><code>(pair-fold kons knil list1 ...)</code></h5>
<p>TODO</p>
<h5 id="pair-fold-right-kons-knil-list1-..."><code>(pair-fold-right kons knil list1 ...)</code></h5>
<p>TODO</p>
<h5 id="reduce-f-ridentity-list"><code>(reduce f ridentity list)</code></h5>
<p><code>reduce</code> is a variant of <code>fold</code>.</p>
<p><code>ridentity</code> should be a &quot;right identity&quot; of the procedure <code>f</code> -- that is, for any value <code>x</code> acceptable to <code>f</code>:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(f x ridentity) <span class="co">;; =&gt; x</span></code></pre></div>
<p>Note: that <code>ridentity</code> is used only in the empty-list case. You typically use reduce when applying <code>f</code> is expensive and you'd like to avoid the extra application incurred when fold applies <code>f</code> to the head of list and the identity value, redundantly producing the same value passed in to <code>f</code>. For example, if <code>f</code> involves searching a file directory or performing a database query, this can be significant. In general, however, <code>fold</code> is useful in many contexts where <code>reduce</code> is not (consider the examples given in the <code>fold</code> definition -- only one of the five folds uses a function with a right identity. The other four may not be performed with reduce).</p>
<h5 id="reducse-right-f-ridentity-list"><code>(reducse-right f ridentity list)</code></h5>
<p><code>reduce-right</code> is the <code>fold-right</code> variant of reduce. It obeys the following definition:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(reduce-right f ridentity &#39;()) <span class="kw">=</span> ridentity
(reduce-right f ridentity &#39;(e1)) <span class="kw">=</span> (f e1 ridentity) <span class="kw">=</span> e1
(reduce-right f ridentity &#39;(e1 e2 ...)) <span class="kw">=</span>
    (f e1 (reduce f ridentity (e2 ...)))</code></pre></div>
<p>... in other words, we compute <code>(fold-right f ridentity list)</code>.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span class="co">;; Append a bunch of lists together.</span>
<span class="co">;; I.e., (apply append list-of-lists)</span>
(reduce-right <span class="kw">append</span> &#39;() list-of-lists)</code></pre></div>
<h5 id="unfold-p-f-g-seed-tail-gen"><code>(unfold p f g seed [tail-gen])</code></h5>
<p>TODO</p>
<h5 id="unfold-right-p-f-g-seed-tail-gen"><code>(unfold-right p f g seed [tail-gen])</code></h5>
<p>TODO</p>
<h5 id="map-proc-list1-...-1"><code>(map proc list1 ...)</code></h5>
<p><code>proc</code> is a procedure taking as many arguments as there are list arguments and returning a single value. map applies <code>proc</code> element-wise to the elements of the lists and returns a list of the results, in order. The dynamic order in which proc is applied to the elements of the lists is unspecified.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(map <span class="kw">cadr</span> &#39;((a b) (d e) (g h))) <span class="kw">=&gt;</span>  (b e h)

(map (<span class="kw">lambda</span> (n) (<span class="kw">expt</span> n n))
     &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>))
    <span class="kw">=&gt;</span>  (<span class="dv">1</span> <span class="dv">4</span> <span class="dv">27</span> <span class="dv">256</span> <span class="dv">3125</span>)

(map <span class="kw">+</span> &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>) &#39;(<span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>)) <span class="kw">=&gt;</span>  (<span class="dv">5</span> <span class="dv">7</span> <span class="dv">9</span>)

(<span class="kw">let</span> ((count <span class="dv">0</span>))
  (map (<span class="kw">lambda</span> (ignored)
         (set! count (<span class="kw">+</span> count <span class="dv">1</span>))
         count)
       &#39;(a b))) <span class="kw">=&gt;</span>  (<span class="dv">1</span> <span class="dv">2</span>) <span class="kw">or</span> (<span class="dv">2</span> <span class="dv">1</span>)</code></pre></div>
<p>At least one of the argument lists must be finite:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(map <span class="kw">+</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span>) (circular-list <span class="dv">1</span> <span class="dv">0</span>)) <span class="co">;; =&gt; (4 1 5 1)</span></code></pre></div>
<h5 id="for-each-proc-clist1-..."><code>(for-each proc clist1 ...)</code></h5>
<p>The arguments to <code>for-each</code> are like the arguments to <code>map</code>, but <code>for-each</code> calls <code>proc</code> for its side effects rather than for its values. Unlike <code>map</code>, <code>for-each</code> is guaranteed to call <code>proc</code> on the elements of the lists in order from the first element(s) to the last, and the value returned by for-each is unspecified.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">let</span> ((v (<span class="kw">make-vector</span> <span class="dv">5</span>)))
  (<span class="kw">for-each</span> (<span class="kw">lambda</span> (i)
              (<span class="kw">vector-set!</span> v i (* i i)))
            &#39;(<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>))
  v)  <span class="kw">=&gt;</span>  #(<span class="dv">0</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">9</span> <span class="dv">16</span>)</code></pre></div>
<p>At least one of the argument lists must be finite.</p>
<h5 id="append-map-f-list-..."><code>(append-map f list ...)</code></h5>
<h5 id="append-map-f-list-...-1"><code>(append-map! f list ...)</code></h5>
<p>Equivalent to:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(apply <span class="kw">append</span> (map f clist1 clist2 ...))</code></pre></div>
<p>And:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(apply append! (map f clist1 clist2 ...))</code></pre></div>
<p>Map <code>f</code> over the elements of the lists, just as in the <code>map</code> function. However, the results of the applications are appended together to make the final result. <code>append-map</code> uses <code>append</code> to append the results together; <code>append-map!</code> uses <code>append!</code>.</p>
<p>The dynamic order in which the various applications of <code>f</code> are made is not specified.</p>
<p>Example:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(append-map! (<span class="kw">lambda</span> (x) (<span class="kw">list</span> x (<span class="kw">-</span> x))) &#39;(<span class="dv">1</span> <span class="dv">3</span> <span class="dv">8</span>)) <span class="co">;; =&gt; (1 -1 3 -3 8 -8)</span></code></pre></div>
<p>At least one of the list arguments must be finite.</p>
<h5 id="map-f-list1-..."><code>(map! f list1 ...)</code></h5>
<p>Linear-update variant of <code>map</code> -- <code>map!</code> is allowed, but not required, to alter the cons cells of <code>list1</code> to construct the result list.</p>
<p>The dynamic order in which the various applications of <code>f</code> are made is not specified. In the n-ary case, <code>clist2</code>, <code>clist3</code>, ... must have at least as many elements as <code>list1</code>.</p>
<h5 id="map-in-order-f-clist1-..."><code>(map-in-order f clist1 ...)</code></h5>
<p>A variant of the map procedure that guarantees to apply <code>f</code> across the elements of the <code>clisti</code> arguments in a left-to-right order. This is useful for mapping procedures that both have side effects and return useful values.</p>
<p>At least one of the list arguments must be finite.</p>
<h5 id="pair-for-each-f-clist1-..."><code>(pair-for-each f clist1 ...)</code></h5>
<p>Like for-each, but <code>f</code> is applied to successive sublists of the argument lists. That is, <code>f</code> is applied to the <code>cons</code> cells of the lists, rather than the lists' elements. These applications occur in left-to-right order.</p>
<p>The f procedure may reliably apply <code>set-cdr!</code> to the pairs it is given without altering the sequence of execution.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(pair-for-each (<span class="kw">lambda</span> (pair) (<span class="kw">display</span> pair) (<span class="kw">newline</span>)) &#39;(a b c))
 <span class="co">;; =&gt; (a b c)</span>
 <span class="co">;; =&gt; (b c)</span>
 <span class="co">;; =&gt; (c)</span></code></pre></div>
<p>At least one of the list arguments must be finite.</p>
<h5 id="filter-map-f-clist1-..."><code>(filter-map f clist1 ...)</code></h5>
<p>Like <code>map</code>, but only true values are saved.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(filter-map (<span class="kw">lambda</span> (x) (<span class="kw">and</span> (<span class="kw">number?</span> x) (* x x))) &#39;(a <span class="dv">1</span> b <span class="dv">3</span> c <span class="dv">7</span>))
    <span class="co">;; =&gt; (1 9 49)</span></code></pre></div>
<p>The dynamic order in which the various applications of <code>f</code> are made is not specified.</p>
<p>At least one of the list arguments must be finite.</p>
<h4 id="filtering-partitioning">Filtering &amp; partitioning</h4>
<h5 id="filter-pred-list"><code>(filter pred list)</code></h5>
<p>Return all the elements of list that satisfy predicate <code>pred</code>. The list is not disordered -- elements that appear in the result list occur in the same order as they occur in the argument list. The returned list may share a common tail with the argument list. The dynamic order in which the various applications of <code>pred</code> are made is not specified.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(filter <span class="kw">even?</span> &#39;(<span class="dv">0</span> <span class="dv">7</span> <span class="dv">8</span> <span class="dv">8</span> <span class="dv">43</span> <span class="dv">-4</span>)) <span class="kw">=&gt;</span> (<span class="dv">0</span> <span class="dv">8</span> <span class="dv">8</span> <span class="dv">-4</span>)</code></pre></div>
<h5 id="partition-pred-list"><code>(partition pred list)</code></h5>
<p>Partitions the elements of list with predicate <code>pred</code>, and returns two values: the list of in-elements and the list of out-elements. The list is not disordered -- elements occur in the result lists in the same order as they occur in the argument list. The dynamic order in which the various applications of pred are made is not specified. One of the returned lists may share a common tail with the argument list.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(partition <span class="kw">symbol?</span> &#39;(one <span class="dv">2</span> <span class="dv">3</span> four five <span class="dv">6</span>)) <span class="kw">=&gt;</span>
    (one four five)
    (<span class="dv">2</span> <span class="dv">3</span> <span class="dv">6</span>)</code></pre></div>
<h5 id="remove-pred-list"><code>(remove pred list)</code></h5>
<p>Returns <code>list</code> without the elements that satisfy predicate <code>pred</code>:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">lambda</span> (pred <span class="kw">list</span>) (filter (<span class="kw">lambda</span> (x) (<span class="kw">not</span> (pred x))) <span class="kw">list</span>))</code></pre></div>
<p>The <code>list</code> is not disordered -- elements that appear in the result list occur in the same order as they occur in the argument list. The returned list may share a common tail with the argument list. The dynamic order in which the various applications of <code>pred</code> are made is not specified.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(remove <span class="kw">even?</span> &#39;(<span class="dv">0</span> <span class="dv">7</span> <span class="dv">8</span> <span class="dv">8</span> <span class="dv">43</span> <span class="dv">-4</span>)) <span class="kw">=&gt;</span> (<span class="dv">7</span> <span class="dv">43</span>)</code></pre></div>
<h5 id="filter-pred-list-1"><code>(filter! pred list)</code></h5>
<h5 id="partition-pred-list-1"><code>(partition! pred list)</code></h5>
<h5 id="remove-pred-list-1"><code>(remove! pred list)</code></h5>
<p>Linear-update variants of <code>filter</code>, <code>partition</code> and <code>remove</code>. These procedures are allowed, but not required, to alter the cons cells in the argument list to construct the result lists.</p>
<h4 id="searching">Searching</h4>
<h5 id="find-pred-clist"><code>(find pred clist)</code></h5>
<p>Return the first element of clist that satisfies predicate <code>pred</code>; false if no element does.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(find <span class="kw">even?</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span>)) <span class="kw">=&gt;</span> <span class="dv">4</span></code></pre></div>
<p>Note that <code>find</code> has an ambiguity in its lookup semantics -- if <code>find</code> returns <code>#f</code>, you cannot tell (in general) if it found a #f element that satisfied <code>pred</code>, or if it did not find any element at all. In many situations, this ambiguity cannot arise -- either the list being searched is known not to contain any <code>#f</code> elements, or the list is guaranteed to have an element satisfying <code>pred</code>. However, in cases where this ambiguity can arise, you should use <code>find-tail</code> instead of find -- <code>find-tail</code> has no such ambiguity.</p>
<h5 id="find-tail-pred-clist"><code>(find-tail pred clist)</code></h5>
<p>Return the first pair of <code>clist</code> whose <code>car</code> satisfies <code>pred</code>. If no pair does, return false.</p>
<p><code>find-tail</code> can be viewed as a general-predicate variant of the member function.</p>
<p>Examples:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(find-tail <span class="kw">even?</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">37</span> <span class="dv">-8</span> <span class="dv">-5</span> <span class="dv">0</span> <span class="dv">0</span>)) <span class="kw">=&gt;</span> (-<span class="dv">8</span> <span class="dv">-5</span> <span class="dv">0</span> <span class="dv">0</span>)
(find-tail <span class="kw">even?</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">37</span> <span class="dv">-5</span>)) <span class="kw">=&gt;</span> <span class="dv">#f</span>

<span class="co">;; MEMBER X LIS:</span>
(find-tail (<span class="kw">lambda</span> (elt) (<span class="kw">equal?</span> x elt)) lis)</code></pre></div>
<p>In the circular-list case, this procedure &quot;rotates&quot; the list.</p>
<p><code>find-tail</code> is essentially drop-while, where the sense of the predicate is inverted: <code>find-tail</code> searches until it finds an element satisfying the predicate; drop-while searches until it finds an element that doesn't satisfy the predicate.</p>
<h5 id="take-while-pred-clist"><code>(take-while  pred clist)</code></h5>
<h5 id="take-while-pred-clist-1"><code>(take-while! pred clist)</code></h5>
<p>Returns the longest initial prefix of <code>clist</code> whose elements all satisfy the predicate <code>pred</code>.</p>
<p><code>take-while!</code> is the linear-update variant. It is allowed, but not required, to alter the argument list to produce the result.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(take-while <span class="kw">even?</span> &#39;(<span class="dv">2</span> <span class="dv">18</span> <span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)) <span class="kw">=&gt;</span> (<span class="dv">2</span> <span class="dv">18</span>)</code></pre></div>
<h5 id="drop-while-pred-clist"><code>(drop-while pred clist)</code></h5>
<p>Drops the longest initial prefix of <code>clist</code> whose elements all satisfy the predicate <code>pred</code>, and returns the rest of the list.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(drop-while <span class="kw">even?</span> &#39;(<span class="dv">2</span> <span class="dv">18</span> <span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)) <span class="kw">=&gt;</span> (<span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)</code></pre></div>
<p>The circular-list case may be viewed as &quot;rotating&quot; the list.</p>
<h5 id="span-pred-clist"><code>(span pred clist)</code></h5>
<h5 id="span-pred-list"><code>(span!  pred list)</code></h5>
<h5 id="break-pred-clist"><code>(break  pred clist)</code></h5>
<h5 id="break-pred-list">`(break! pred list)</h5>
<p>Span splits the list into the longest initial prefix whose elements all satisfy <code>pred</code>, and the remaining tail. Break inverts the sense of the predicate: the tail commences with the first element of the input list that satisfies the predicate.</p>
<p>In other words: <code>span</code> finds the intial span of elements satisfying <code>pred</code>, and break breaks the list at the first element satisfying <code>pred</code>.</p>
<p>Span is equivalent to</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">values</span> (take-while pred clist)
        (drop-while pred clist))</code></pre></div>
<p><code>span!</code> and <code>break!</code> are the linear-update variants. They are allowed, but not required, to alter the argument list to produce the result.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(span <span class="kw">even?</span> &#39;(<span class="dv">2</span> <span class="dv">18</span> <span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)) <span class="kw">=&gt;</span>
      (<span class="dv">2</span> <span class="dv">18</span>)
      (<span class="dv">3</span> <span class="dv">10</span> <span class="dv">22</span> <span class="dv">9</span>)

(<span class="kw">break</span> <span class="kw">even?</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span>)) <span class="kw">=&gt;</span>
      (<span class="dv">3</span> <span class="dv">1</span>)
      (<span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span>)</code></pre></div>
<h5 id="any-pred-clist1-..."><code>(any pred clist1 ...)</code></h5>
<p>Applies the predicate across the lists, returning true if the predicate returns true on any application.</p>
<p>If there are n list arguments <code>clist1 ... clistn</code>, then <code>pred</code> must be a procedure taking n arguments and returning a single value, interpreted as a boolean (that is, <code>#f</code> means false, and any other value means true).</p>
<p><code>any</code> applies <code>pred</code> to the first elements of the <code>clisti</code> parameters. If this application returns a true value, any immediately returns that value. Otherwise, it iterates, applying <code>pred</code> to the second elements of the <code>clisti</code> parameters, then the third, and so forth. The iteration stops when a true value is produced or one of the lists runs out of values; in the latter case, any returns <code>#f</code>. The application of pred to the last element of the lists is a tail call.</p>
<p>Note the difference between <code>find</code> and <code>any</code> -- <code>find</code> returns the element that satisfied the predicate; <code>any</code> returns the true value that the predicate produced.</p>
<p>Like <code>every</code>, <code>any</code>'s name does not end with a question mark -- this is to indicate that it does not return a simple boolean (#t or #f), but a general value.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(any <span class="kw">integer?</span> &#39;(a <span class="dv">3</span> b <span class="fl">2.7</span>))   <span class="kw">=&gt;</span> <span class="dv">#t</span>
(any <span class="kw">integer?</span> &#39;(a <span class="fl">3.1</span> b <span class="fl">2.7</span>)) <span class="kw">=&gt;</span> <span class="dv">#f</span>
(any <span class="kw">&lt;</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span>)
           &#39;(<span class="dv">2</span> <span class="dv">7</span> <span class="dv">1</span> <span class="dv">8</span> <span class="dv">2</span>)) <span class="kw">=&gt;</span> <span class="dv">#t</span></code></pre></div>
<h5 id="every-pred-clist1-..."><code>(every pred clist1 ...)</code></h5>
<p>Applies the predicate across the lists, returning true if the predicate returns true on every application.</p>
<p>If there are n list arguments <code>clist1 ... clistn</code>, then <code>pred</code> must be a procedure taking n arguments and returning a single value, interpreted as a boolean (that is, #f means false, and any other value means true).</p>
<p><code>every</code> applies <code>pred</code> to the first elements of the <code>clisti</code> parameters. If this application returns false, every immediately returns false. Otherwise, it iterates, applying <code>pred</code> to the second elements of the <code>clisti</code> parameters, then the third, and so forth. The iteration stops when a false value is produced or one of the lists runs out of values. In the latter case, <code>every</code> returns the true value produced by its final application of pred. The application of <code>pred</code> to the last element of the lists is a tail call.</p>
<p>If one of the <code>clisti</code> has no elements, <code>every</code> simply returns #t.</p>
<p>Like <code>any</code>, <code>every</code>'s name does not end with a question mark -- this is to indicate that it does not return a simple boolean (<code>#t</code> or <code>#f</code>), but a general value.</p>
<h5 id="list-index-pred-clist1-..."><code>(list-index pred clist1 ...)</code></h5>
<p>Return the index of the leftmost element that satisfies <code>pred</code>.</p>
<p>If there are n list arguments <code>clist1 ... clistn</code>, then <code>pred</code> must be a function taking n arguments and returning a single value, interpreted as a boolean (that is, <code>#f</code> means false, and any other value means true).</p>
<p><code>list-index</code> applies <code>pred</code> to the first elements of the <code>clisti</code> parameters. If this application returns true, <code>list-index</code> immediately returns zero. Otherwise, it iterates, applying <code>pred</code> to the second elements of the <code>clisti</code> parameters, then the third, and so forth. When it finds a tuple of list elements that cause <code>pred</code> to return true, it stops and returns the zero-based index of that position in the lists.</p>
<p>The iteration stops when one of the lists runs out of values; in this case, <code>list-index</code> returns <code>#f</code>.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(list-index <span class="kw">even?</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span>)) <span class="kw">=&gt;</span> <span class="dv">2</span>
(list-index <span class="kw">&lt;</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span> <span class="dv">5</span> <span class="dv">6</span>) &#39;(<span class="dv">2</span> <span class="dv">7</span> <span class="dv">1</span> <span class="dv">8</span> <span class="dv">2</span>)) <span class="kw">=&gt;</span> <span class="dv">1</span>
(list-index <span class="kw">=</span> &#39;(<span class="dv">3</span> <span class="dv">1</span> <span class="dv">4</span> <span class="dv">1</span> <span class="dv">5</span> <span class="dv">9</span> <span class="dv">2</span> <span class="dv">5</span> <span class="dv">6</span>) &#39;(<span class="dv">2</span> <span class="dv">7</span> <span class="dv">1</span> <span class="dv">8</span> <span class="dv">2</span>)) <span class="kw">=&gt;</span> <span class="dv">#f</span></code></pre></div>
<h5 id="member-x-list"><code>(member x list [=])</code></h5>
<h5 id="memq-x-list"><code>(memq x list)</code></h5>
<h5 id="memv-x-list"><code>(memv x list)</code></h5>
<p>These procedures return the first sublist of <code>list</code> whose <code>car</code> is <code>x</code>, where the sublists of <code>list</code> are the non-empty lists returned by <code>(drop list i)</code> for <code>i</code> less than the length of list. If <code>x</code> does not occur in list, then <code>#f</code> is returned. <code>memq</code> uses <code>eq?</code> to compare <code>x</code> with the elements of list, while <code>memv</code> uses <code>eqv?</code>, and <code>member</code> uses <code>equal?</code>.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">memq</span> &#39;a &#39;(a b c))          <span class="kw">=&gt;</span>  (a b c)
(<span class="kw">memq</span> &#39;b &#39;(a b c))          <span class="kw">=&gt;</span>  (b c)
(<span class="kw">memq</span> &#39;a &#39;(b c d))          <span class="kw">=&gt;</span>  <span class="dv">#f</span>
(<span class="kw">memq</span> (<span class="kw">list</span> &#39;a) &#39;(b (a) c)) <span class="kw">=&gt;</span>  <span class="dv">#f</span>
(<span class="kw">member</span> (<span class="kw">list</span> &#39;a) &#39;(b (a) c))         <span class="kw">=&gt;</span>  ((a) c)
(<span class="kw">memq</span> <span class="dv">101</span> &#39;(<span class="dv">100</span> <span class="dv">101</span> <span class="dv">102</span>))   <span class="kw">=&gt;</span>  *unspecified*
(<span class="kw">memv</span> <span class="dv">101</span> &#39;(<span class="dv">100</span> <span class="dv">101</span> <span class="dv">102</span>))   <span class="kw">=&gt;</span>  (<span class="dv">101</span> <span class="dv">102</span>)</code></pre></div>
<p>The comparison procedure is used to compare the elements <code>ei</code> of list to the key <code>x</code> in this way:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">=</span> x ei) <span class="co">; list is (e1 ... en)</span></code></pre></div>
<p>That is, the first argument is always <code>x</code>, and the second argument is one of the list elements. Thus one can reliably find the first element of list that is greater than five with <code>(member 5 list &lt;)</code></p>
<p>Note that fully general list searching may be performed with the <code>find-tail</code> and <code>find</code> procedures, e.g.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(find-tail <span class="kw">even?</span> <span class="kw">list</span>) <span class="co">; Find the first elt with an even key.</span></code></pre></div>
<h4 id="deleting">Deleting</h4>
<h5 id="delete-x-list"><code>(delete x list)</code></h5>
<h5 id="delete-x-list-1"><code>(delete! x list)</code></h5>
<p><code>delete</code> uses the comparison procedure <code>=</code>, which defaults to <code>equal?</code>, to find all elements of list that are equal to <code>x</code>, and deletes them from list. The dynamic order in which the various applications of <code>=</code> are made is not specified.</p>
<p>The list is not disordered -- elements that appear in the result list occur in the same order as they occur in the argument list. The result may share a common tail with the argument list.</p>
<p>Note that fully general element deletion can be performed with the <code>remove</code> and <code>remove!</code> procedures, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span class="co">;; Delete all the even elements from LIS:</span>
(remove <span class="kw">even?</span> lis)</code></pre></div>
<p>The comparison procedure is used in this way: <code>(= x ei)</code>. That is, <code>x</code> is always the first argument, and a list element is always the second argument. The comparison procedure will be used to compare each element of list exactly once; the order in which it is applied to the various <code>ei</code> is not specified. Thus, one can reliably remove all the numbers greater than five from a list with <code>(delete 5 list &lt;)</code>.</p>
<p><code>delete!</code> is the linear-update variant of <code>delete</code>. It is allowed, but not required, to alter the cons cells in its argument list to construct the result.</p>
<h5 id="delete-duplicates-list"><code>(delete-duplicates  list [=])</code></h5>
<h5 id="delete-duplicates-list-1"><code>(delete-duplicates! list [=])</code></h5>
<p><code>delete-duplicates</code> removes duplicate elements from the list argument. If there are multiple equal elements in the argument list, the result list only contains the first or leftmost of these elements in the result. The order of these surviving elements is the same as in the original list -- delete-duplicates does not disorder the list (hence it is useful for &quot;cleaning up&quot; association lists).</p>
<p>The <code>=</code> parameter is used to compare the elements of the list; it defaults to equal?. If x comes before y in list, then the comparison is performed (= x y). The comparison procedure will be used to compare each pair of elements in list no more than once; the order in which it is applied to the various pairs is not specified.</p>
<p>Implementations of <code>delete-duplicates</code> are allowed to share common tails between argument and result lists -- for example, if the list argument contains only unique elements, it may simply return exactly this list.</p>
<p>Be aware that, in general, delete-duplicates runs in time O(n2) for n-element lists. Uniquifying long lists can be accomplished in O(n lg n) time by sorting the list to bring equal elements together, then using a linear-time algorithm to remove equal elements. Alternatively, one can use algorithms based on element-marking, with linear-time results.</p>
<p><code>delete-duplicates!</code> is the linear-update variant of <code>delete-duplicates</code>; it is allowed, but not required, to alter the cons cells in its argument list to construct the result.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(delete-duplicates &#39;(a b a c a b c z)) <span class="kw">=&gt;</span> (a b c z)

<span class="co">;; Clean up an alist:</span>
(delete-duplicates &#39;((a . <span class="dv">3</span>) (b . <span class="dv">7</span>) (a . <span class="dv">9</span>) (c . <span class="dv">1</span>))
                   (<span class="kw">lambda</span> (x y) (<span class="kw">eq?</span> (<span class="kw">car</span> x) (<span class="kw">car</span> y))))
<span class="co">;;  =&gt; ((a . 3) (b . 7) (c . 1))</span></code></pre></div>
<h4 id="association-lists">Association lists</h4>
<p>An &quot;association list&quot; (or &quot;alist&quot;) is a list of pairs. The car of each pair contains a key value, and the cdr contains the associated data value. They can be used to construct simple look-up tables in Scheme. Note that association lists are probably inappropriate for performance-critical use on large data; in these cases, hash tables or some other alternative should be employed.</p>
<h5 id="assoc-key-alist"><code>(assoc key alist [=])</code></h5>
<h5 id="assq-key-alist"><code>(assq key alist)</code></h5>
<h5 id="assv-key-alist"><code>(assv key alist)</code></h5>
<p><code>alist</code> must be an association list -- a list of pairs. These procedures find the first pair in <code>alist</code> whose <code>car</code> field is <code>key</code>, and returns that pair. If no pair in <code>alist</code> has <code>key</code> as its <code>car</code>, then <code>#f</code> is returned. <code>assq</code> uses <code>eq?</code> to compare <code>key</code> with the <code>car</code> fields of the pairs in <code>alist</code>, while <code>assv</code> uses <code>eqv?</code> and <code>assoc</code> uses <code>equal?</code>.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> e </span>&#39;((a <span class="dv">1</span>) (b <span class="dv">2</span>) (c <span class="dv">3</span>)))
(<span class="kw">assq</span> &#39;a e)                            <span class="kw">=&gt;</span>  (a <span class="dv">1</span>)
(<span class="kw">assq</span> &#39;b e)                            <span class="kw">=&gt;</span>  (b <span class="dv">2</span>)
(<span class="kw">assq</span> &#39;d e)                            <span class="kw">=&gt;</span>  <span class="dv">#f</span>
(<span class="kw">assq</span> (<span class="kw">list</span> &#39;a) &#39;(((a)) ((b)) ((c))))  <span class="kw">=&gt;</span>  <span class="dv">#f</span>
(<span class="kw">assoc</span> (<span class="kw">list</span> &#39;a) &#39;(((a)) ((b)) ((c)))) <span class="kw">=&gt;</span>  ((a))
(<span class="kw">assq</span> <span class="dv">5</span> &#39;((<span class="dv">2</span> <span class="dv">3</span>) (<span class="dv">5</span> <span class="dv">7</span>) (<span class="dv">11</span> <span class="dv">13</span>)))    <span class="kw">=&gt;</span>  *unspecified*
(<span class="kw">assv</span> <span class="dv">5</span> &#39;((<span class="dv">2</span> <span class="dv">3</span>) (<span class="dv">5</span> <span class="dv">7</span>) (<span class="dv">11</span> <span class="dv">13</span>)))    <span class="kw">=&gt;</span>  (<span class="dv">5</span> <span class="dv">7</span>)</code></pre></div>
<p>The comparison procedure is used to compare the elements <code>ei</code> of list to the <code>key</code> parameter in this way:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">=</span> key (<span class="kw">car</span> ei)) <span class="co">; list is (E1 ... En)</span></code></pre></div>
<p>That is, the first argument is always <code>key</code>, and the second argument is one of the list elements. Thus one can reliably find the first entry of alist whose key is greater than five with <code>(assoc 5 alist &lt;)</code></p>
<p>Note that fully general <code>alist</code> searching may be performed with the <code>find-tail</code> and <code>find</code> procedures, e.g.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span class="co">;; Look up the first association in alist with an even key:</span>
(find (<span class="kw">lambda</span> (a) (<span class="kw">even?</span> (<span class="kw">car</span> a))) alist)</code></pre></div>
<h5 id="alist-cons-key-datum-alist"><code>(alist-cons key datum alist)</code></h5>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">lambda</span> (key datum alist) (<span class="kw">cons</span> (<span class="kw">cons</span> key datum) alist))</code></pre></div>
<p><code>cons</code> a new entry mapping <code>key</code> to <code>datum</code> onto <code>alist</code>.</p>
<h5 id="alist-copy-alist"><code>(alist-copy alist)</code></h5>
<p>Make a fresh copy of <code>alist</code>. This means copying each pair that forms an association as well as the spine of the list, i.e.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">lambda</span> (a) (map (<span class="kw">lambda</span> (elt) (<span class="kw">cons</span> (<span class="kw">car</span> elt) (<span class="kw">cdr</span> elt))) a))</code></pre></div>
<h5 id="alist-delete-key-alist"><code>(alist-delete  key alist [=])</code></h5>
<h5 id="alist-delete-key-alist-1"><code>(alist-delete! key alist [=])</code></h5>
<p><code>alist-delete</code> deletes all associations from alist with the given key, using key-comparison procedure <code>=</code>, which defaults to equal?. The dynamic order in which the various applications of = are made is not specified.</p>
<p>Return values may share common tails with the alist argument. The alist is not disordered -- elements that appear in the result alist occur in the same order as they occur in the argument alist.</p>
<p>The comparison procedure is used to compare the element keys ki of alist's entries to the key parameter in this way: (= key ki). Thus, one can reliably remove all entries of alist whose key is greater than five with (alist-delete 5 alist &lt;)</p>
<p>alist-delete! is the linear-update variant of alist-delete. It is allowed, but not required, to alter cons cells from the alist parameter to construct the result.</p>
<h4 id="set-operations-on-lists">Set operations on lists</h4>
<p>These procedures implement operations on sets represented as lists of elements. They all take an = argument used to compare elements of lists. This equality procedure is required to be consistent with eq?. That is, it must be the case that <code>(eq? x y) =&gt; (= x y)</code>.</p>
<p>Note that this implies, in turn, that two lists that are eq? are also set-equal by any legal comparison procedure. This allows for constant-time determination of set operations on eq? lists.</p>
<p>Be aware that these procedures typically run in time O(n * m) for n- and m-element list arguments. Performance-critical applications operating upon large sets will probably wish to use other data structures and algorithms.</p>
<h5 id="lset-list1-..."><code>(lset&lt;= = list1 ...)</code></h5>
<p>Returns true iff every listi is a subset of listi+1, using = for the element-equality procedure. List A is a subset of list B if every element in A is equal to some element of B. When performing an element comparison, the = procedure's first argument is an element of A; its second, an element of B.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(lset&lt;= <span class="kw">eq?</span> &#39;(a) &#39;(a b a) &#39;(a b c c)) <span class="kw">=&gt;</span> <span class="dv">#t</span>

(lset&lt;= <span class="kw">eq?</span>) <span class="kw">=&gt;</span> <span class="dv">#t</span>             <span class="co">; Trivial cases</span>
(lset&lt;= <span class="kw">eq?</span> &#39;(a)) <span class="kw">=&gt;</span> <span class="dv">#t</span></code></pre></div>
<h5 id="lset-list1-...-1"><code>(lset= = list1 ...)</code></h5>
<p>Returns true iff every listi is set-equal to listi+1, using = for the element-equality procedure. &quot;Set-equal&quot; simply means that listi is a subset of listi+1, and listi+1 is a subset of listi. The = procedure's first argument is an element of listi; its second is an element of listi+1.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(lset= <span class="kw">eq?</span> &#39;(b e a) &#39;(a e b) &#39;(e e b a)) <span class="kw">=&gt;</span> <span class="dv">#t</span>

(lset= <span class="kw">eq?</span>) <span class="kw">=&gt;</span> <span class="dv">#t</span>               <span class="co">; Trivial cases</span>
(lset= <span class="kw">eq?</span> &#39;(a)) <span class="kw">=&gt;</span> <span class="dv">#t</span></code></pre></div>
<h5 id="lset-adjoin-list-elt1-..."><code>(lset-adjoin = list elt1 ...)</code></h5>
<p>Adds the elti elements not already in the list parameter to the result list. The result shares a common tail with the list parameter. The new elements are added to the front of the list, but no guarantees are made about their order. The = parameter is an equality procedure used to determine if an elti is already a member of list. Its first argument is an element of list; its second is one of the elti.</p>
<p>The list parameter is always a suffix of the result -- even if the list parameter contains repeated elements, these are not reduced.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(lset-adjoin <span class="kw">eq?</span> &#39;(a b c d c e) &#39;a &#39;e &#39;i &#39;o &#39;u) <span class="kw">=&gt;</span> (u o i a b c d c e)</code></pre></div>
<h5 id="lset-union-list1-..."><code>(lset-union = list1 ...)</code></h5>
<p>Returns the union of the lists, using = for the element-equality procedure.</p>
<p>The union of lists A and B is constructed as follows:</p>
<ul>
<li>If A is the empty list, the answer is B (or a copy of B).</li>
<li>Otherwise, the result is initialised to be list A (or a copy of A).</li>
<li>Proceed through the elements of list B in a left-to-right order. If b is such an element of B, compare every element r of the current result list to b: (= r b). If all comparisons fail, b is consed onto the front of the result.</li>
</ul>
<p>However, there is no guarantee that = will be applied to every pair of arguments from A and B. In particular, if A is eq? to B, the operation may immediately terminate.</p>
<p>In the n-ary case, the two-argument list-union operation is simply folded across the argument lists.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(lset-union <span class="kw">eq?</span> &#39;(a b c d e) &#39;(a e i o u)) <span class="kw">=&gt;</span>
        (u o i a b c d e)

<span class="co">;; Repeated elements in LIST1 are preserved.</span>
(lset-union <span class="kw">eq?</span> &#39;(a a c) &#39;(x a x)) <span class="kw">=&gt;</span> (x a a c)

<span class="co">;; Trivial cases</span>
(lset-union <span class="kw">eq?</span>) <span class="kw">=&gt;</span> ()
(lset-union <span class="kw">eq?</span> &#39;(a b c)) <span class="kw">=&gt;</span> (a b c)</code></pre></div>
<h5 id="lset-intersection-list1-list2-..."><code>(lset-intersection = list1 list2 ...)</code></h5>
<p>Returns the intersection of the lists, using = for the element-equality procedure.</p>
<p>The intersection of lists A and B is comprised of every element of A that is = to some element of B: (= a b), for a in A, and b in B. Note this implies that an element which appears in B and multiple times in list A will also appear multiple times in the result.</p>
<p>The order in which elements appear in the result is the same as they appear in list1 -- that is, lset-intersection essentially filters list1, without disarranging element order. The result may share a common tail with list1.</p>
<p>In the n-ary case, the two-argument list-intersection operation is simply folded across the argument lists. However, the dynamic order in which the applications of = are made is not specified. The procedure may check an element of list1 for membership in every other list before proceeding to consider the next element of list1, or it may completely intersect list1 and list2 before proceeding to list3, or it may go about its work in some third order.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(lset-intersection <span class="kw">eq?</span> &#39;(a b c d e) &#39;(a e i o u)) <span class="kw">=&gt;</span> (a e)

<span class="co">;; Repeated elements in LIST1 are preserved.</span>
(lset-intersection <span class="kw">eq?</span> &#39;(a x y a) &#39;(x a x z)) <span class="kw">=&gt;</span> &#39;(a x a)

(lset-intersection <span class="kw">eq?</span> &#39;(a b c)) <span class="kw">=&gt;</span> (a b c)     <span class="co">; Trivial case</span></code></pre></div>
<h5 id="lset-difference-list1-list2-..."><code>(lset-difference = list1 list2 ...)</code></h5>
<p>Returns the difference of the lists, using = for the element-equality procedure -- all the elements of list1 that are not = to any element from one of the other listi parameters.</p>
<p>The = procedure's first argument is always an element of list1; its second is an element of one of the other listi. Elements that are repeated multiple times in the list1 parameter will occur multiple times in the result. The order in which elements appear in the result is the same as they appear in list1 -- that is, lset-difference essentially filters list1, without disarranging element order. The result may share a common tail with list1. The dynamic order in which the applications of = are made is not specified. The procedure may check an element of list1 for membership in every other list before proceeding to consider the next element of list1, or it may completely compute the difference of list1 and list2 before proceeding to list3, or it may go about its work in some third order.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(lset-difference <span class="kw">eq?</span> &#39;(a b c d e) &#39;(a e i o u)) <span class="kw">=&gt;</span> (b c d)

(lset-difference <span class="kw">eq?</span> &#39;(a b c)) <span class="kw">=&gt;</span> (a b c) <span class="co">; Trivial case</span></code></pre></div>
<h5 id="lset-xor-list1-...">`(lset-xor = list1 ...)</h5>
<p>Returns the exclusive-or of the sets, using = for the element-equality procedure. If there are exactly two lists, this is all the elements that appear in exactly one of the two lists. The operation is associative, and thus extends to the n-ary case -- the elements that appear in an odd number of the lists. The result may share a common tail with any of the listi parameters.</p>
<p>More precisely, for two lists A and B, A xor B is a list of</p>
<ul>
<li>every element a of A such that there is no element b of B such that (= a b), and</li>
<li>every element b of B such that there is no element a of A such that (= b a).</li>
</ul>
<p>However, an implementation is allowed to assume that = is symmetric -- that is, that</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">=</span> a b) <span class="kw">=&gt;</span> (<span class="kw">=</span> b a).</code></pre></div>
<p>This means, for example, that if a comparison (= a b) produces true for some a in A and b in B, both a and b may be removed from inclusion in the result.</p>
<p>In the n-ary case, the binary-xor operation is simply folded across the lists.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(lset-xor <span class="kw">eq?</span> &#39;(a b c d e) &#39;(a e i o u)) <span class="kw">=&gt;</span> (d c b i o u)

<span class="co">;; Trivial cases.</span>
(lset-xor <span class="kw">eq?</span>) <span class="kw">=&gt;</span> ()
(lset-xor <span class="kw">eq?</span> &#39;(a b c d e)) <span class="kw">=&gt;</span> (a b c d e)</code></pre></div>
<h5 id="lset-diffintersection-list1-list2-..."><code>(lset-diff+intersection = list1 list2 ...)</code></h5>
<p>Returns two values -- the difference and the intersection of the lists. Is equivalent to:</p>
<pre><code>(values (lset-difference = list1 list2 ...)
        (lset-intersection = list1
                             (lset-union = list2 ...)))</code></pre>
<p>But can be implemented more efficiently.</p>
<p>The = procedure's first argument is an element of list1; its second is an element of one of the other listi.</p>
<p>Either of the answer lists may share a common tail with list1. This operation essentially partitions list1.</p>
<h5 id="lset-union-list1-...-1"><code>(lset-union! list1 ...)</code></h5>
<h5 id="lset-intersection-list1-..."><code>(lset-intersection! list1 ...)</code></h5>
<h5 id="lset-difference-list1-..."><code>(lset-difference! list1 ...)</code></h5>
<h5 id="lset-xor-list1-...-1"><code>(lset-xor! list1 ...)</code></h5>
<h5 id="lset-diffintersection-list1-..."><code>(lset-diff+intersection! list1 ...)</code></h5>
<p>These are linear-update variants. They are allowed, but not required, to use the cons cells in their first list parameter to construct their answer. lset-union! is permitted to recycle cons cells from any of its list arguments.</p>
<h4 id="primitive-side-effects">Primitive side-effects</h4>
<h5 id="set-car-pair-object"><code>(set-car! pair object)</code></h5>
<h5 id="set-cdr-pair-object"><code>(set-cdr! pair object)</code></h5>
<p>These procedures store object in the car and cdr field of pair, respectively. The value returned is unspecified.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> </span>(f) (<span class="kw">list</span> &#39;not-a-constant-list))
(<span class="kw">define</span><span class="fu"> </span>(g) &#39;(constant-list))
(<span class="kw">set-car!</span> (f) <span class="dv">3</span>) <span class="kw">=&gt;</span>  *unspecified*
(<span class="kw">set-car!</span> (g) <span class="dv">3</span>) <span class="kw">=&gt;</span>  *error*</code></pre></div>
<h2 id="srfi-srfi-2"><code>(srfi srfi-2)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-2/">SRFI-2</a>.</p>
<h3 id="abstract-2">Abstract</h3>
<p>Like an ordinary <code>and</code>, an <code>and-let*</code> special form evaluates its arguments -- expressions -- one after another in order, till the first one that yields <code>#f</code>. Unlike <code>and</code>, however, a non-<code>#f</code> result of one expression can be bound to a fresh variable and used in the subsequent expressions. <code>and-let*</code> is a cross-breed between <code>let*</code> and <code>and</code>.</p>
<h3 id="reference-2">Reference</h3>
<h4 id="and-let"><code>and-let*</code></h4>
<p><code>and-let*</code> is a generalized <code>and</code>: it evaluates a sequence of forms one after another till the first one that yields <code>#f</code>; the non-<code>#f</code> result of a form can be bound to a fresh variable and used in the subsequent forms.</p>
<h2 id="srfi-srfi-4"><code>(srfi srfi-4)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-4/">SRFI-4</a>.</p>
<h3 id="abstract-3">Abstract</h3>
<p>This SRFI describes a set of datatypes for vectors whose elements are of the same numeric type (signed or unsigned exact integer or inexact real of a given precision). These datatypes support operations analogous to the Scheme vector type, but they are distinct datatypes.</p>
<h3 id="reference-3">Reference</h3>
<h4 id="signed-8-bits-integer">Signed 8 bits integer</h4>
<h5 id="s8vector">s8vector?</h5>
<h5 id="make-s8vector">make-s8vector</h5>
<h5 id="s8vector-1">s8vector</h5>
<h5 id="s8vector-length">s8vector-length</h5>
<h5 id="s8vector-ref">s8vector-ref</h5>
<h5 id="s8vector-set">s8vector-set!</h5>
<h5 id="s8vector-list">s8vector-&gt;list</h5>
<h5 id="list-s8vector">list-&gt;s8vector</h5>
<h4 id="signed-16-bits-integer">Signed 16 bits integer</h4>
<h5 id="s16vector">s16vector?</h5>
<h5 id="make-s16vector">make-s16vector</h5>
<h5 id="s16vector-1">s16vector</h5>
<h5 id="s16vector-length">s16vector-length</h5>
<h5 id="s16vector-ref">s16vector-ref</h5>
<h5 id="s16vector-set">s16vector-set!</h5>
<h5 id="s16vector-list">s16vector-&gt;list</h5>
<h5 id="list-s16vector">list-&gt;s16vector</h5>
<h4 id="signed-32-bits-integer">Signed 32 bits integer</h4>
<h5 id="s32vector">s32vector?</h5>
<h5 id="make-s32vector">make-s32vector</h5>
<h5 id="s32vector-1">s32vector</h5>
<h5 id="s32vector-length">s32vector-length</h5>
<h5 id="s32vector-ref">s32vector-ref</h5>
<h5 id="s32vector-set">s32vector-set!</h5>
<h5 id="s32vector-list">s32vector-&gt;list</h5>
<h5 id="list-s32vector">list-&gt;s32vector</h5>
<h4 id="signed-64-bits-integer">Signed 64 bits integer</h4>
<h5 id="s64vector">s64vector?</h5>
<h5 id="make-s64vector">make-s64vector</h5>
<h5 id="s64vector-1">s64vector</h5>
<h5 id="s64vector-length">s64vector-length</h5>
<h5 id="s64vector-ref">s64vector-ref</h5>
<h5 id="s64vector-set">s64vector-set!</h5>
<h5 id="s64vector-list">s64vector-&gt;list</h5>
<h5 id="list-s64vector">list-&gt;s64vector</h5>
<h4 id="unsigned-8-bits-integer">Unsigned 8 bits integer</h4>
<h5 id="u8vector">u8vector?</h5>
<h5 id="make-u8vector">make-u8vector</h5>
<h5 id="u8vector-1">u8vector</h5>
<h5 id="u8vector-length">u8vector-length</h5>
<h5 id="u8vector-ref">u8vector-ref</h5>
<h5 id="u8vector-set">u8vector-set!</h5>
<h5 id="u8vector-list">u8vector-&gt;list</h5>
<h5 id="list-u8vector">list-&gt;u8vector</h5>
<h4 id="unsigned-16-bits-integer">Unsigned 16 bits integer</h4>
<h5 id="u16vector">u16vector?</h5>
<h5 id="make-u16vector">make-u16vector</h5>
<h5 id="u16vector-1">u16vector</h5>
<h5 id="u16vector-length">u16vector-length</h5>
<h5 id="u16vector-ref">u16vector-ref</h5>
<h5 id="u16vector-set">u16vector-set!</h5>
<h5 id="u16vector-list">u16vector-&gt;list</h5>
<h5 id="list-u16vector">list-&gt;u16vector</h5>
<h4 id="unsigned-32-bits-integer">Unsigned 32 bits integer</h4>
<h5 id="u32vector">u32vector?</h5>
<h5 id="make-u32vector">make-u32vector</h5>
<h5 id="u32vector-1">u32vector</h5>
<h5 id="u32vector-length">u32vector-length</h5>
<h5 id="u32vector-ref">u32vector-ref</h5>
<h5 id="u32vector-set">u32vector-set!</h5>
<h5 id="u32vector-list">u32vector-&gt;list</h5>
<h5 id="list-u32vector">list-&gt;u32vector</h5>
<h4 id="unsigned-64-bits-integer">Unsigned 64 bits integer</h4>
<h5 id="u64vector">u64vector?</h5>
<h5 id="make-u64vector">make-u64vector</h5>
<h5 id="u64vector-1">u64vector</h5>
<h5 id="u64vector-length">u64vector-length</h5>
<h5 id="u64vector-ref">u64vector-ref</h5>
<h5 id="u64vector-set">u64vector-set!</h5>
<h5 id="u64vector-list">u64vector-&gt;list</h5>
<h5 id="list-u64vector">list-&gt;u64vector</h5>
<h4 id="bits-float">32 bits float</h4>
<h5 id="f32vector">f32vector?</h5>
<h5 id="make-f32vector">make-f32vector</h5>
<h5 id="f32vector-1">f32vector</h5>
<h5 id="f32vector-length">f32vector-length</h5>
<h5 id="f32vector-ref">f32vector-ref</h5>
<h5 id="f32vector-set">f32vector-set!</h5>
<h5 id="f32vector-list">f32vector-&gt;list</h5>
<h5 id="list-f32vector">list-&gt;f32vector</h5>
<h4 id="bits-float-1">64 bits float</h4>
<h5 id="f64vector">f64vector?</h5>
<h5 id="make-f64vector">make-f64vector</h5>
<h5 id="f64vector-1">f64vector</h5>
<h5 id="f64vector-length">f64vector-length</h5>
<h5 id="f64vector-ref">f64vector-ref</h5>
<h5 id="f64vector-set">f64vector-set!</h5>
<h5 id="f64vector-list">f64vector-&gt;list</h5>
<h5 id="list-f64vector">list-&gt;f64vector</h5>
<h2 id="srfi-srfi-5"><code>(srfi srfi-5)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-5/">SRFI-5</a>.</p>
<h3 id="abstract-4">Abstract</h3>
<p>The named-<code>let</code> incarnation of the <code>let</code> form has two slight inconsistencies with the <code>define</code> form. As defined, the <code>let</code> form makes no accommodation for rest arguments, an issue of functionality and consistency. As defined, the let form does not accommodate signature-style syntax, an issue of aesthetics and consistency. Both issues are addressed here in a manner which is compatible with the traditional <code>let</code> form but for minor extensions.</p>
<h3 id="reference-4">Reference</h3>
<p>TODO</p>
<h2 id="srfi-srfi-6"><code>(srfi srfi-6)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-6/">SRFI-6</a>.</p>
<h3 id="abstract-5">Abstract</h3>
<p>Scheme's i/o primitives are extended by adding three new procedures that</p>
<ul>
<li><p>create an input port from a string,</p></li>
<li><p>create an output port whose contents are accumulated in Scheme's working memory instead of an external file, and</p></li>
<li><p>extract the accumulated contents of an in-memory output port and return them in the form of a string.</p></li>
</ul>
<h3 id="reference-5">Reference</h3>
<h4 id="open-input-string-string-1"><code>(open-input-string string)</code></h4>
<p>Takes a string and returns an input port that delivers characters from the string. The port can be closed by <code>close-input-port</code>, though its storage will be reclaimed by the garbage collector if it becomes inaccessible.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> p</span>
  (open-input-string <span class="st">&quot;(a . (b . (c . ()))) 34&quot;</span>))

(<span class="kw">input-port?</span> p) <span class="co">;; =&gt;  #t</span>
(<span class="kw">read</span> p) <span class="co">;; =&gt; (a b c)</span>
(<span class="kw">read</span> p) <span class="co">;; =&gt; 34</span>
(<span class="kw">eof-object?</span> (<span class="kw">peek-char</span> p)) <span class="co">;; =&gt; #t</span></code></pre></div>
<h4 id="open-output-string-1"><code>(open-output-string)</code></h4>
<p>Returns an output port that will accumulate characters for retrieval by <code>get-output-string</code>. The port can be closed by the procedure <code>close-output-port</code>, though its storage will be reclaimed by the garbage collector if it becomes inaccessible.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">let</span> ((q (open-output-string))
      (x &#39;(a b c)))
  (<span class="kw">write</span> (<span class="kw">car</span> x) q)
  (<span class="kw">write</span> (<span class="kw">cdr</span> x) q)
  (get-output-string q)) <span class="co">;; =&gt; &quot;a(b c)&quot;</span></code></pre></div>
<h4 id="get-output-string-output-port"><code>(get-output-string output-port)</code></h4>
<p>Given an output port created by <code>open-output-string</code>, returns a string consisting of the characters that have been output to the port so far.</p>
<h2 id="srfi-srfi-8"><code>(srfi srfi-8)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-8/">SRFI-8</a>.</p>
<h3 id="abstract-6">Abstract</h3>
<p>The only mechanism that R5RS provides for binding identifiers to the values of a multiple-valued expression is the primitive <code>call-with-values</code>. This SRFI proposes a more concise, more readable syntax for creating such bindings.</p>
<h3 id="reference-6">Reference</h3>
<h4 id="receive-formals-expression-body-syntax"><code>(receive &lt;formals&gt; &lt;expression&gt; &lt;body&gt;)</code> syntax</h4>
<h2 id="srfi-srfi-9"><code>(srfi srfi-9)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-9/">SRFI-9</a>.</p>
<h3 id="abstract-7">Abstract</h3>
<p>Syntax for creating new data types, called record types. A predicate, constructor, and field accessors and modifiers are defined for each record type. Each new record type is distinct from all existing types, including other record types and Scheme's predefined types.</p>
<h3 id="reference-7">Reference</h3>
<h4 id="define-record-type-...-syntax"><code>(define-record-type ...)</code> syntax</h4>
<p>The following:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">  (define-record-type &lt;pare&gt;
    (kons x y)
    pare?
    (x kar set-kar!)
    (y kdr))</code></pre></div>
<p>Defines <code>KONS</code> to be a constructor, <code>KAR</code> and <code>KDR</code> to be accessors, <code>SET-KAR!</code> to be a modifier, and <code>PARE?</code> to be a predicate for <code>&lt;PAREs&gt;</code>.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">  (pare? (kons <span class="dv">1</span> <span class="dv">2</span>))        --&gt; <span class="dv">#t</span>
  (pare? (<span class="kw">cons</span> <span class="dv">1</span> <span class="dv">2</span>))        --&gt; <span class="dv">#f</span>
  (kar (kons <span class="dv">1</span> <span class="dv">2</span>))          --&gt; <span class="dv">1</span>
  (kdr (kons <span class="dv">1</span> <span class="dv">2</span>))          --&gt; <span class="dv">2</span>
  (<span class="kw">let</span> ((k (kons <span class="dv">1</span> <span class="dv">2</span>)))
    (set-kar! k <span class="dv">3</span>)
    (kar k))                --&gt; <span class="dv">3</span></code></pre></div>
<h2 id="srfi-srfi-13"><code>(srfi srfi-13)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-13/">SRFI-13</a>.</p>
<h3 id="abstract-8">Abstract</h3>
<p>TODO</p>
<h3 id="reference-8">Reference</h3>
<h4 id="predicates-1">Predicates</h4>
<h5 id="string-4"><code>string?</code></h5>
<h5 id="string-null"><code>string-null?</code></h5>
<h5 id="string-every"><code>string-every</code></h5>
<h5 id="string-any"><code>string-any</code></h5>
<h4 id="constructors-1">Constructors</h4>
<h5 id="make-string"><code>make-string</code></h5>
<h5 id="string-5"><code>string</code></h5>
<h5 id="string-tabulate"><code>string-tabulate</code></h5>
<h4 id="list-string-conversion">List &amp; string conversion</h4>
<h5 id="string-list"><code>string-&gt;list</code></h5>
<h5 id="list-string"><code>list-&gt;string</code></h5>
<h5 id="reverse-list-string"><code>reverse-list-&gt;string</code></h5>
<h5 id="string-join"><code>string-join</code></h5>
<h4 id="selection">Selection</h4>
<h5 id="string-length"><code>string-length</code></h5>
<h5 id="string-ref"><code>string-ref</code></h5>
<h5 id="string-copy"><code>string-copy</code></h5>
<h5 id="substringshared"><code>substring/shared</code></h5>
<h5 id="string-copy-1"><code>string-copy!</code></h5>
<h5 id="string-take"><code>string-take</code></h5>
<h5 id="string-take-right"><code>string-take-right</code></h5>
<h5 id="string-drop"><code>string-drop</code></h5>
<h5 id="string-drop-right"><code>string-drop-right</code></h5>
<h5 id="string-pad"><code>string-pad</code></h5>
<h5 id="string-pad-right"><code>string-pad-right</code></h5>
<h5 id="string-trim"><code>string-trim</code></h5>
<h5 id="string-trim-right"><code>string-trim-right</code></h5>
<h5 id="string-trim-both"><code>string-trim-both</code></h5>
<h4 id="modification">Modification</h4>
<h5 id="string-set"><code>string-set!</code></h5>
<h5 id="string-fill"><code>string-fill!</code></h5>
<h4 id="comparison">Comparison</h4>
<h5 id="string-compare"><code>string-compare</code></h5>
<h5 id="string-compare-ci"><code>string-compare-ci</code></h5>
<h5 id="string-6"><code>string&lt;&gt;</code></h5>
<h5 id="string-7"><code>string=</code></h5>
<h5 id="string-8"><code>string&lt;</code></h5>
<h5 id="string-9"><code>string&gt;</code></h5>
<h5 id="string-10"><code>string&lt;=</code></h5>
<h5 id="string-11"><code>string&gt;=</code></h5>
<h5 id="string-ci"><code>string-ci&lt;&gt;</code></h5>
<h5 id="string-ci-1"><code>string-ci=</code></h5>
<h5 id="string-ci-2"><code>string-ci&lt;</code></h5>
<h5 id="string-ci-3"><code>string-ci&gt;</code></h5>
<h5 id="string-ci-4"><code>string-ci&lt;=</code></h5>
<h5 id="string-ci-5"><code>string-ci&gt;=</code></h5>
<h5 id="string-hash"><code>string-hash</code></h5>
<h5 id="string-hash-ci"><code>string-hash-ci</code></h5>
<h4 id="prefixes-suffixes">Prefixes &amp; suffixes</h4>
<h5 id="string-prefix-length"><code>string-prefix-length</code></h5>
<h5 id="string-suffix-length"><code>string-suffix-length</code></h5>
<h5 id="string-prefix-length-ci"><code>string-prefix-length-ci</code></h5>
<h5 id="string-suffix-length-ci"><code>string-suffix-length-ci</code></h5>
<h5 id="string-prefix"><code>string-prefix?</code></h5>
<h5 id="string-suffix"><code>string-suffix?</code></h5>
<h5 id="string-prefix-ci"><code>string-prefix-ci?</code></h5>
<h5 id="string-suffix-ci"><code>string-suffix-ci?</code></h5>
<h4 id="searching-1">Searching</h4>
<h5 id="string-index"><code>string-index</code></h5>
<h5 id="string-index-right"><code>string-index-right</code></h5>
<h5 id="string-skip"><code>string-skip</code></h5>
<h5 id="string-skip-right"><code>string-skip-right</code></h5>
<h5 id="string-count"><code>string-count</code></h5>
<h5 id="string-contains"><code>string-contains</code></h5>
<h5 id="string-contains-ci"><code>string-contains-ci</code></h5>
<h4 id="alphabetic-case-mapping">Alphabetic case mapping</h4>
<h5 id="string-titlecase"><code>string-titlecase</code></h5>
<h5 id="string-upcase"><code>string-upcase</code></h5>
<h5 id="string-downcase"><code>string-downcase</code></h5>
<h5 id="string-titlecase-1"><code>string-titlecase!</code></h5>
<h5 id="string-upcase-1"><code>string-upcase!</code></h5>
<h5 id="string-downcase-1"><code>string-downcase!</code></h5>
<h4 id="reverse-append">Reverse &amp; append</h4>
<h5 id="string-reverse"><code>string-reverse</code></h5>
<h5 id="string-reverse-1"><code>string-reverse!</code></h5>
<h5 id="string-append"><code>string-append</code></h5>
<h5 id="string-concatenate"><code>string-concatenate</code></h5>
<h5 id="string-concatenateshared"><code>string-concatenate/shared</code></h5>
<h5 id="string-appendshared"><code>string-append/shared</code></h5>
<h5 id="string-concatenate-reverse"><code>string-concatenate-reverse</code></h5>
<h5 id="string-concatenate-reverseshared"><code>string-concatenate-reverse/shared</code></h5>
<h4 id="fold-unfold-map-1">Fold, unfold &amp; map</h4>
<h5 id="string-map"><code>string-map</code></h5>
<h5 id="string-map-1"><code>string-map!</code></h5>
<h5 id="string-fold"><code>string-fold</code></h5>
<h5 id="string-fold-right"><code>string-fold-right</code></h5>
<h5 id="string-unfold"><code>string-unfold</code></h5>
<h5 id="string-unfold-right"><code>string-unfold-right</code></h5>
<h5 id="string-for-each"><code>string-for-each</code></h5>
<h5 id="string-for-each-index"><code>string-for-each-index</code></h5>
<h4 id="replicate-rotate">Replicate &amp; rotate</h4>
<h5 id="xsubstring"><code>xsubstring</code></h5>
<h5 id="string-xcopy"><code>string-xcopy!</code></h5>
<h4 id="miscellaneous-insertion-parsing">Miscellaneous: insertion, parsing</h4>
<h5 id="string-replace"><code>string-replace</code></h5>
<h5 id="string-tokenize"><code>string-tokenize</code></h5>
<h4 id="filtering-deleting">Filtering &amp; deleting</h4>
<h5 id="string-filter"><code>string-filter</code></h5>
<h5 id="string-delete"><code>string-delete</code></h5>
<h4 id="low-level-procedures">Low-level procedures</h4>
<h5 id="string-parse-startend"><code>string-parse-start+end</code></h5>
<h5 id="string-parse-final-startend"><code>string-parse-final-start+end</code></h5>
<h5 id="let-string-startend"><code>let-string-start+end</code></h5>
<h5 id="check-substring-spec"><code>check-substring-spec</code></h5>
<h5 id="substring-spec-ok"><code>substring-spec-ok?</code></h5>
<h5 id="make-kmp-restart-vector"><code>make-kmp-restart-vector</code></h5>
<h5 id="kmp-step"><code>kmp-step</code></h5>
<h5 id="string-kmp-partial-search"><code>string-kmp-partial-search</code></h5>
<h2 id="srfi-srfi-14"><code>(srfi srfi-14)</code></h2>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-14/">SRFI-14</a>.</p>
<h3 id="abstract-9">Abstract</h3>
<p>The ability to efficiently represent and manipulate sets of characters is an unglamorous but very useful capability for text-processing code -- one that tends to pop up in the definitions of other libraries.</p>
<h3 id="reference-9">Reference</h3>
<h4 id="char-set"><code>-&gt;char-set</code></h4>
<p>TODO</p>
<h4 id="char-set-1"><code>char-set</code></h4>
<p>TODO</p>
<h4 id="char-set-list"><code>char-set-&gt;list</code></h4>
<p>TODO</p>
<h4 id="char-set-string"><code>char-set-&gt;string</code></h4>
<p>TODO</p>
<h4 id="char-set-adjoin"><code>char-set-adjoin</code></h4>
<p>TODO</p>
<h4 id="char-set-adjoin-1"><code>char-set-adjoin!</code></h4>
<p>TODO</p>
<h4 id="char-set-any"><code>char-set-any</code></h4>
<p>TODO</p>
<h4 id="char-set-complement"><code>char-set-complement</code></h4>
<p>TODO</p>
<h4 id="char-set-complement-1"><code>char-set-complement!</code></h4>
<p>TODO</p>
<h4 id="char-set-contains"><code>char-set-contains?</code></h4>
<p>TODO</p>
<h4 id="char-set-copy"><code>char-set-copy</code></h4>
<p>TODO</p>
<h4 id="char-set-count"><code>char-set-count</code></h4>
<p>TODO</p>
<h4 id="char-set-cursor"><code>char-set-cursor</code></h4>
<p>TODO</p>
<h4 id="char-set-cursor-next"><code>char-set-cursor-next</code></h4>
<p>TODO</p>
<h4 id="char-set-delete"><code>char-set-delete</code></h4>
<p>TODO</p>
<h4 id="char-set-delete-1"><code>char-set-delete!</code></h4>
<p>TODO</p>
<h4 id="char-set-diffintersection"><code>char-set-diff+intersection</code></h4>
<p>TODO</p>
<h4 id="char-set-diffintersection-1"><code>char-set-diff+intersection!</code></h4>
<p>TODO</p>
<h4 id="char-set-difference"><code>char-set-difference</code></h4>
<p>TODO</p>
<h4 id="char-set-difference-1"><code>char-set-difference!</code></h4>
<p>TODO</p>
<h4 id="char-set-every"><code>char-set-every</code></h4>
<p>TODO</p>
<h4 id="char-set-filter"><code>char-set-filter</code></h4>
<p>TODO</p>
<h4 id="char-set-filter-1"><code>char-set-filter!</code></h4>
<p>TODO</p>
<h4 id="char-set-fold"><code>char-set-fold</code></h4>
<p>TODO</p>
<h4 id="char-set-for-each"><code>char-set-for-each</code></h4>
<p>TODO</p>
<h4 id="char-set-hash"><code>char-set-hash</code></h4>
<p>TODO</p>
<h4 id="char-set-intersection"><code>char-set-intersection</code></h4>
<p>TODO</p>
<h4 id="char-set-intersection-1"><code>char-set-intersection!</code></h4>
<p>TODO</p>
<h4 id="char-set-map"><code>char-set-map</code></h4>
<p>TODO</p>
<h4 id="char-set-ref"><code>char-set-ref</code></h4>
<p>TODO</p>
<h4 id="char-set-size"><code>char-set-size</code></h4>
<p>TODO</p>
<h4 id="char-set-unfold"><code>char-set-unfold</code></h4>
<p>TODO</p>
<h4 id="char-set-unfold-1"><code>char-set-unfold!</code></h4>
<p>TODO</p>
<h4 id="char-set-union"><code>char-set-union</code></h4>
<p>TODO</p>
<h4 id="char-set-union-1"><code>char-set-union!</code></h4>
<p>TODO</p>
<h4 id="char-set-xor"><code>char-set-xor</code></h4>
<p>TODO</p>
<h4 id="char-set-xor-1"><code>char-set-xor!</code></h4>
<p>TODO</p>
<h4 id="char-setascii"><code>char-set:ascii</code></h4>
<p>TODO</p>
<h4 id="char-setblank"><code>char-set:blank</code></h4>
<p>TODO</p>
<h4 id="char-setdigit"><code>char-set:digit</code></h4>
<p>TODO</p>
<h4 id="char-setempty"><code>char-set:empty</code></h4>
<p>TODO</p>
<h4 id="char-setfull"><code>char-set:full</code></h4>
<p>TODO</p>
<h4 id="char-setgraphic"><code>char-set:graphic</code></h4>
<p>TODO</p>
<h4 id="char-sethex-digit"><code>char-set:hex-digit</code></h4>
<p>TODO</p>
<h4 id="char-setiso-control"><code>char-set:iso-control</code></h4>
<p>TODO</p>
<h4 id="char-setletter"><code>char-set:letter</code></h4>
<p>TODO</p>
<h4 id="char-setletterdigit"><code>char-set:letter+digit</code></h4>
<p>TODO</p>
<h4 id="char-setlower-case"><code>char-set:lower-case</code></h4>
<p>TODO</p>
<h4 id="char-setprinting"><code>char-set:printing</code></h4>
<p>TODO</p>
<h4 id="char-setpunctuation"><code>char-set:punctuation</code></h4>
<p>TODO</p>
<h4 id="char-setsymbol"><code>char-set:symbol</code></h4>
<p>TODO</p>
<h4 id="char-settitle-case"><code>char-set:title-case</code></h4>
<p>TODO</p>
<h4 id="char-setupper-case"><code>char-set:upper-case</code></h4>
<p>TODO</p>
<h4 id="char-setwhitespace"><code>char-set:whitespace</code></h4>
<p>TODO</p>
<h4 id="char-set-2"><code>char-set&lt;=</code></h4>
<p>TODO</p>
<h4 id="char-set-3"><code>char-set=</code></h4>
<p>TODO</p>
<h4 id="char-set-4"><code>char-set?</code></h4>
<p>TODO</p>
<h4 id="end-of-char-set"><code>end-of-char-set?</code></h4>
<p>TODO</p>
<h4 id="list-char-set"><code>list-&gt;char-set</code></h4>
<p>TODO</p>
<h4 id="list-char-set-1"><code>list-&gt;char-set!</code></h4>
<p>TODO</p>
<h4 id="string-char-set"><code>string-&gt;char-set</code></h4>
<p>TODO</p>
<h4 id="string-char-set-1"><code>string-&gt;char-set!</code></h4>
<p>TODO</p>
<h4 id="ucs-range-char-set"><code>ucs-range-&gt;char-set</code></h4>
<p>TODO</p>
<h4 id="ucs-range-char-set-1"><code>ucs-range-&gt;char-set!</code></h4>
<p>TODO</p>
<h2 id="srfi-srfi-16"><code>(srfi srfi-16)</code></h2>
<h3 id="case-lambda-clause1-clause2-...-syntax"><code>(case-lambda clause1 clause2 ...)</code> syntax</h3>
<p>Each clause is of the form <code>(formals body)</code>, where <code>formals</code> and <code>body</code> have the same syntax as in a lambda expression.</p>
<p>A case-lambda expression evaluates to a procedure that accepts a variable number of arguments and is lexically scoped in the same manner as a procedure resulting from a lambda expression. When the procedure is called, the first clause for which the arguments agree with <code>formals</code> is selected, where agreement is specified as for the <code>formals</code> of a lambda expression. The variables of <code>formals</code> are bound to fresh locations, the values of the arguments are stored in those locations, the <code>body</code> is evaluated in the extended environment, and the results of <code>body</code> are returned as the results of the procedure call.</p>
<p>It is an error for the arguments not to agree with the <code>formals</code> of any clause`.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> add1</span>
  (case-lambda
    ((a) (add1 a <span class="dv">0</span>))
    ((a b) (<span class="kw">+</span> <span class="dv">1</span> a b))))

(add1 <span class="dv">1</span>) <span class="co">;; =&gt; 2</span>
(add1 <span class="dv">1</span> <span class="dv">2</span>) <span class="co">;; =&gt; 4</span></code></pre></div>
<h2 id="srfi-srfi-17"><code>(srfi srfi-17)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-17/">SRFI-17</a>.</p>
<h3 id="abstract-10">Abstract</h3>
<p>Allow procedure calls that evaluate to the &quot;value of a location&quot; to be used to set the value of the location, when used as the first operand of <code>set!</code>. For example:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(set! (<span class="kw">car</span> x) (<span class="kw">car</span> y))</code></pre></div>
<p>becomes equivalent to</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">set-car!</span> x (<span class="kw">car</span> y))</code></pre></div>
<h3 id="reference-10">Reference</h3>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(set! (<span class="kw">car</span> x) v) == (<span class="kw">set-car!</span> x v)
(set! (<span class="kw">cdr</span> x) v) == (<span class="kw">set-cdr!</span> x v)
(set! (<span class="kw">caar</span> x) v) == (<span class="kw">set-car!</span> (<span class="kw">car</span> x) v)
(set! (<span class="kw">cadr</span> x) v) == (<span class="kw">set-car!</span> (<span class="kw">cdr</span> x) v)
....
(set! (caXXr x) v) == (<span class="kw">set-car!</span> (cXXr x) v)
(set! (cdXXr x) v) == (<span class="kw">set-cdr!</span> (cXXr x) v)
(set! (<span class="kw">string-ref</span> x i) v) == (<span class="kw">string-set!</span> x i v)
(set! (<span class="kw">vector-ref</span> x i) v) == (<span class="kw">vector-set!</span> x i v)</code></pre></div>
<h2 id="srfi-srfi-19"><code>(srfi srfi-19)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-19/">SRFI-19</a>.</p>
<h3 id="abstract-11">Abstract</h3>
<p>TODO</p>
<h3 id="reference-11">Reference</h3>
<h4 id="time-duration"><code>time-duration</code></h4>
<h4 id="time-monotonic"><code>time-monotonic</code></h4>
<h4 id="time-process"><code>time-process</code></h4>
<h4 id="time-tai"><code>time-tai</code></h4>
<h4 id="time-thread"><code>time-thread</code></h4>
<h4 id="time-utc"><code>time-utc</code></h4>
<h4 id="current-date"><code>current-date</code></h4>
<h4 id="current-julian-day"><code>current-julian-day</code></h4>
<h4 id="current-modified-julian-day"><code>current-modified-julian-day</code></h4>
<h4 id="current-time"><code>current-time</code></h4>
<h4 id="time-resolution"><code>time-resolution</code></h4>
<h4 id="make-time"><code>make-time</code></h4>
<h4 id="time"><code>time?</code></h4>
<h4 id="time-type"><code>time-type</code></h4>
<h4 id="time-nanosecond"><code>time-nanosecond</code></h4>
<h4 id="time-second"><code>time-second</code></h4>
<h4 id="set-time-type"><code>set-time-type!</code></h4>
<h4 id="set-time-nanosecond"><code>set-time-nanosecond!</code></h4>
<h4 id="set-time-second"><code>set-time-second!</code></h4>
<h4 id="copy-time"><code>copy-time</code></h4>
<h4 id="time-1"><code>time&lt;=?</code></h4>
<h4 id="time-2"><code>time&lt;?</code></h4>
<h4 id="time-3"><code>time=?</code></h4>
<h4 id="time-4"><code>time&gt;=?</code></h4>
<h4 id="time-5"><code>time&gt;?</code></h4>
<h4 id="time-difference"><code>time-difference</code></h4>
<h4 id="time-difference-1"><code>time-difference!</code></h4>
<h4 id="add-duration"><code>add-duration</code></h4>
<h4 id="add-duration-1"><code>add-duration!</code></h4>
<h4 id="subtract-duration"><code>subtract-duration</code></h4>
<h4 id="subtract-duration-1"><code>subtract-duration!</code></h4>
<h4 id="make-date"><code>make-date</code></h4>
<h4 id="date"><code>date?</code></h4>
<h4 id="date-nanosecond"><code>date-nanosecond</code></h4>
<h4 id="date-second"><code>date-second</code></h4>
<h4 id="date-minute"><code>date-minute</code></h4>
<h4 id="date-hour"><code>date-hour</code></h4>
<h4 id="date-day"><code>date-day</code></h4>
<h4 id="date-month"><code>date-month</code></h4>
<h4 id="date-year"><code>date-year</code></h4>
<h4 id="date-zone-offset"><code>date-zone-offset</code></h4>
<h4 id="date-year-day"><code>date-year-day</code></h4>
<h4 id="date-week-day"><code>date-week-day</code></h4>
<h4 id="date-week-number"><code>date-week-number</code></h4>
<h4 id="date-julian-day"><code>date-&gt;julian-day</code></h4>
<h4 id="date-modified-julian-day"><code>date-&gt;modified-julian-day</code></h4>
<h4 id="date-time-monotonic"><code>date-&gt;time-monotonic</code></h4>
<h4 id="date-time-tai"><code>date-&gt;time-tai</code></h4>
<h4 id="date-time-utc"><code>date-&gt;time-utc</code></h4>
<h4 id="julian-day-date"><code>julian-day-&gt;date</code></h4>
<h4 id="julian-day-time-monotonic"><code>julian-day-&gt;time-monotonic</code></h4>
<h4 id="julian-day-time-tai"><code>julian-day-&gt;time-tai</code></h4>
<h4 id="julian-day-time-utc"><code>julian-day-&gt;time-utc</code></h4>
<h4 id="modified-julian-day-date"><code>modified-julian-day-&gt;date</code></h4>
<h4 id="modified-julian-day-time-monotonic"><code>modified-julian-day-&gt;time-monotonic</code></h4>
<h4 id="modified-julian-day-time-tai"><code>modified-julian-day-&gt;time-tai</code></h4>
<h4 id="modified-julian-day-time-utc"><code>modified-julian-day-&gt;time-utc</code></h4>
<h4 id="time-monotonic-date"><code>time-monotonic-&gt;date</code></h4>
<h4 id="time-monotonic-julian-day"><code>time-monotonic-&gt;julian-day</code></h4>
<h4 id="time-monotonic-modified-julian-day"><code>time-monotonic-&gt;modified-julian-day</code></h4>
<h4 id="time-monotonic-time-tai"><code>time-monotonic-&gt;time-tai</code></h4>
<h4 id="time-monotonic-time-tai-1"><code>time-monotonic-&gt;time-tai!</code></h4>
<h4 id="time-monotonic-time-utc"><code>time-monotonic-&gt;time-utc</code></h4>
<h4 id="time-monotonic-time-utc-1"><code>time-monotonic-&gt;time-utc!</code></h4>
<h4 id="time-tai-date"><code>time-tai-&gt;date</code></h4>
<h4 id="time-tai-julian-day"><code>time-tai-&gt;julian-day</code></h4>
<h4 id="time-tai-modified-julian-day"><code>time-tai-&gt;modified-julian-day</code></h4>
<h4 id="time-tai-time-monotonic"><code>time-tai-&gt;time-monotonic</code></h4>
<h4 id="time-tai-time-monotonic-1"><code>time-tai-&gt;time-monotonic!</code></h4>
<h4 id="time-tai-time-utc"><code>time-tai-&gt;time-utc</code></h4>
<h4 id="time-tai-time-utc-1"><code>time-tai-&gt;time-utc!</code></h4>
<h4 id="time-utc-date"><code>time-utc-&gt;date</code></h4>
<h4 id="time-utc-julian-day"><code>time-utc-&gt;julian-day</code></h4>
<h4 id="time-utc-modified-julian-day"><code>time-utc-&gt;modified-julian-day</code></h4>
<h4 id="time-utc-time-monotonic"><code>time-utc-&gt;time-monotonic</code></h4>
<h4 id="time-utc-time-monotonic-1"><code>time-utc-&gt;time-monotonic!</code></h4>
<h4 id="time-utc-time-tai"><code>time-utc-&gt;time-tai</code></h4>
<h4 id="time-utc-time-tai-1"><code>time-utc-&gt;time-tai!</code></h4>
<h4 id="date-string"><code>date-&gt;string</code></h4>
<h4 id="string-date"><code>string-&gt;date</code></h4>
<h2 id="srfi-srfi-23"><code>(srfi srfi-23)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-23/">SRFI-23</a>.</p>
<h3 id="abstract-12">Abstract</h3>
<p>A mechanism is proposed to allow Scheme code to report errors and abort execution. The proposed mechanism is already implemented in several Scheme systems and can be implemented, albeit imperfectly, in any R5RS conforming Scheme.</p>
<h3 id="reference-12">Reference</h3>
<h4 id="error-reason-arg-..."><code>(error &lt;reason&gt; [arg ...])</code></h4>
<h2 id="srfi-srfi-25"><code>(srfi srfi-25)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-25/">SRFI-25</a>.</p>
<h3 id="abstract-13">Abstract</h3>
<p>A core set of procedures for creating and manipulating heterogeneous multidimensional arrays is proposed. The design is consistent with the rest of Scheme and independent of other container data types. It provides easy sharing of parts of an array as other arrays without copying, encouraging a declarative style of programming.</p>
<h3 id="reference-13">Reference</h3>
<p>TODO</p>
<h2 id="srfi-srfi-26"><code>(srfi srfi-26)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-26/">SRFI-26</a>.</p>
<h3 id="abstract-14">Abstract</h3>
<p>When programming in functional style, it is frequently necessary to specialize some of the parameters of a multi-parameter procedure. For example, from the binary operation cons one might want to obtain the unary operation (lambda (x) (cons 1 x)). This specialization of parameters is also known as &quot;partial application&quot;, &quot;operator section&quot; or &quot;projection&quot;.</p>
<h3 id="reference-14">Reference</h3>
<h4 id="cut-...-syntax"><code>(cut ...)</code> syntax</h4>
<h4 id="cute-...-syntax"><code>(cute ...)</code> syntax</h4>
<h2 id="srfi-srfi-28"><code>(srfi srfi-28)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-28/">SRFI-28</a>.</p>
<h3 id="abstract-15">Abstract</h3>
<p>A method of interpreting a Scheme string which contains a number of escape sequences that are replaced with other string data according to the semantics of each sequence. Also called string interpolation.</p>
<h3 id="reference-15">Reference</h3>
<h4 id="format-format-string-obj-..."><code>(format format-string [obj ...])</code></h4>
<p>Accepts a message template (a Scheme string), and processes it, replacing any escape sequences in order with one or more characters, the characters themselves dependent on the semantics of the escape sequence encountered.</p>
<p>An escape sequence is a two character sequence in the string where the first character is a tilde '~'. Each escape code's meaning is as follows:</p>
<ul>
<li><p><code>~a</code> The corresponding value is inserted into the string as if printed with display.</p></li>
<li><p><code>~s</code> The corresponding value is inserted into the string as if printed with write.</p></li>
<li><p><code>~%</code> A newline is inserted.</p></li>
<li><p><code>~~</code> A tilde <code>~</code> is inserted.</p></li>
</ul>
<p><code>~a</code> and <code>~s</code>, when encountered, require a corresponding Scheme value to be present after the format string. The values provided as operands are used by the escape sequences in order. It is an error if fewer values are provided than escape sequences that require them.</p>
<p><code>~%</code> and <code>~~</code> require no corresponding value.</p>
<p><strong>Examples:</strong></p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(format <span class="st">&quot;Hello, ~a&quot;</span> <span class="st">&quot;World!&quot;</span>)
<span class="co">;; =&gt; &quot;Hello, World!&quot;</span>

(format <span class="st">&quot;Error, list is too short: ~s~%&quot;</span> &#39;(one <span class="st">&quot;two&quot;</span> <span class="dv">3</span>))
<span class="co">;; =&gt; &quot;Error, list is too short: (one \&quot;two\&quot; 3))&quot;</span></code></pre></div>
<h2 id="srfi-srfi-29"><code>(srfi srfi-29)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-29/">SRFI-29</a>.</p>
<h3 id="abstract-16">Abstract</h3>
<p>An interface to retrieving and displaying locale sensitive messages. A Scheme program can register one or more translations of templated messages, and then write Scheme code that can transparently retrieve the appropriate message for the locale under which the Scheme system is running.</p>
<h3 id="reference-16">Reference</h3>
<h4 id="current-language"><code>current-language</code></h4>
<h4 id="current-country"><code>current-country</code></h4>
<h4 id="current-locale-details"><code>current-locale-details</code></h4>
<h4 id="declare-bundle"><code>declare-bundle!</code></h4>
<h4 id="store-bundle"><code>store-bundle</code></h4>
<h4 id="store-bundle-1"><code>store-bundle!</code></h4>
<h4 id="load-bundle"><code>load-bundle!</code></h4>
<h4 id="localized-template"><code>localized-template</code></h4>
<h2 id="srfi-srfi-31"><code>(srfi srfi-31)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-31/">SRFI-31</a>.</p>
<h3 id="abstract-17">Abstract</h3>
<p>TODO</p>
<h3 id="reference-17">Reference</h3>
<p>TODO</p>
<h2 id="srfi-srfi-34"><code>(srfi srfi-34)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-34/">SRFI-34</a>.</p>
<h3 id="abstract-18">Abstract</h3>
<p>TODO</p>
<h3 id="reference-18">Reference</h3>
<h4 id="with-exception-handler-1"><code>with-exception-handler</code></h4>
<h4 id="guard"><code>guard</code></h4>
<h4 id="raise"><code>raise</code></h4>
<h2 id="srfi-srfi-35"><code>(srfi srfi-35)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-35/">SRFI-35</a>.</p>
<h3 id="abstract-19">Abstract</h3>
<p>Defines constructs for creating and inspecting condition types and values. A condition value encapsulates information about an exceptional situation, or exception. This SRFI also defines a few basic condition types.</p>
<h3 id="reference-19">Reference</h3>
<h4 id="make-condition-type"><code>make-condition-type</code></h4>
<h4 id="condition-type"><code>condition-type?</code></h4>
<h4 id="condition-has-type"><code>condition-has-type?</code></h4>
<h4 id="condition-ref"><code>condition-ref</code></h4>
<h4 id="make-compound-condition"><code>make-compound-condition</code></h4>
<h4 id="extract-condition"><code>extract-condition</code></h4>
<h4 id="define-condition-type"><code>define-condition-type</code></h4>
<h4 id="condition"><code>&amp;condition</code></h4>
<h4 id="make-condition"><code>make-condition</code></h4>
<h4 id="condition-1"><code>condition?</code></h4>
<h4 id="condition-2"><code>condition</code></h4>
<h4 id="serious"><code>&amp;serious</code></h4>
<h4 id="serious-condition"><code>serious-condition?</code></h4>
<h4 id="error"><code>&amp;error</code></h4>
<h4 id="error-1"><code>error?</code></h4>
<h4 id="message"><code>&amp;message</code></h4>
<h4 id="message-condition"><code>message-condition?</code></h4>
<h4 id="condition-message"><code>condition-message</code></h4>
<h2 id="srfi-srfi-37"><code>(srfi srfi-37)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-37/">SRFI-37</a>.</p>
<h3 id="abstract-20">Abstract</h3>
<p>Many operating systems make the set of argument strings used to invoke a program available (often following the program name string in an array called argv). Most programs need to parse and process these argument strings in one way or another. This SRFI describes a set of procedures that support processing program arguments according to POSIX and GNU C Library Reference Manual guidelines.</p>
<h3 id="reference-20">Reference</h3>
<h4 id="args-fold"><code>args-fold</code></h4>
<h4 id="option"><code>option</code></h4>
<h4 id="option-1"><code>option?</code></h4>
<h4 id="option-names"><code>option-names</code></h4>
<h4 id="option-required-arg"><code>option-required-arg?</code></h4>
<h4 id="option-optional-arg"><code>option-optional-arg?</code></h4>
<h4 id="option-processor"><code>option-processor</code></h4>
<h2 id="srfi-srfi-38"><code>(srfi srfi-38)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-38/">SRFI-38</a>.</p>
<h3 id="abstract-21">Abstract</h3>
<p>TODO</p>
<h3 id="reference-21">Reference</h3>
<h4 id="write-with-shared-structure-obj-port-optarg"><code>(write-with-shared-structure obj [port [optarg]])</code></h4>
<h4 id="read-with-shared-structure-port"><code>(read-with-shared-structure [port])</code></h4>
<h2 id="srfi-srfi-39"><code>(srfi srfi-39)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-39/">SRFI-39</a>.</p>
<h3 id="abstract-22">Abstract</h3>
<p>This SRFI defines parameter objects, the procedure make-parameter to create parameter objects and the parameterize special form to dynamically bind parameter objects. In the dynamic environment, each parameter object is bound to a cell containing the value of the parameter. When a procedure is called the called procedure inherits the dynamic environment from the caller. The parameterize special form allows the binding of a parameter object to be changed for the dynamic extent of its body.</p>
<h3 id="reference-22">Reference</h3>
<h4 id="make-parameter"><code>make-parameter</code></h4>
<h4 id="parameterize"><code>parameterize</code></h4>
<h2 id="srfi-srfi-41"><code>(srfi srfi-41)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-41/">SRFI-41</a>.</p>
<h3 id="abstract-23">Abstract</h3>
<p>Streams, sometimes called lazy lists, are a sequential data structure containing elements computed only on demand. A stream is either null or is a pair with a stream in its cdr. Since elements of a stream are computed only when accessed, streams can be infinite. Once computed, the value of a stream element is cached in case it is needed again.</p>
<h3 id="reference-23">Reference</h3>
<h5 id="stream-null"><code>stream-null</code></h5>
<h5 id="stream-cons"><code>stream-cons</code></h5>
<h5 id="stream"><code>stream?</code></h5>
<h5 id="stream-null-1"><code>stream-null?</code></h5>
<h5 id="stream-pair"><code>stream-pair?</code></h5>
<h5 id="stream-car"><code>stream-car</code></h5>
<h5 id="stream-cdr"><code>stream-cdr</code></h5>
<h5 id="stream-lambda"><code>stream-lambda</code></h5>
<h5 id="define-stream"><code>define-stream</code></h5>
<h5 id="list-stream"><code>list-&gt;stream</code></h5>
<h5 id="port-stream"><code>port-&gt;stream</code></h5>
<h5 id="stream-1"><code>stream</code></h5>
<h5 id="stream-list"><code>stream-&gt;list</code></h5>
<h5 id="stream-append"><code>stream-append</code></h5>
<h5 id="stream-concat"><code>stream-concat</code></h5>
<h5 id="stream-constant"><code>stream-constant</code></h5>
<h5 id="stream-drop"><code>stream-drop</code></h5>
<h5 id="stream-drop-while"><code>stream-drop-while</code></h5>
<h5 id="stream-filter"><code>stream-filter</code></h5>
<h5 id="stream-fold"><code>stream-fold</code></h5>
<h5 id="stream-for-each"><code>stream-for-each</code></h5>
<h5 id="stream-from"><code>stream-from</code></h5>
<h5 id="stream-iterate"><code>stream-iterate</code></h5>
<h5 id="stream-length"><code>stream-length</code></h5>
<h5 id="stream-let"><code>stream-let</code></h5>
<h5 id="stream-map"><code>stream-map</code></h5>
<h5 id="stream-match"><code>stream-match</code></h5>
<h5 id="stream-of"><code>stream-of</code></h5>
<h5 id="stream-range"><code>stream-range</code></h5>
<h5 id="stream-ref"><code>stream-ref</code></h5>
<h5 id="stream-reverse"><code>stream-reverse</code></h5>
<h5 id="stream-scan"><code>stream-scan</code></h5>
<h5 id="stream-take"><code>stream-take</code></h5>
<h5 id="stream-take-while"><code>stream-take-while</code></h5>
<h5 id="stream-unfold"><code>stream-unfold</code></h5>
<h5 id="stream-unfolds"><code>stream-unfolds</code></h5>
<h5 id="stream-zip"><code>stream-zip</code></h5>
<h2 id="srfi-srfi-42"><code>(srfi srfi-42)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-42/">SRFI-42</a>.</p>
<h3 id="abstract-24">Abstract</h3>
<p>TODO</p>
<h3 id="reference-24">Reference</h3>
<h4 id="do-ec"><code>do-ec</code></h4>
<h4 id="list-ec"><code>list-ec</code></h4>
<h4 id="append-ec"><code>append-ec</code></h4>
<h4 id="string-ec"><code>string-ec</code></h4>
<h4 id="string-append-ec"><code>string-append-ec</code></h4>
<h4 id="vector-ec"><code>vector-ec</code></h4>
<h4 id="vector-of-length-ec"><code>vector-of-length-ec</code></h4>
<h4 id="sum-ec"><code>sum-ec</code></h4>
<h4 id="product-ec"><code>product-ec</code></h4>
<h4 id="min-ec"><code>min-ec</code></h4>
<h4 id="max-ec"><code>max-ec</code></h4>
<h4 id="any-ec"><code>any?-ec</code></h4>
<h4 id="every-ec"><code>every?-ec</code></h4>
<h4 id="first-ec"><code>first-ec</code></h4>
<h4 id="last-ec"><code>last-ec</code></h4>
<h4 id="fold-ec"><code>fold-ec</code></h4>
<h4 id="fold3-ec"><code>fold3-ec</code></h4>
<h4 id="section-3"><code>:</code></h4>
<h4 id="list"><code>:list</code></h4>
<h4 id="string-12"><code>:string</code></h4>
<h4 id="vector"><code>:vector</code></h4>
<h4 id="integers"><code>:integers</code></h4>
<h4 id="range"><code>:range</code></h4>
<h4 id="real-range"><code>:real-range</code></h4>
<h4 id="char-range"><code>:char-range</code></h4>
<h4 id="port"><code>:port</code></h4>
<h4 id="dispatched"><code>:dispatched</code></h4>
<h4 id="do-1"><code>:do</code></h4>
<h4 id="let"><code>:let</code></h4>
<h4 id="parallel"><code>:parallel</code></h4>
<h4 id="while"><code>:while</code></h4>
<h4 id="until"><code>:until</code></h4>
<h4 id="dispatch-ref"><code>:-dispatch-ref</code></h4>
<h4 id="dispatch-set"><code>:-dispatch-set!</code></h4>
<h4 id="make-initial--dispatch"><code>make-initial-:-dispatch</code></h4>
<h4 id="dispatch-union"><code>dispatch-union</code></h4>
<h4 id="generator-proc"><code>:generator-proc</code></h4>
<h2 id="srfi-srfi-43"><code>(srfi srfi-43)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-43/">SRFI-43</a>.</p>
<h3 id="abstract-25">Abstract</h3>
<p>TODO</p>
<h3 id="reference-25">Reference</h3>
<p>TODO</p>
<h2 id="srfi-srfi-45"><code>(srfi srfi-45)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-45/">SRFI-45</a>.</p>
<h3 id="abstract-26">Abstract</h3>
<p>TODO</p>
<h3 id="reference-26">Reference</h3>
<h4 id="delay"><code>delay</code></h4>
<h4 id="lazy"><code>lazy</code></h4>
<h4 id="force"><code>force</code></h4>
<h4 id="eager"><code>eager</code></h4>
<h2 id="srfi-srfi-48"><code>(srfi srfi-48)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-48/">SRFI-48</a>.</p>
<h3 id="abstract-27">Abstract</h3>
<p>TODO</p>
<h3 id="reference-27">Reference</h3>
<p>TODO</p>
<h2 id="srfi-srfi-51"><code>(srfi srfi-51)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-51/">SRFI-51</a>.</p>
<h3 id="abstract-28">Abstract</h3>
<p>TODO</p>
<h3 id="reference-28">Reference</h3>
<p>TODO</p>
<h2 id="srfi-srfi-54"><code>(srfi srfi-54)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-54/">SRFI-54</a>.</p>
<h3 id="abstract-29">Abstract</h3>
<p>TODO</p>
<h3 id="reference-29">Reference</h3>
<p>TODO</p>
<h2 id="srfi-srfi-60"><code>(srfi srfi-60)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-60/">SRFI-60</a>.</p>
<h3 id="abstract-30">Abstract</h3>
<p>TODO</p>
<h3 id="reference-30">Reference</h3>
<h4 id="logand">logand</h4>
<h4 id="bitwise-and">bitwise-and</h4>
<h4 id="logior">logior</h4>
<h4 id="bitwise-ior">bitwise-ior</h4>
<h4 id="logxor">logxor</h4>
<h4 id="bitwise-xor">bitwise-xor</h4>
<h4 id="lognot">lognot</h4>
<h4 id="bitwise-not">bitwise-not</h4>
<h4 id="bitwise-if">bitwise-if</h4>
<h4 id="bitwise-merge">bitwise-merge</h4>
<h4 id="logtest">logtest</h4>
<h4 id="any-bits-set">any-bits-set?</h4>
<h4 id="logcount">logcount</h4>
<h4 id="bit-count">bit-count</h4>
<h4 id="integer-length">integer-length</h4>
<h4 id="log2-binary-factors">log2-binary-factors</h4>
<h4 id="first-set-bit">first-set-bit</h4>
<h4 id="logbit">logbit?</h4>
<h4 id="bit-set">bit-set?</h4>
<h4 id="copy-bit">copy-bit</h4>
<h4 id="bit-field">bit-field</h4>
<h4 id="copy-bit-field">copy-bit-field</h4>
<h4 id="ash">ash</h4>
<h4 id="arithmetic-shift">arithmetic-shift</h4>
<h4 id="rotate-bit-field">rotate-bit-field</h4>
<h4 id="reverse-bit-field">reverse-bit-field</h4>
<h4 id="integer-list">integer-&gt;list</h4>
<h4 id="integer-list-1">integer-&gt;list</h4>
<h4 id="list-integer">list-&gt;integer</h4>
<h4 id="booleans-integer">booleans-&gt;integer</h4>
<h2 id="srfi-srfi-61"><code>(srfi srfi-61)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-61/">SRFI-61</a>.</p>
<h3 id="abstract-31">Abstract</h3>
<p>TODO</p>
<h3 id="reference-31">Reference</h3>
<p>TODO</p>
<h2 id="srfi-srfi-67"><code>(srfi srfi-67)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-67/">SRFI-67</a>.</p>
<h3 id="abstract-32">Abstract</h3>
<p>TODO</p>
<h3 id="reference-32">Reference</h3>
<p>TODO</p>
<h2 id="srfi-srfi-69"><code>(srfi srfi-69)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-69/">SRFI-69</a>.</p>
<h3 id="abstract-33">Abstract</h3>
<p>TODO</p>
<h3 id="reference-33">Reference</h3>
<p>TODO</p>
<h2 id="srfi-srfi-98"><code>(srfi srfi-98)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-98/">SRFI-98</a>.</p>
<h3 id="abstract-34">Abstract</h3>
<p>TODO</p>
<h3 id="reference-34">Reference</h3>
<p>TODO</p>
<h2 id="srfi-srfi-99"><code>(srfi srfi-99)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-99/">SRFI-99</a>.</p>
<h3 id="abstract-35">Abstract</h3>
<p>TODO</p>
<h3 id="reference-35">Reference</h3>
<p>TODO</p>
<h2 id="srfi-srfi-101"><code>(srfi srfi-101)</code></h2>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-101/">SRFI-101</a>.</p>
<h3 id="abstract-36">Abstract</h3>
<p>TODO</p>
<h3 id="reference-36">Reference</h3>
<p>TODO</p>
<h2 id="srfi-srfi-111"><code>(srfi srfi-111)</code></h2>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-111/">SRFI-111</a>.</p>
<h3 id="abstract-37">Abstract</h3>
<p>Boxes are objects with a single mutable state. Several Schemes have them, sometimes called cells. A constructor, predicate, accessor, and mutator are provided.</p>
<h3 id="reference-37">Reference</h3>
<h4 id="box-value"><code>(box value)</code></h4>
<p>Constructor. Returns a newly allocated box initialized to value.</p>
<h4 id="box-object"><code>(box? object)</code></h4>
<p>Predicate. Returns <code>#t</code> if object is a box, and <code>#f</code> otherwise.</p>
<h4 id="unbox-box"><code>(unbox box)</code></h4>
<p>Accessor. Returns the current value of box.</p>
<h4 id="set-box-box-value"><code>(set-box! box value)</code></h4>
<p>Mutator. Changes box to hold value.</p>
<h2 id="srfi-srfi-113"><code>(srfi srfi-113)</code></h2>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-113/">SRFI-113</a>.</p>
<h3 id="abstract-38">Abstract</h3>
<p>Sets and bags (also known as multisets) are unordered collections that can contain any Scheme object. Sets enforce the constraint that no two elements can be the same in the sense of the set's associated equality predicate; bags do not.</p>
<h3 id="reference-38">Reference</h3>
<p>TODO</p>
<h4 id="set">Set</h4>
<h5 id="set-1">set</h5>
<h5 id="set-unfold">set-unfold</h5>
<h5 id="set-2">set?</h5>
<h5 id="set-contains">set-contains?</h5>
<h5 id="set-empty">set-empty?</h5>
<h5 id="set-disjoint">set-disjoint?</h5>
<h5 id="set-member">set-member</h5>
<h5 id="set-element-comparator">set-element-comparator</h5>
<h5 id="set-adjoin">set-adjoin</h5>
<h5 id="set-adjoin-1">set-adjoin!</h5>
<h5 id="set-replace">set-replace</h5>
<h5 id="set-replace-1">set-replace!</h5>
<h5 id="set-delete">set-delete</h5>
<h5 id="set-delete-1">set-delete!</h5>
<h5 id="set-delete-all">set-delete-all</h5>
<h5 id="set-delete-all-1">set-delete-all!</h5>
<h5 id="set-search">set-search!</h5>
<h5 id="set-size">set-size</h5>
<h5 id="set-find">set-find</h5>
<h5 id="set-count">set-count</h5>
<h5 id="set-any">set-any?</h5>
<h5 id="set-every">set-every?</h5>
<h5 id="set-map">set-map</h5>
<h5 id="set-for-each">set-for-each</h5>
<h5 id="set-fold">set-fold</h5>
<h5 id="set-filter">set-filter</h5>
<h5 id="set-remove">set-remove</h5>
<h5 id="set-remove-1">set-remove</h5>
<h5 id="set-partition">set-partition</h5>
<h5 id="set-filter-1">set-filter!</h5>
<h5 id="set-remove-2">set-remove!</h5>
<h5 id="set-partition-1">set-partition!</h5>
<h5 id="set-copy">set-copy</h5>
<h5 id="set-list">set-&gt;list</h5>
<h5 id="list-set">list-&gt;set</h5>
<h5 id="list-set-1">list-&gt;set!</h5>
<h5 id="set-3">set=?</h5>
<h5 id="set-4">set&lt;?</h5>
<h5 id="set-5">set&gt;?</h5>
<h5 id="set-6">set&lt;=?</h5>
<h5 id="set-7">set&gt;=?</h5>
<h5 id="set-union">set-union</h5>
<h5 id="set-intersection">set-intersection</h5>
<h5 id="set-difference">set-difference</h5>
<h5 id="set-xor">set-xor</h5>
<h5 id="set-union-1">set-union!</h5>
<h5 id="set-intersection-1">set-intersection!</h5>
<h5 id="set-difference-1">set-difference!</h5>
<h5 id="set-xor-1">set-xor!</h5>
<h5 id="set-comparator">set-comparator</h5>
<h4 id="bag">Bag</h4>
<h5 id="bag-1">bag</h5>
<h5 id="bag-unfold">bag-unfold</h5>
<h5 id="bag-2">bag?</h5>
<h5 id="bag-contains">bag-contains?</h5>
<h5 id="bag-empty">bag-empty?</h5>
<h5 id="bag-disjoint">bag-disjoint?</h5>
<h5 id="bag-member">bag-member</h5>
<h5 id="bag-element-comparator">bag-element-comparator</h5>
<h5 id="bag-adjoin">bag-adjoin</h5>
<h5 id="bag-adjoin-1">bag-adjoin!</h5>
<h5 id="bag-replace">bag-replace</h5>
<h5 id="bag-replace-1">bag-replace!</h5>
<h5 id="bag-delete">bag-delete</h5>
<h5 id="bag-delete-1">bag-delete!</h5>
<h5 id="bag-delete-all">bag-delete-all</h5>
<h5 id="bag-delete-all-1">bag-delete-all!</h5>
<h5 id="bag-search">bag-search!</h5>
<h5 id="bag-size">bag-size</h5>
<h5 id="bag-find">bag-find</h5>
<h5 id="bag-count">bag-count</h5>
<h5 id="bag-any">bag-any?</h5>
<h5 id="bag-every">bag-every?</h5>
<h5 id="bag-map">bag-map</h5>
<h5 id="bag-for-each">bag-for-each</h5>
<h5 id="bag-fold">bag-fold</h5>
<h5 id="bag-filter">bag-filter</h5>
<h5 id="bag-remove">bag-remove</h5>
<h5 id="bag-partition">bag-partition</h5>
<h5 id="bag-filter-1">bag-filter!</h5>
<h5 id="bag-remove-1">bag-remove!</h5>
<h5 id="bag-partition-1">bag-partition!</h5>
<h5 id="bag-copy">bag-copy</h5>
<h5 id="bag-list">bag-&gt;list</h5>
<h5 id="list-bag">list-&gt;bag</h5>
<h5 id="list-bag-1">list-&gt;bag!</h5>
<h5 id="bag-3">bag=?</h5>
<h5 id="bag-4">bag&lt;?</h5>
<h5 id="bag-5">bag&gt;?</h5>
<h5 id="bag-6">bag&lt;=?</h5>
<h5 id="bag-7">bag&gt;=?</h5>
<h5 id="bag-union">bag-union</h5>
<h5 id="bag-intersection">bag-intersection</h5>
<h5 id="bag-difference">bag-difference</h5>
<h5 id="bag-xor">bag-xor</h5>
<h5 id="bag-union-1">bag-union!</h5>
<h5 id="bag-intersection-1">bag-intersection!</h5>
<h5 id="bag-difference-1">bag-difference!</h5>
<h5 id="bag-xor-1">bag-xor!</h5>
<h5 id="bag-comparator">bag-comparator</h5>
<h5 id="bag-sum">bag-sum</h5>
<h5 id="bag-sum-1">bag-sum!</h5>
<h5 id="bag-product">bag-product</h5>
<h5 id="bag-product-1">bag-product!</h5>
<h5 id="bag-unique-size">bag-unique-size</h5>
<h5 id="bag-element-count">bag-element-count</h5>
<h5 id="bag-for-each-unique">bag-for-each-unique</h5>
<h5 id="bag-fold-unique">bag-fold-unique</h5>
<h5 id="bag-increment">bag-increment!</h5>
<h5 id="bag-decrement">bag-decrement!</h5>
<h5 id="bag-set">bag-&gt;set</h5>
<h5 id="set-bag">set-&gt;bag</h5>
<h5 id="set-bag-1">set-&gt;bag!</h5>
<h5 id="bag-alist">bag-&gt;alist</h5>
<h5 id="alist-bag">alist-&gt;bag</h5>
<h2 id="srfi-srfi-115"><code>(srfi srfi-115)</code></h2>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-115/">SRFI-115</a>.</p>
<h3 id="abstract-39">Abstract</h3>
<p>TODO</p>
<h3 id="reference-39">Reference</h3>
<p>TODO</p>
<h2 id="srfi-srfi-116"><code>(srfi srfi-116)</code></h2>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-116/">SRFI-116</a>.</p>
<h3 id="abstract-40">Abstract</h3>
<p>TODO</p>
<h3 id="reference-40">Reference</h3>
<p>TODO</p>
<h2 id="srfi-srfi-117"><code>(srfi srfi-117)</code></h2>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-117/">SRFI-117</a>.</p>
<h3 id="abstract-41">Abstract</h3>
<p>TODO</p>
<h3 id="reference-41">Reference</h3>
<p>TODO</p>
<h2 id="srfi-srfi-124"><code>(srfi srfi-124)</code></h2>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-124/">SRFI-124</a>.</p>
<h3 id="abstract-42">Abstract</h3>
<p>TODO</p>
<h3 id="reference-42">Reference</h3>
<h4 id="ephemeron-obj"><code>(ephemeron? obj)</code></h4>
<h4 id="make-ephemeron"><code>make-ephemeron</code></h4>
<h4 id="ephemeron-broken"><code>ephemeron-broken?</code></h4>
<h4 id="ephemeron-key"><code>ephemeron-key</code></h4>
<h4 id="ephemeron-value"><code>ephemeron-value</code></h4>
<h2 id="srfi-srfi-125"><code>(srfi srfi-125)</code></h2>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-125/">srfi-125</a>.</p>
<p>The library doesn't implement deprecated features. Application must rely on <code>(scheme comparator)</code> to specify equal predicate and hash function.</p>
<h3 id="abstract-43">Abstract</h3>
<p>This SRFI defines an interface to hash tables, which are widely recognized as a fundamental data structure for a wide variety of applications. A hash table is a data structure that:</p>
<ul>
<li>Is disjoint from all other types.</li>
<li><p>Provides a mapping from objects known as keys to corresponding objects known as values.</p></li>
<li>Keys may be any Scheme objects in some kinds of hash tables, but are restricted in other kinds.</li>
<li><p>Values may be any Scheme objects.</p></li>
<li>Has no intrinsic order for the key-value associations it contains.</li>
<li>Provides an equality predicate which defines when a proposed key is the same as an existing key. No table may contain more than one value for a given key.</li>
<li>Provides a hash function which maps a candidate key into a non-negative exact integer.</li>
<li>Supports mutation as the primary means of setting the contents of a table.</li>
<li>Provides key lookup and destructive update in (expected) amortized constant time, provided a satisfactory hash function is available.</li>
<li><p>Does not guarantee that whole-table operations work in the presence of concurrent mutation of the whole hash table (values may be safely mutated).</p></li>
</ul>
<h3 id="reference-43">Reference</h3>
<h4 id="constructors-2">Constructors</h4>
<h5 id="make-hash-table-comparator-.-args"><code>(make-hash-table comparator . args)</code></h5>
<p>Returns a newly allocated hash table using <code>(scheme comparator)</code> object <code>COMPARATOR</code>. For the time being, <code>ARGS</code> is ignored.</p>
<h5 id="hash-table-comparator-key-value-..."><code>(hash-table comparator [key value] ...)</code></h5>
<p>Returns a newly allocated hash table using <code>(scheme comparator)</code> object <code>COMPARATOR</code>. For each pair of arguments, an association is added to the new hash table with key as its key and value as its value. If the same key (in the sense of the equality predicate) is specified more than once, it is an error.</p>
<h5 id="hash-table-unfold-stop-mapper-successor-seed-comparator-args-..."><code>(hash-table-unfold stop? mapper successor seed comparator args ...)</code></h5>
<p>Create a new hash table as if by <code>make-hash-table</code> using <code>comparator</code> and the <code>args</code>. If the result of applying the predicate <code>stop?</code> to <code>seed</code> is true, return the hash table. Otherwise, apply the procedure <code>mapper</code> to <code>seed</code>. <code>mapper</code> returns two values, which are inserted into the hash table as the key and the value respectively. Then get a new <code>seed</code> by applying the procedure <code>successor</code> to <code>seed</code>, and repeat this algorithm.</p>
<h5 id="alist-hash-table-alist-comparator-arg-..."><code>(alist-&gt;hash-table alist comparator arg ...)</code></h5>
<p>Returns a newly allocated hash-table as if by <code>make-hash-table</code> using <code>comparator</code> and the <code>args</code>. It is then initialized from the associations of <code>alist</code>. Associations earlier in the list take precedence over those that come later.</p>
<h4 id="predicates-2">Predicates</h4>
<h5 id="hash-table-obj"><code>(hash-table? obj)</code></h5>
<p>Returns #t if obj is a hash table, and #f otherwise</p>
<h5 id="hash-table-contains-hash-table-key"><code>(hash-table-contains? hash-table key)</code></h5>
<p>Returns #t if there is any association to key in hash-table, and #f otherwise.</p>
<h5 id="hash-table-empty-hash-table"><code>(hash-table-empty? hash-table)</code></h5>
<p>Returns #t if hash-table contains no associations, and #f otherwise.</p>
<h5 id="hash-table-value-comparator-hash-table1-hash-table2"><code>(hash-table=? value-comparator hash-table1 hash-table2)</code></h5>
<p>Returns #t if hash-table1 and hash-table2 have the same keys (in the sense of their common equality predicate) and each key has the same value (in the sense of value-comparator), and #f otherwise.</p>
<h5 id="hash-table-mutable-hash-table"><code>(hash-table-mutable? hash-table)</code></h5>
<p>Returns #t if the hash table is mutable.</p>
<h4 id="accessors">Accessors</h4>
<p>The following procedures, given a key, return the corresponding value.</p>
<h5 id="hash-table-ref-hash-table-key-failure-success"><code>(hash-table-ref hash-table key [failure [success]])</code></h5>
<p>Extracts the value associated to key in hash-table, invokes the procedure success on it, and returns its result; if success is not provided, then the value itself is returned. If key is not contained in hash-table and failure is supplied, then failure is invoked on no arguments and its result is returned.</p>
<h5 id="hash-table-refdefault-hash-table-key-default"><code>(hash-table-ref/default hash-table key default)</code></h5>
<p>TODO</p>
<h4 id="mutators">Mutators</h4>
<p>The following procedures alter the associations in a hash table either unconditionally, or conditionally on the presence or absence of a specified key. It is an error to add an association to a hash table whose key does not satisfy the type test predicate of the comparator used to create the hash table.</p>
<h5 id="hash-table-set-hash-table-key-value-..."><code>(hash-table-set! hash-table key value ...)</code></h5>
<p>Repeatedly mutates hash-table, creating new associations in it by processing the arguments from left to right. The args alternate between keys and values. Whenever there is a previous association for a key, it is deleted. It is an error if the type check procedure of the comparator of hash-table, when invoked on a key, does not return #t. Likewise, it is an error if a key is not a valid argument to the equality predicate of hash-table. Returns an unspecified value.</p>
<h5 id="hash-table-delete-hash-table-key-..."><code>(hash-table-delete! hash-table key ...)</code></h5>
<p>Deletes any association to each key in hash-table and returns the number of keys that had associations.</p>
<h5 id="hash-table-intern-hash-table-key-failure"><code>(hash-table-intern! hash-table key failure)</code></h5>
<p>Effectively invokes hash-table-ref with the given arguments and returns what it returns. If key was not found in hash-table, its value is set to the result of calling failure.</p>
<h5 id="hash-table-update-hash-table-key-updater-failure-success"><code>(hash-table-update! hash-table key updater [failure [success]])</code></h5>
<p>TODO:</p>
<h5 id="hash-table-pop-hash-table"><code>(hash-table-pop! hash-table)</code></h5>
<p>Chooses an arbitrary association from hash-table and removes it, returning the key and value as two values.</p>
<p>It is an error if hash-table is empty.</p>
<h5 id="hash-table-clear-hash-table"><code>(hash-table-clear! hash-table)</code></h5>
<p>Delete all the associations from hash-table.</p>
<h4 id="the-whole-hash-table">The whole hash table</h4>
<p>These procedures process the associations of the hash table in an unspecified order.</p>
<h5 id="hash-table-size-hash-table"><code>(hash-table-size hash-table)</code></h5>
<p>Returns the number of associations in hash-table as an exact integer.</p>
<h5 id="hash-table-keys-hash-table"><code>(hash-table-keys hash-table)</code></h5>
<p>Returns a newly allocated list of all the keys in hash-table.</p>
<h5 id="hash-table-values-hash-table"><code>(hash-table-values hash-table)</code></h5>
<p>Returns a newly allocated list of all the keys in hash-table.</p>
<h5 id="hash-table-entries-hash-table"><code>(hash-table-entries hash-table)</code></h5>
<p>Returns two values, a newly allocated list of all the keys in hash-table and a newly allocated list of all the values in hash-table in the corresponding order.</p>
<h5 id="hash-table-find-proc-hash-table-failure"><code>(hash-table-find proc hash-table failure)</code></h5>
<p>For each association of hash-table, invoke proc on its key and value. If proc returns true, then hash-table-find returns what proc returns. If all the calls to proc return #f, return the result of invoking the thunk failure.</p>
<h5 id="hash-table-count-pred-hash-table"><code>(hash-table-count pred hash-table)</code></h5>
<p>For each association of hash-table, invoke pred on its key and value. Return the number of calls to pred which returned true.</p>
<h4 id="mapping-and-folding">Mapping and folding</h4>
<p>These procedures process the associations of the hash table in an unspecified order.</p>
<h5 id="hash-table-map-proc-comparator-hash-table"><code>(hash-table-map proc comparator hash-table)</code></h5>
<p>Returns a newly allocated hash table as if by <code>(make-hash-table comparator)</code>. Calls <code>PROC</code> for every association in <code>hash-table</code> with the value of the association. The key of the association and the result of invoking <code>proc</code> are entered into the new hash table. Note that this is not the result of lifting mapping over the domain of hash tables, but it is considered more useful.</p>
<p>If comparator recognizes multiple keys in the hash-table as equivalent, any one of such associations is taken.</p>
<h5 id="hash-table-for-each-proc-hash-table"><code>(hash-table-for-each proc hash-table)</code></h5>
<p>Calls proc for every association in hash-table with two arguments: the key of the association and the value of the association. The value returned by proc is discarded. Returns an unspecified value.</p>
<h5 id="hash-table-map-proc-hash-table"><code>(hash-table-map! proc hash-table)</code></h5>
<p>Calls proc for every association in hash-table with two arguments: the key of the association and the value of the association. The value returned by proc is used to update the value of the association. Returns an unspecified value.</p>
<h5 id="hash-table-map-list-proc-hash-table"><code>(hash-table-map-&gt;list proc hash-table)</code></h5>
<p>Calls proc for every association in hash-table with two arguments: the key of the association and the value of the association. The values returned by the invocations of proc are accumulated into a list, which is returned.</p>
<h5 id="hash-table-fold-proc-seed-hash-table"><code>(hash-table-fold proc seed hash-table)</code></h5>
<p>Calls proc for every association in hash-table with three arguments: the key of the association, the value of the association, and an accumulated value val. Val is seed for the first invocation of procedure, and for subsequent invocations of proc, the returned value of the previous invocation. The value returned by hash-table-fold is the return value of the last invocation of proc.</p>
<h5 id="hash-table-prune-proc-hash-table"><code>(hash-table-prune! proc hash-table)</code></h5>
<p>Calls proc for every association in hash-table with two arguments, the key and the value of the association, and removes all associations from hash-table for which proc returns true. Returns an unspecified value.</p>
<h4 id="copying-and-conversion">Copying and conversion</h4>
<h5 id="hash-table-copy-hash-table-mutable"><code>(hash-table-copy hash-table [mutable?])</code></h5>
<p>Returns a newly allocated hash table with the same properties and associations as hash-table. If the second argument is present and is true, the new hash table is mutable. Otherwise it is immutable provided that the implementation supports immutable hash tables.</p>
<h5 id="hash-table-empty-copy-hash-table"><code>(hash-table-empty-copy hash-table)</code></h5>
<p>Returns a newly allocated mutable hash table with the same properties as hash-table, but with no associations.</p>
<h5 id="hash-table-alist-hash-table"><code>(hash-table-&gt;alist hash-table)</code></h5>
<p>Returns an alist with the same associations as hash-table in an unspecified order.</p>
<h4 id="hash-tables-as-sets">Hash tables as sets</h4>
<h5 id="hash-table-union-hash-table1-hash-table2"><code>(hash-table-union! hash-table1 hash-table2)</code></h5>
<p>Adds the associations of hash-table2 to hash-table1 and returns hash-table1. If a key appears in both hash tables, its value is set to the value appearing in hash-table1. Returns hash-table1.</p>
<h5 id="hash-table-intersection-hash-table1-hash-table2"><code>(hash-table-intersection! hash-table1 hash-table2)</code></h5>
<p>Deletes the associations from hash-table1 whose keys don't also appear in hash-table2 and returns hash-table1.</p>
<h5 id="hash-table-difference-hash-table1-hash-table2"><code>(hash-table-difference! hash-table1 hash-table2)</code></h5>
<p>Deletes the associations of hash-table1 whose keys are also present in hash-table2 and returns hash-table1.</p>
<h5 id="hash-table-xor-hash-table1-hash-table2"><code>(hash-table-xor! hash-table1 hash-table2)</code></h5>
<p>Deletes the associations of hash-table1 whose keys are also present in hash-table2, and then adds the associations of hash-table2 whose keys are not present in hash-table1 to hash-table1. Returns hash-table1.</p>
<h2 id="srfi-srfi-127"><code>(srfi srfi-127)</code></h2>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-127/">SRFI-127</a>.</p>
<h3 id="abstract-44">Abstract</h3>
<p>TODO</p>
<h3 id="reference-44">Reference</h3>
<p>TODO</p>
<h2 id="srfi-srfi-128"><code>(srfi srfi-128)</code></h2>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-128/">SRFI-128</a>.</p>
<h3 id="abstract-45">Abstract</h3>
<p>A comparator is an object of a disjoint type. It is a bundle of procedures that are useful for comparing two objects either for equality or for ordering. There are four procedures in the bundle:</p>
<ul>
<li><p>The type test predicate returns #t if its argument has the correct type to be passed as an argument to the other three procedures, and #f otherwise.</p></li>
<li><p>The equality predicate returns #t if the two objects are the same in the sense of the comparator, and #f otherwise. It is the programmer's responsibility to ensure that it is reflexive, symmetric, transitive, and can handle any arguments that satisfy the type test predicate.</p></li>
<li><p>The comparison procedure returns -1, 0, or 1 if the first object precedes the second, is equal to the second, or follows the second, respectively, in a total order defined by the comparator. It is the programmer's responsibility to ensure that it is reflexive, weakly antisymmetric, transitive, can handle any arguments that satisfy the type test predicate, and returns 0 iff the equality predicate returns #t.</p></li>
<li><p>The hash function takes one argument, and returns an exact non-negative integer. It is the programmer's responsibility to ensure that it can handle any argument that satisfies the type test predicate, and that it returns the same value on two objects if the equality predicate says they are the same (but not necessarily the converse).</p></li>
</ul>
<p>It is also the programmer's responsibility to ensure that all four procedures provide the same result whenever they are applied to the same object(s) (in the sense of eqv?), unless the object(s) have been mutated since the last invocation. In particular, they must not depend in any way on memory addresses in implementations where the garbage collector can move objects in memory.</p>
<p><strong>Limitations</strong></p>
<p>The comparator objects defined in this library are not applicable to circular structure or to NaNs or objects containing them. Attempts to pass any such objects to any procedure defined here, or to any procedure that is part of a comparator defined here, is an error except as otherwise noted.</p>
<h3 id="reference-45">Reference</h3>
<h4 id="predicates-3">Predicates</h4>
<h5 id="comparator-obj"><code>(comparator? obj)</code></h5>
<p>Returns #t if obj is a comparator, and #f otherwise.</p>
<h5 id="comparator-comparison-procedure-comparator"><code>(comparator-comparison-procedure? comparator)</code></h5>
<p>Returns #t if comparator has a supplied comparison procedure, and #f otherwise.</p>
<h5 id="comparator-hash-function-comparator"><code>(comparator-hash-function? comparator)</code></h5>
<p>Returns #t if comparator has a supplied hash function, and #f otherwise.</p>
<h4 id="standard-comparators">Standard comparators</h4>
<h5 id="boolean-comparator"><code>boolean-comparator</code></h5>
<p>Compares booleans using the total order #f &lt; #t.</p>
<h5 id="char-comparator"><code>char-comparator</code></h5>
<p>Compares characters using the total order implied by char&lt;?. On R6RS and R7RS systems, this is Unicode codepoint order.</p>
<h5 id="char-ci-comparator"><code>char-ci-comparator</code></h5>
<p>Compares characters using the total order implied by char-ci&lt;? On R6RS and R7RS systems, this is Unicode codepoint order after the characters have been folded to lower case.</p>
<h5 id="string-comparator"><code>string-comparator</code></h5>
<p>Compares strings using the total order implied by string&lt;?. Note that this order is implementation-dependent.</p>
<h5 id="string-ci-comparator"><code>string-ci-comparator</code></h5>
<p>Compares strings using the total order implied by string-ci&lt;?. Note that this order is implementation-dependent.</p>
<h5 id="symbol-comparator"><code>symbol-comparator</code></h5>
<p>Compares symbols using the total order implied by applying symbol-&gt;string to the symbols and comparing them using the total order implied by string&lt;?. It is not a requirement that the hash function of symbol-comparator be consistent with the hash function of string-comparator, however.</p>
<h5 id="exact-integer-comparator"><code>exact-integer-comparator</code></h5>
<h5 id="integer-comparator"><code>integer-comparator</code></h5>
<h5 id="rational-comparator"><code>rational-comparator</code></h5>
<h5 id="real-comparator"><code>real-comparator</code></h5>
<h5 id="complex-comparator"><code>complex-comparator</code></h5>
<h5 id="number-comparator"><code>number-comparator</code></h5>
<p>These comparators compare exact integers, integers, rational numbers, real numbers, complex numbers, and any numbers using the total order implied by &lt;. They must be compatible with the R5RS numerical tower in the following sense: If S is a subtype of the numerical type T and the two objects are members of S , then the equality predicate and comparison procedures (but not necessarily the hash function) of S-comparator and T-comparator compute the same results on those objects.</p>
<p>Since non-real numbers cannot be compared with &lt;, the following least-surprising ordering is defined: If the real parts are &lt; or &gt;, so are the numbers; otherwise, the numbers are ordered by their imaginary parts. This can still produce surprising results if one real part is exact and the other is inexact.</p>
<h5 id="pair-comparator"><code>pair-comparator</code></h5>
<p>This comparator compares pairs using default-comparator (see below) on their cars. If the cars are not equal, that value is returned. If they are equal, default-comparator is used on their cdrs and that value is returned.</p>
<h5 id="list-comparator"><code>list-comparator</code></h5>
<p>This comparator compares lists lexicographically, as follows:</p>
<ul>
<li>The empty list compares equal to itself.</li>
<li>The empty list compares less than any non-empty list.</li>
<li>Two non-empty lists are compared by comparing their cars. If the cars are not equal when compared using default-comparator (see below), then the result is the result of that comparison. Otherwise, the cdrs are compared using list-comparator.</li>
</ul>
<h5 id="vector-comparator"><code>vector-comparator</code></h5>
<h5 id="bytevector-comparator"><code>bytevector-comparator</code></h5>
<p>These comparators compare vectors and bytevectors by comparing their lengths. A shorter argument is always less than a longer one. If the lengths are equal, then each element is compared in turn using default-comparator (see below) until a pair of unequal elements is found, in which case the result is the result of that comparison. If all elements are equal, the arguments are equal.</p>
<p>If the implementation does not support bytevectors, bytevector-comparator has a type testing procedure that always returns #f.</p>
<h4 id="the-default-comparator">The default comparator</h4>
<h5 id="default-comparator"><code>default-comparator</code></h5>
<p>This is a comparator that accepts any two Scheme values (with the exceptions listed in the Limitations section) and orders them in some implementation-defined way, subject to the following conditions:</p>
<ul>
<li><p>The following ordering between types must hold: the empty list precedes pairs, which precede booleans, which precede characters, which precede strings, which precede symbols, which precede numbers, which precede vectors, which precede bytevectors, which precede all other objects.</p></li>
<li><p>When applied to pairs, booleans, characters, strings, symbols, numbers, vectors, or bytevectors, its behavior must be the same as pair-comparator, boolean-comparator, character-comparator, string-comparator, symbol-comparator, number-comparator, vector-comparator, and bytevector-comparator respectively. The same should be true when applied to an object or objects of a type for which a standard comparator is defined elsewhere.</p></li>
<li><p>Given disjoint types a and b, one of three conditions must hold:</p></li>
<li>All objects of type a compare less than all objects of type b.</li>
<li>All objects of type a compare greater than all objects of type b.</li>
<li><p>All objects of either type a or type b compare equal to each other. This is not permitted for any of the standard types mentioned above.</p></li>
</ul>
<h4 id="comparator-constructors">Comparator constructors</h4>
<h5 id="make-comparator-type-test-equality-compare-hash"><code>(make-comparator type-test equality compare hash)</code></h5>
<p>Returns a comparator which bundles the type-test, equality, compare, and hash procedures provided. As a convenience, the following additional values are accepted:</p>
<ul>
<li>If type-test is #t, a type-test procedure that accepts any arguments is provided.</li>
<li>If equality is #t, an equality predicate is provided that returns #t iff compare returns 0.</li>
<li>If compare or hash is #f, a procedure is provided that signals an error on application. The predicates comparator-comparison-procedure? and/or comparator-hash-function?, respectively, will return #f in these cases.</li>
</ul>
<h5 id="make-inexact-real-comparator-epsilon-rounding-nan-handling"><code>(make-inexact-real-comparator epsilon rounding nan-handling)</code></h5>
<p>Returns a comparator that compares inexact real numbers including NaNs as follows: if after rounding to the nearest epsilon they are the same, they compare equal; otherwise they compare as specified by &lt;. The direction of rounding is specified by the rounding argument, which is either a procedure accepting two arguments (the number and epsilon, or else one of the symbols floor, ceiling, truncate, or round.</p>
<p>The argument nan-handling specifies how to compare NaN arguments to non-NaN arguments. If it is a procedure, the procedure is invoked on the other argument if either argument is a NaN. If it is the symbol min, NaN values precede all other values; if it is the symbol max, they follow all other values, and if it is the symbol error, an error is signaled if a NaN value is compared. If both arguments are NaNs, however, they always compare as equal.</p>
<h5 id="make-list-comparator-element-comparator"><code>(make-list-comparator element-comparator)</code></h5>
<h5 id="make-vector-comparator-element-comparator"><code>(make-vector-comparator element-comparator)</code></h5>
<h5 id="make-bytevector-comparator-element-comparator"><code>(make-bytevector-comparator element-comparator)</code></h5>
<p>These procedures return comparators which compare two lists, vectors, or bytevectors in the same way as list-comparator, vector-comparator, and bytevector-comparator respectively, but using element-comparator rather than default-comparator.</p>
<p>If the implementation does not support bytevectors, the result of invoking make-bytevector-comparator is a comparator whose type testing procedure always returns #f.</p>
<h5 id="make-listwise-comparator-type-test-element-comparator-empty-head-tail"><code>(make-listwise-comparator type-test element-comparator empty? head tail)</code></h5>
<p>Returns a comparator which compares two objects that satisfy type-test as if they were lists, using the empty? procedure to determine if an object is empty, and the head and tail procedures to access particular elements.</p>
<h5 id="make-vectorwise-comparator-type-test-element-comparator-length-ref"><code>(make-vectorwise-comparator type-test element-comparator length ref)</code></h5>
<p>Returns a comparator which compares two objects that satisfy type-test as if they were vectors, using the length procedure to determine the length of the object, and the ref procedure to access a particular element.</p>
<h5 id="make-car-comparator-comparator"><code>(make-car-comparator comparator)</code></h5>
<p>Returns a comparator that compares pairs on their cars alone using comparator.</p>
<h5 id="make-cdr-comparator-comparator"><code>(make-cdr-comparator comparator)</code></h5>
<p>Returns a comparator that compares pairs on their cdrs alone using comparator.</p>
<h5 id="make-pair-comparator-car-comparator-cdr-comparator"><code>(make-pair-comparator car-comparator cdr-comparator)</code></h5>
<p>Returns a comparator that compares pairs first on their cars using car-comparator. If the cars are equal, it compares the cdrs using cdr-comparator.</p>
<h5 id="make-improper-list-comparator-element-comparator"><code>(make-improper-list-comparator element-comparator)</code></h5>
<p>Returns a comparator that compares arbitrary objects as follows: the empty list precedes all pairs, which precede all other objects. Pairs are compared as if with (make-pair-comparator element-comparator element-comparator). All other objects are compared using element-comparator.</p>
<h5 id="make-selecting-comparator-comparator1-comparator2-..."><code>(make-selecting-comparator comparator1 comparator2 ...)</code></h5>
<p>Returns a comparator whose procedures make use of the comparators as follows:</p>
<p>The type test predicate passes its argument to the type test predicates of comparators in the sequence given. If any of them returns #t, so does the type test predicate; otherwise, it returns #f.</p>
<p>The arguments of the equality, compare, and hash functions are passed to the type test predicate of each comparator in sequence. The first comparator whose type test predicate is satisfied on all the arguments is used when comparing those arguments. All other comparators are ignored. If no type test predicate is satisfied, an error is signaled.</p>
<h5 id="make-refining-comparator-comparator1-comparator2-..."><code>(make-refining-comparator comparator1 comparator2 ...)</code></h5>
<p>Returns a comparator that makes use of the comparators in the same way as make-selecting-comparator, except that its procedures can look past the first comparator whose type test predicate is satisfied. If the comparison procedure of that comparator returns zero, then the next comparator whose type test predicate is satisfied is tried in place of it until one returns a non-zero value. If there are no more such comparators, then the comparison procedure returns zero. The equality predicate is defined in the same way. If no type test predicate is satisfied, an error is signaled.</p>
<p>The hash function of the result returns a value which depends, in an implementation-defined way, on the results of invoking the hash functions of the comparators whose type test predicates are satisfied on its argument. In particular, it may depend solely on the first or last such hash function. If no type test predicate is satisfied, an error is signaled.</p>
<p>This procedure is analogous to the expression type refine-compare from SRFI 67.</p>
<h5 id="make-reverse-comparator-comparator"><code>(make-reverse-comparator comparator)</code></h5>
<p>Returns a comparator that behaves like comparator, except that the compare procedure returns 1, 0, and -1 instead of -1, 0, and 1 respectively. This allows ordering in reverse.</p>
<h5 id="make-debug-comparator-comparator"><code>(make-debug-comparator comparator)</code></h5>
<p>Returns a comparator that behaves exactly like comparator, except that whenever any of its procedures are invoked, it verifies all the programmer responsibilities (except stability), and an error is signaled if any of them are violated. Because it requires three arguments, transitivity is not tested on the first call to a debug comparator; it is tested on all future calls using an arbitrarily chosen argument from the previous invocation. Note that this may cause unexpected storage leaks.</p>
<h4 id="wrapped-equality-predicates">Wrapped equality predicates</h4>
<h5 id="eq-comparator"><code>eq-comparator</code></h5>
<h5 id="eqv-comparator"><code>eqv-comparator</code></h5>
<h5 id="equal-comparator"><code>equal-comparator</code></h5>
<p>The equality predicates of these comparators are eq?, eqv?, and equal? respectively. When their comparison procedures are applied to non-equal objects, their behavior is implementation-defined. The type test predicates always return #t.</p>
<p>These comparators accept circular structure (in the case of equal-comparator, provided the implementation's equal does so) and NaNs.</p>
<h4 id="accessors-1">Accessors</h4>
<h5 id="comparator-type-test-procedure-comparator"><code>(comparator-type-test-procedure comparator)</code></h5>
<p>Returns the type test predicate of comparator.</p>
<h5 id="comparator-equality-predicate-comparator"><code>(comparator-equality-predicate comparator)</code></h5>
<p>Returns the equality predicate of comparator.</p>
<h5 id="comparator-comparison-procedure-comparator-1"><code>(comparator-comparison-procedure comparator)</code></h5>
<p>Returns the comparison procedure of comparator.</p>
<h5 id="comparator-hash-function-comparator-1"><code>(comparator-hash-function comparator)</code></h5>
<p>Returns the hash function of comparator.</p>
<h4 id="primitive-applicators">Primitive applicators</h4>
<h5 id="comparator-test-type-comparator-obj"><code>(comparator-test-type comparator obj)</code></h5>
<p>Invokes the type test predicate of comparator on obj and returns what it returns.</p>
<h5 id="comparator-check-type-comparator-obj"><code>(comparator-check-type comparator obj)</code></h5>
<p>Invokes the type test predicate of comparator on obj and returns true if it returns true and signals an error otherwise.</p>
<h5 id="comparator-equal-comparator-obj1-obj2"><code>(comparator-equal? comparator obj1 obj2)</code></h5>
<p>Invokes the equality predicate of comparator on obj1 and obj2 and returns what it returns.</p>
<h5 id="comparator-compare-comparator-obj1-obj2"><code>(comparator-compare comparator obj1 obj2)</code></h5>
<p>Invokes the comparison procedure of comparator on obj1 and obj2 and returns what it returns.</p>
<h5 id="comparator-hash-comparator-obj"><code>(comparator-hash comparator obj)</code></h5>
<p>Invokes the hash function of comparator on obj and returns what it returns.</p>
<h4 id="comparison-procedure-constructors">Comparison procedure constructors</h4>
<h5 id="make-comparison-lt-pred"><code>(make-comparison&lt; lt-pred)</code></h5>
<h5 id="make-comparison-gt-pred"><code>(make-comparison&gt; gt-pred)</code></h5>
<h5 id="make-comparison-le-pred"><code>(make-comparison&lt;= le-pred)</code></h5>
<h5 id="make-comparison-ge-pred"><code>(make-comparison&gt;= ge-pred)</code></h5>
<h5 id="make-comparison-eq-pred-lt-pred"><code>(make-comparison=/&lt; eq-pred lt-pred)</code></h5>
<h5 id="make-comparison-eq-pred-gt-pred"><code>(make-comparison=/&gt; eq-pred gt-pred)</code></h5>
<p>These procedures return a comparison procedure, given a less-than predicate, a greater-than predicate, a less-than-or-equal-to predicate, a greater-than-or-equal-to predicate, or the combination of an equality predicate and either a less-than or a greater-than predicate.</p>
<h4 id="comparison-syntax">Comparison syntax</h4>
<p>The following expression types allow the convenient use of comparison procedures.</p>
<h5 id="if3-expr-less-equal-greater"><code>(if3 &lt;expr&gt; &lt;less&gt; &lt;equal&gt; &lt;greater&gt;)</code></h5>
<p>The expression <code>&lt;expr&gt;</code> is evaluated; it will typically, but not necessarily, be a call on a comparison procedure. If the result is -1, <code>&lt;less&gt;</code> is evaluated and its value(s) are returned; if the result is 0, <code>&lt;equal&gt;</code> is evaluated and its value(s) are returned; if the result is 1, <code>&lt;greater&gt;</code> is evaluated and its value(s) are returned. Otherwise an error is signaled.</p>
<h5 id="if-expr-consequent-alternate"><code>(if=? &lt;expr&gt; &lt;consequent&gt; [ &lt;alternate&gt; ])</code></h5>
<h5 id="if-expr-consequent-alternate-1"><code>(if&lt;? &lt;expr&gt; &lt;consequent&gt; [ &lt;alternate&gt; ])</code></h5>
<h5 id="if-expr-consequent-alternate-2"><code>(if&gt;? &lt;expr&gt; &lt;consequent&gt; [ &lt;alternate&gt; ])</code></h5>
<h5 id="if-expr-consequent-alternate-3"><code>(if&lt;=? &lt;expr&gt; &lt;consequent&gt; [ &lt;alternate&gt; ])</code></h5>
<h5 id="if-expr-consequent-alternate-4"><code>(if&gt;=? &lt;expr&gt; &lt;consequent&gt; [ &lt;alternate&gt; ])</code></h5>
<h5 id="if-not-expr-consequent-alternate"><code>(if-not=? &lt;expr&gt; &lt;consequent&gt; [ &lt;alternate&gt; ])</code></h5>
<p>The expression <code>&lt;expr&gt;</code> is evaluated; it will typically, but not necessarily, be a call on a comparison procedure. It is an error if its value is not -1, 0, or 1. If the value is consistent with the specified relation, <code>&lt;consequent&gt;</code> is evaluated and its value(s) are returned. Otherwise, if <code>&lt;alternate&gt;</code> is present, it is evaluated and its value(s) are returned; if it is absent, an unspecified value is returned.</p>
<h4 id="comparison-predicates">Comparison predicates</h4>
<h5 id="comparator-object1-object2-object3-..."><code>(=? comparator object1 object2 object3 ...)</code></h5>
<h5 id="comparator-object1-object2-object3-...-1"><code>(&lt;? comparator object1 object2 object3 ...)</code></h5>
<h5 id="comparator-object1-object2-object3-...-2"><code>(&gt;? comparator object1 object2 object3 ...)</code></h5>
<h5 id="comparator-object1-object2-object3-...-3"><code>(&lt;=? comparator object1 object2 object3 ...)</code></h5>
<h5 id="comparator-object1-object2-object3-...-4"><code>(&gt;=? comparator object1 object2 object3 ...)</code></h5>
<p>These procedures are analogous to the number, character, and string comparison predicates of Scheme. They allow the convenient use of comparators in situations where the expression types are not usable. They are also analogous to the similarly named procedures SRFI 67, but handle arbitrary numbers of arguments, which in SRFI 67 requires the use of the variants whose names begin with chain.</p>
<p>These procedures apply the comparison procedure of comparator to the objects as follows. If the specified relation returns #t for all objecti and objectj where n is the number of objects and 1 &lt;= i &lt; j &lt;= n, then the procedures return #t, but otherwise #f.</p>
<p>The order in which the values are compared is unspecified. Because the relations are transitive, it suffices to compare each object with its successor.</p>
<h4 id="comparison-predicate-constructors">Comparison predicate constructors</h4>
<h5 id="make-comparator"><code>(make=? comparator)</code></h5>
<h5 id="make-comparator-1"><code>(make&lt;? comparator)</code></h5>
<h5 id="make-comparator-2"><code>(make&gt;? comparator)</code></h5>
<h5 id="make-comparator-3"><code>(make&lt;=? comparator)</code></h5>
<h5 id="make-comparator-4"><code>(make&gt;=? comparator)</code></h5>
<p>These procedures return predicates which, when applied to two or more arguments, return #t if comparing obj1 and obj2 using the equality or comparison procedures of comparator shows that the objects bear the specified relation to one another. Such predicates can be used in contexts that do not understand or expect comparators.</p>
<h4 id="interval-ternary-comparison-predicates">Interval (ternary) comparison predicates</h4>
<p>These procedures return true or false depending on whether an object is contained in an open, closed, or half-open interval. All comparisons are done in the sense of comparator, which is default-comparator if omitted.</p>
<h5 id="in-open-interval-comparator-obj1-obj2-obj3"><code>(in-open-interval? [comparator] obj1 obj2 obj3)</code></h5>
<p>Return #t if obj1 is less than obj2, which is less thanobj3, and #f otherwise.</p>
<h5 id="in-closed-interval-comparator-obj1-obj2-obj3"><code>(in-closed-interval? [comparator] obj1 obj2 obj3)</code></h5>
<p>Returns #t if obj1 is less than or equal to obj2, which is less than or equal to obj3, and #f otherwise.</p>
<h5 id="in-open-closed-interval-comparator-obj1-obj2-obj3"><code>(in-open-closed-interval? [comparator] obj1 obj2 obj3)</code></h5>
<p>Returns #t if obj1 is less than obj2, which is less than or equal to obj3, and #f otherwise.</p>
<h5 id="in-closed-open-interval-comparator-obj1-obj2-obj3"><code>(in-closed-open-interval? [comparator] obj1 obj2 obj3)</code></h5>
<p>Returns #t if obj1 is less than or equal to obj2, which is less than obj3, and #f otherwise.</p>
<h4 id="minmax-comparison-procedures">Min/max comparison procedures</h4>
<h5 id="comparator-min-comparator-object1-object2-..."><code>(comparator-min comparator object1 object2 ...)</code></h5>
<h5 id="comparator-max-comparator-object1-object2-..."><code>(comparator-max comparator object1 object2 ...)</code></h5>
<p>These procedures are analogous to min and max respectively. They apply the comparison procedure of comparator to the objects to find and return a minimal (or maximal) object. The order in which the values are compared is unspecified.</p>
<h2 id="srfi-srfi-132"><code>(srfi srfi-132)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-132/">SRFI-132</a>.</p>
<h3 id="abstract-46">Abstract</h3>
<p>TODO</p>
<h3 id="reference-46">Reference</h3>
<p>TODO</p>
<h2 id="srfi-srfi-133"><code>(srfi srfi-133)</code></h2>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-133/">SRFI-133</a>.</p>
<h3 id="abstract-47">Abstract</h3>
<p>TODO</p>
<h3 id="reference-47">Reference</h3>
<p>TODO</p>
<h2 id="srfi-srfi-134"><code>(srfi srfi-134)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-134/">SRFI-134</a>.</p>
<h3 id="abstract-48">Abstract</h3>
<p>TODO</p>
<h3 id="reference-48">Reference</h3>
<p>TODO</p>
<h2 id="srfi-srfi-135"><code>(srfi srfi-135)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-135/">SRFI-135</a>.</p>
<h3 id="abstract-49">Abstract</h3>
<p>TODO</p>
<h3 id="reference-49">Reference</h3>
<p>TODO</p>
<h2 id="srfi-srfi-141"><code>(srfi srfi-141)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-141/">SRFI-141</a>.</p>
<h3 id="abstract-50">Abstract</h3>
<p>TODO</p>
<h3 id="reference-50">Reference</h3>
<p>TODO</p>
<h2 id="srfi-srfi-143"><code>(srfi srfi-143)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-143/">SRFI-143</a>.</p>
<h3 id="abstract-51">Abstract</h3>
<p>TODO</p>
<h3 id="reference-51">Reference</h3>
<p>TODO</p>
<h2 id="srfi-srfi-144"><code>(srfi srfi-144)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-144/">SRFI-144</a>.</p>
<h3 id="abstract-52">Abstract</h3>
<p>TODO</p>
<h3 id="reference-52">Reference</h3>
<p>TODO</p>
<h2 id="srfi-srfi-145"><code>(srfi srfi-145)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-145/">SRFI-145</a>.</p>
<h3 id="abstract-53">Abstract</h3>
<p>TODO</p>
<h3 id="reference-53">Reference</h3>
<h4 id="assume-obj-syntax"><code>(assume obj)</code> syntax</h4>
<h2 id="srfi-srfi-146"><code>(srfi srfi-146)</code></h2>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-146/">SRFI-146</a>.</p>
<h3 id="abstract-54">Abstract</h3>
<p>Mappings are finite sets of associations, where each association is a pair consisting of a key and an arbitrary Scheme value. The keys are elements of a suitable domain. Each mapping holds no more than one association with the same key. The fundamental mapping operation is retrieving the value of an association stored in the mapping when the key is given.</p>
<h3 id="reference-54">Reference</h3>
<h4 id="mapping">mapping</h4>
<h5 id="construtors">Construtors</h5>
<h6 id="mapping-comparator-key-value-..."><code>(mapping comparator [key value] ...)</code></h6>
<p>Returns a newly allocated mapping. The comparator argument is used to control and distinguish the keys of the mapping. The args alternate between keys and values and are used to initialize the mapping. In particular, the number of args has to be even. Earlier associations with equal keys take precedence over later arguments.</p>
<h6 id="mapping-unfold-stop-mapper-successor-seed-comparator"><code>(mapping-unfold stop? mapper successor seed comparator)</code></h6>
<p>Create a newly allocated mapping as if by mapping using comparator. If the result of applying the predicate stop? to seed is true, return the mapping. Otherwise, apply the procedure mapper to seed. Mapper returns two values which are added to the mapping as the key and the value, respectively. Then get a new seed by applying the procedure successor to seed, and repeat this algorithm. Associations earlier in the list take precedence over those that come later.</p>
<h6 id="mappingordered"><code>(mapping/ordered)</code></h6>
<h6 id="mapping-unfoldordered"><code>(mapping-unfold/ordered</code></h6>
<p>These are the same as mapping and mapping-unfold, except that it is an error if the keys are not in order, and they may be more efficient.</p>
<h5 id="predicates-4">Predicates</h5>
<h6 id="mapping-obj"><code>(mapping? obj)</code></h6>
<p>Returns #t if obj is a mapping, and #f otherwise.</p>
<h6 id="mapping-contains-mapping-key"><code>(mapping-contains? mapping key)</code></h6>
<p>Returns #t if key is the key of an association of mapping and #f otherwise.</p>
<h6 id="mapping-empty-mapping"><code>(mapping-empty? mapping)</code></h6>
<p>Returns #t if mapping has no associations and #f otherwise.</p>
<h6 id="mapping-disjoint-mapping1-mapping2"><code>(mapping-disjoint? mapping1 mapping2)</code></h6>
<p>Returns #t if mapping1 and mapping2 have no keys in common and #f otherwise.</p>
<h5 id="accessors-2">Accessors</h5>
<p>The following three procedures, given a key, return the corresponding value.</p>
<h6 id="mapping-ref-mapping-key-failure-success"><code>(mapping-ref mapping key [failure [success]])</code></h6>
<p>Extracts the value associated to key in the mapping mapping, invokes the procedure success in tail context on it, and returns its result; if success is not provided, then the value itself is returned. If key is not contained in mapping and failure is supplied, then failure is invoked in tail context on no arguments and its values are returned. Otherwise, it is an error.</p>
<h6 id="mapping-refdefault-mapping-key-default"><code>(mapping-ref/default mapping key default)</code></h6>
<h6 id="mapping-key-comparator-mapping"><code>(mapping-key-comparator mapping)</code></h6>
<p>Returns the comparator used to compare the keys of the mapping mapping.</p>
<h5 id="updaters">Updaters</h5>
<h6 id="mapping-adjoin-mapping-arg-..."><code>(mapping-adjoin mapping arg ...)</code></h6>
<p>The mapping-adjoin procedure returns a newly allocated mapping that uses the same comparator as the mapping mapping and contains all the associations of mapping, and in addition new associations by processing the arguments from left to right. The args alternate between keys and values. Whenever there is a previous association for a key, the previous association prevails and the new association is skipped. It is an error to add an association to mapping whose key that does not return #t when passed to the type test procedure of the comparator.</p>
<h6 id="mapping-adjoin-mapping-arg-...-1"><code>(mapping-adjoin! mapping arg ...)</code></h6>
<p>The mapping-adjoin! procedure is the same as mapping-adjoin, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping.</p>
<h6 id="mapping-set-mapping-arg-..."><code>(mapping-set mapping arg ...)</code></h6>
<p>The mapping-set procedure returns a newly allocated mapping that uses the same comparator as the mapping mapping and contains all the associations of mapping, and in addition new associations by processing the arguments from left to right. The args alternate between keys and values. Whenever there is a previous association for a key, it is deleted. It is an error to add an association to mapping whose key that does not return #t when passed to the type test procedure of the comparator.</p>
<h6 id="mapping-set-mapping-arg-...-1"><code>(mapping-set! mapping arg ...)</code></h6>
<p>The mapping-set! procedure is the same as mapping-set, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping.</p>
<h6 id="mapping-replace-mapping-key-value"><code>(mapping-replace mapping key value)</code></h6>
<p>The mapping-replace procedure returns a newly allocated mapping that uses the same comparator as the mapping mapping and contains all the associations of mapping except as follows: If key is equal (in the sense of mapping's comparator) to an existing key of mapping, then the association for that key is omitted and replaced the association defined by the pair key and value. If there is no such key in mapping, then mapping is returned unchanged.</p>
<h6 id="mapping-replace-mapping-key-value-1"><code>(mapping-replace! mapping key value)</code></h6>
<p>The mapping-replace! procedure is the same as mapping-replace, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping.</p>
<h6 id="mapping-delete-mapping-key-..."><code>(mapping-delete mapping key ...)</code></h6>
<h6 id="mapping-delete-mapping-key-...-1"><code>(mapping-delete! mapping key ...)</code></h6>
<h6 id="mapping-delete-all-mapping-key-list"><code>(mapping-delete-all mapping key-list)</code></h6>
<h6 id="mapping-delete-all-mapping-key-list-1"><code>(mapping-delete-all! mapping key-list)</code></h6>
<p>The mapping-delete procedure returns a newly allocated mapping containing all the associations of the mapping mapping except for any whose keys are equal (in the sense of mapping's comparator) to one or more of the keys. Any key that is not equal to some key of the mapping is ignored.</p>
<p>The mapping-delete! procedure is the same as mapping-delete, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping.</p>
<p>The mapping-delete-all and mapping-delete-all! procedures are the same as mapping-delete and mapping-delete!, respectively, except that they accept a single argument which is a list of keys whose associations are to be deleted.</p>
<h6 id="mapping-intern-mapping-key-failure"><code>(mapping-intern mapping key failure)</code></h6>
<p>Extracts the value associated to key in the mapping mapping, and returns mapping and the value as two values. If key is not contained in mapping, failure is invoked on no arguments. The procedure then returns two values, a newly allocated mapping that uses the same comparator as the mapping and contains all the associations of mapping, and in addition a new association mapping key to the result of invoking failure, and the result of invoking failure.</p>
<h6 id="mapping-intern-mapping-key-failure-1"><code>(mapping-intern! mapping key failure)</code></h6>
<p>The mapping-intern! procedure is the same as mapping-intern, except that it is permitted to mutate and return the mapping argument as its first value rather than allocating a new mapping.</p>
<h6 id="mapping-update-mapping-key-updater-failure-success"><code>(mapping-update mapping key updater [failure [success]])</code></h6>
<p>TODO</p>
<h6 id="mapping-update-mapping-key-updater-failure-success-1"><code>(mapping-update! mapping key updater [failure [success]])</code></h6>
<p>The mapping-update! procedure is the same as mapping-update, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping.</p>
<h6 id="mapping-updatedefault-mapping-key-updater-default"><code>(mapping-update/default mapping key updater default)</code></h6>
<p>TODO</p>
<h6 id="mapping-updatedefault-mapping-key-updater-default-1"><code>(mapping-update!/default mapping key updater default)</code></h6>
<p>The mapping-update!/default procedure is the same as mapping-update/default, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping.</p>
<h6 id="mapping-pop-mapping-failure"><code>(mapping-pop mapping [failure])</code></h6>
<p>The mapping-pop procedure exported from (srfi 146) chooses the association with the least key from mapping and returns three values, a newly allocated mapping that uses the same comparator as mapping and contains all associations of mapping except the chosen one, and the key and the value of the chosen association. If mapping contains no association and failure is supplied, then failure is invoked in tail context on no arguments and its values returned. Otherwise, it is an error.</p>
<h6 id="mapping-pop-mapping-failure-1"><code>(mapping-pop! mapping [failure])</code></h6>
<p>The mapping-pop! procedure is the same as mapping-pop, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping.</p>
<h6 id="mapping-search-mapping-key-failure-success"><code>(mapping-search mapping key failure success)</code></h6>
<p>The mapping mapping is searched in order (that is in the order of the stored keys) for an association with key key. If it is not found, then the failure procedure is tail-called with two continuation arguments, insert and ignore, and is expected to tail-call one of them. If an association with key key is found, then the success procedure is tail-called with the matching key of mapping, the associated value, and two continuations, update and remove, and is expected to tail-call one of them.</p>
<p>It is an error if the continuation arguments are invoked, but not in tail position in the failure and success procedures. It is also an error if the failure and success procedures return to their implicit continuation without invoking one of their continuation arguments.</p>
<p>The effects of the continuations are as follows (where obj is any Scheme object):</p>
<ul>
<li><p>Invoking (insert value obj) causes a mapping to be newly allocated that uses the same comparator as the mapping mapping and contains all the associations of mapping, and in addition a new association mapping key to value.</p></li>
<li><p>Invoking (ignore obj) has no effects; in particular, no new mapping is allocated (but see below).</p></li>
<li><p>Invoking (update new-key new-value obj) causes a mapping to be newly allocated that uses the same comparator as the mapping and contains all the associations of mapping, except for the association with key key, which is replaced by a new association mapping new-key to new-value.</p></li>
<li><p>Invoking (remove obj) causes a mapping to be newly allocated that uses the same comparator as the mapping and contains all the associations of mapping, except for the association with key key.</p></li>
</ul>
<p>In all cases, two values are returned: the possibly newly allocated mapping and obj.</p>
<h6 id="mapping-search-mapping-key-failure-success-1"><code>(mapping-search! mapping key failure success)</code></h6>
<p>The mapping-search! procedure is the same as mapping-search, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping.</p>
<h5 id="the-whole-mapping">The whole mapping</h5>
<h6 id="mapping-size-mapping"><code>(mapping-size mapping)</code></h6>
<p>Returns the number of associations in mapping as an exact integer.</p>
<h6 id="mapping-find-predicate-mapping-failure"><code>(mapping-find predicate mapping failure)</code></h6>
<p>Returns the association with the least key of the mapping mapping consisting of a key and value as two values such that predicate returns a true value when invoked with key and value as arguments, or the result of tail-calling failure with no arguments if there is none. There are no guarantees how many times and with which keys and values predicate is invoked.</p>
<h6 id="mapping-count-predicate-mapping"><code>(mapping-count predicate mapping)</code></h6>
<p>Returns the number of associations of the mapping mapping that satisfy predicate (in the sense of mapping-find) as an exact integer. There are no guarantees how many times and with which keys and values predicate is invoked.</p>
<h6 id="mapping-any-predicate-mapping"><code>(mapping-any? predicate mapping)</code></h6>
<p>Returns #t if any association of the mapping mapping satisfies predicate (in the sense of mapping-find), or #f otherwise. There are no guarantees how many times and with which keys and values predicate is invoked.</p>
<h6 id="mapping-every-predicate-mapping"><code>(mapping-every? predicate mapping)</code></h6>
<p>Returns #t if every association of the mapping mapping satisfies predicate (in the sense of mapping-find), or #f otherwise. There are no guarantees how many times and with which keys and values predicate is invoked.</p>
<h6 id="mapping-keys-mapping"><code>(mapping-keys mapping)</code></h6>
<p>Returns a newly allocated list of all the keys in increasing order in the mapping mapping.</p>
<h6 id="mapping-values-mapping"><code>(mapping-values mapping)</code></h6>
<p>Returns a newly allocated list of all the values in increasing order of the keys in the mapping mapping.</p>
<h6 id="mapping-entries-mapping"><code>(mapping-entries mapping)</code></h6>
<p>Returns two values, a newly allocated list of all the keys in the mapping mapping, and a newly allocated list of all the values in the mapping mapping in increasing order of the keys.</p>
<h5 id="mapping-and-folding-1">Mapping and folding</h5>
<h6 id="mapping-map-proc-comparator-mapping"><code>(mapping-map proc comparator mapping)</code></h6>
<p>Applies proc, which returns two values, on two arguments, the key and value of each association of mapping in increasing order of the keys and returns a newly allocated mapping that uses the comparator comparator, and which contains the results of the applications inserted as keys and values.</p>
<h6 id="mapping-map-list-proc-mapping"><code>(mapping-map-&gt;list proc mapping)</code></h6>
<p>Calls proc for every association in increasing order of the keys in the mapping mapping with two arguments: the key of the association and the value of the association. The values returned by the invocations of proc are accumulated into a list, which is returned.</p>
<h6 id="mapping-for-each-proc-mapping"><code>(mapping-for-each proc mapping)</code></h6>
<p>Invokes proc for every association in the mapping mapping in increasing order of the keys, discarding the returned values, with two arguments: the key of the association and the value of the association. Returns an unspecified value.</p>
<h6 id="mapping-fold-proc-nil-mapping"><code>(mapping-fold proc nil mapping)</code></h6>
<p>Invokes proc for each association of the mapping mapping in increasing order of the keys with three arguments: the key of the association, the value of the association, and an accumulated result of the previous invocation. For the first invocation, nil is used as the third argument. Returns the result of the last invocation, or nil if there was no invocation.</p>
<h6 id="mapping-filter-predicate-mapping"><code>(mapping-filter predicate mapping)</code></h6>
<p>Returns a newly allocated mapping with the same comparator as the mapping mapping, containing just the associations of mapping that satisfy predicate (in the sense of mapping-find).</p>
<h6 id="mapping-filter-predicate-mapping-1"><code>(mapping-filter! predicate mapping)</code></h6>
<p>A linear update procedure that returns a mapping containing just the associations of mapping that satisfy predicate.</p>
<h6 id="mapping-remove-predicate-mapping"><code>(mapping-remove predicate mapping)</code></h6>
<p>Returns a newly allocated mapping with the same comparator as the mapping mapping, containing just the associations of mapping that do not satisfy predicate (in the sense of mapping-find).</p>
<h6 id="mapping-remove-predicate-mapping-1"><code>(mapping-remove! predicate mapping)</code></h6>
<p>A linear update procedure that returns a mapping containing just the associations of mapping that do not satisfy predicate.</p>
<h6 id="mapping-partition-predicate-mapping"><code>(mapping-partition predicate mapping)</code></h6>
<p>Returns two values: a newly allocated mapping with the same comparator as the mapping mapping that contains just the associations of mapping that satisfy predicate (in the sense of mapping-find), and another newly allocated mapping, also with the same comparator, that contains just the associations of mapping that do not satisfy predicate.</p>
<h6 id="mapping-partition-predicate-mapping-1"><code>(mapping-partition! predicate mapping)</code></h6>
<p>A linear update procedure that returns two mappings containing the associations of mapping that do and do not, respectively, satisfy predicate.</p>
<h5 id="copying-and-conversion-1">Copying and conversion</h5>
<h6 id="mapping-copy-mapping"><code>(mapping-copy mapping)</code></h6>
<p>Returns a newly allocated mapping containing the associations of the mapping mapping, and using the same comparator.</p>
<h6 id="mapping-alist-mapping"><code>(mapping-&gt;alist mapping)</code></h6>
<p>Returns a newly allocated association list containing the associations of the mapping in increasing order of the keys. Each association in the list is a pair whose car is the key and whose cdr is the associated value.</p>
<h6 id="alist-mapping-comparator-alist"><code>(alist-&gt;mapping comparator alist)</code></h6>
<p>Returns a newly allocated mapping, created as if by mapping using the comparator comparator, that contains the associations in the list, which consist of a pair whose car is the key and whose cdr is the value. Associations earlier in the list take precedence over those that come later.</p>
<h6 id="alist-mapping-mapping-alist"><code>(alist-&gt;mapping! mapping alist)</code></h6>
<p>A linear update procedure that returns a mapping that contains the associations of both mapping and alist. Associations in the mapping and those earlier in the list take precedence over those that come later.</p>
<h5 id="submappings">Submappings</h5>
<p>All predicates in this subsection take a comparator argument, which is a comparator used to compare the values of the associations stored in the mappings. Associations in the mappings are equal if their keys are equal with mappings' key comparator and their values are equal with the given comparator. Two mappings are equal if and only if their associations are equal, respectively.</p>
<p>Note: None of these five predicates produces a total order on mappings. In particular, mapping=?, mapping&lt;?, and mapping&gt;? do not obey the trichotomy law.</p>
<h6 id="mapping-comparator-mapping1-mapping2-..."><code>(mapping=? comparator mapping1 mapping2 ...)</code></h6>
<p>Returns #t if each mapping mapping contains the same associations, and #f otherwise.</p>
<p>Furthermore, it is explicitly not an error if mapping=? is invoked on mappings that do not share the same (key) comparator. In that case, #f is returned.</p>
<h6 id="mapping-comparator-mapping1-mapping2-...-1"><code>(mapping&lt;? comparator mapping1 mapping2 ...)</code></h6>
<p>Returns #t if the set of associations of each mapping mapping other than the last is a proper subset of the following mapping, and #f otherwise.</p>
<h6 id="mapping-comparator-mapping1-mapping2-...-2"><code>(mapping&gt;? comparator mapping1 mapping2 ...)</code></h6>
<p>Returns #t if each mapping mapping contains the same associations, and #f otherwise.</p>
<p>Furthermore, it is explicitly not an error if mapping=? is invoked on mappings that do not share the same (key) comparator. In that case, #f is returned.</p>
<h6 id="mapping-comparator-mapping1-mapping2-...-3"><code>(mapping&lt;=? comparator mapping1 mapping2 ...)</code></h6>
<p>Returns #t if the set of associations of each mapping mapping other than the last is a subset of the following mapping, and #f otherwise.</p>
<h6 id="mapping-comparator-mapping1-mapping2-...-4"><code>(mapping&gt;=? comparator mapping1 mapping2 ...)</code></h6>
<p>Returns #t if the set of associations of each mapping mapping other than the last is a superset of the following mapping, and #f otherwise.</p>
<h5 id="set-theory-operations">Set theory operations</h5>
<h6 id="mapping-union-mapping1-mapping2-..."><code>(mapping-union mapping1 mapping2 ...)</code></h6>
<h6 id="mapping-intersection-mapping1-mapping2-..."><code>(mapping-intersection mapping1 mapping2 ...)</code></h6>
<h6 id="mapping-difference-mapping1-mapping2-..."><code>(mapping-difference mapping1 mapping2 ...)</code></h6>
<h6 id="mapping-xor-mapping1-mapping2-..."><code>(mapping-xor mapping1 mapping2 ...)</code></h6>
<p>Return a newly allocated mapping whose set of associations is the union, intersection, asymmetric difference, or symmetric difference of the sets of associations of the mappings mappings. Asymmetric difference is extended to more than two mappings by taking the difference between the first mapping and the union of the others. Symmetric difference is not extended beyond two mappings. When comparing associations, only the keys are compared. In case of duplicate keys (in the sense of the mappings comparators), associations in the result mapping are drawn from the first mapping in which they appear.</p>
<h6 id="mapping-union-mapping1-mapping2-...-1"><code>(mapping-union! mapping1 mapping2 ...)</code></h6>
<h6 id="mapping-intersection-mapping1-mapping2-...-1"><code>(mapping-intersection! mapping1 mapping2 ...)</code></h6>
<h6 id="mapping-difference-mapping1-mapping2-...-1"><code>(mapping-difference! mapping1 mapping2 ...)</code></h6>
<h6 id="mapping-xor-mapping1-mapping2-...-1"><code>(mapping-xor! mapping1 mapping2 ...)</code></h6>
<p>These procedures are the linear update analogs of the corresponding pure functional procedures above.</p>
<h5 id="additional-procedures">Additional procedures</h5>
<h6 id="mapping-min-key-mapping"><code>(mapping-min-key mapping)</code></h6>
<h6 id="mapping-max-key-mapping"><code>(mapping-max-key mapping)</code></h6>
<p>Returns the least/greatest key contained in the mapping mapping. It is an error for mapping to be empty.</p>
<h6 id="mapping-min-value-mapping"><code>(mapping-min-value mapping)</code></h6>
<h6 id="mapping-max-value-mapping"><code>(mapping-max-value mapping)</code></h6>
<p>Returns the value associated with the least/greatest key contained in the mapping mapping. It is an error for mapping to be empty.</p>
<h6 id="mapping-min-entry-mapping"><code>(mapping-min-entry mapping)</code></h6>
<h6 id="mapping-max-entry-mapping"><code>(mapping-max-entry mapping)</code></h6>
<p>Returns the entry associated with the least/greatest key contained in the mapping mapping as two values, the key and its associated value. It is an error for mapping to be empty.</p>
<h6 id="mapping-key-predecessor-mapping-obj-failure"><code>(mapping-key-predecessor mapping obj failure)</code></h6>
<h6 id="mapping-key-successor-mapping-obj-failure"><code>(mapping-key-successor mapping obj failure)</code></h6>
<p>Returns the key contained in the mapping mapping that immediately precedes/succeeds obj in the mapping's order of keys. If no such key is contained in mapping (because obj is the minimum/maximum key, or because mapping is empty), returns the result of tail-calling the thunk failure.</p>
<h6 id="mapping-range-mapping-obj"><code>(mapping-range= mapping obj)</code></h6>
<h6 id="mapping-range-mapping-obj-1"><code>(mapping-range&lt; mapping obj)</code></h6>
<h6 id="mapping-range-mapping-obj-2"><code>(mapping-range&gt; mapping obj)</code></h6>
<h6 id="mapping-range-mapping-obj-3"><code>(mapping-range&lt;= mapping obj)</code></h6>
<h6 id="mapping-range-mapping-obj-4"><code>(mapping-range&gt;= mapping obj)</code></h6>
<p>Returns a mapping containing only the associations of the mapping whose keys are equal to, less than, greater than, less than or equal to, or greater than or equal to obj.</p>
<h6 id="mapping-range-mapping-obj-5"><code>(mapping-range=! mapping obj)</code></h6>
<h6 id="mapping-range-mapping-obj-6"><code>(mapping-range&lt;! mapping obj)</code></h6>
<h6 id="mapping-range-mapping-obj-7"><code>(mapping-range&gt;! mapping obj)</code></h6>
<h6 id="mapping-range-mapping-obj-8"><code>(mapping-range&lt;=! mapping obj)</code></h6>
<h6 id="mapping-range-mapping-obj-9"><code>(mapping-range&gt;=! mapping obj)</code></h6>
<p>Linear update procedures returning a mapping containing only the associations of the mapping whose keys are equal to, less than, greater than, less than or equal to, or greater than or equal to obj.</p>
<h6 id="mapping-split-mapping-obj"><code>(mapping-split mapping obj)</code></h6>
<p>Returns five values, equivalent to the results of invoking (mapping-range&lt; mapping obj), (mapping-range&lt;= mapping obj), (mapping-range= mapping obj), (mapping-range&gt;= mapping obj), and (mapping-range&gt; mapping obj), but may be more efficient.</p>
<h6 id="mapping-split-mapping-obj-1"><code>(mapping-split! mapping obj)</code></h6>
<p>The mapping-split! procedure is the same as mapping-split, except that it is permitted to mutate and return the mapping rather than allocating a new mapping.</p>
<h6 id="mapping-catenate-comparator-mapping1-key-value-mapping2"><code>(mapping-catenate comparator mapping1 key value mapping2)</code></h6>
<p>Returns a newly allocated mapping using the comparator comparator whose set of associations is the union of the sets of associations of the mapping mapping1, the association mapping key to value, and the associations of mapping2. It is an error if the keys contained in mapping1 in their natural order, the key key, and the keys contained in mapping2 in their natural order (in that order) do not form a strictly monotone sequence with respect to the ordering of comparator.</p>
<h6 id="mapping-catenate-comparator-mapping1-key-value-mapping2-1"><code>(mapping-catenate! comparator mapping1 key value mapping2)</code></h6>
<p>Returns a newly allocated mapping using the comparator comparator whose set of associations is the union of the sets of associations of the mapping mapping1, the association mapping key to value, and the associations of mapping2. It is an error if the keys contained in mapping1 in their natural order, the key key, and the keys contained in mapping2 in their natural order (in that order) do not form a strictly monotone sequence with respect to the ordering of comparator.</p>
<h6 id="mapping-mapmonotone-proc-comparator-mapping"><code>(mapping-map/monotone proc comparator mapping)</code></h6>
<p>Equivalent to (mapping-map proc comparator mapping), but it is an error if proc does not induce a strictly monotone mapping between the keys with respect to the ordering of the comparator of mapping and the ordering of comparator. Maybe be implemented more efficiently than mapping-map.</p>
<h6 id="mapping-mapmonotone-proc-comparator-mapping-1"><code>(mapping-map/monotone! proc comparator mapping)</code></h6>
<p>The mapping-map/monotone! procedure is the same as mapping-map/monotone, except that it is permitted to mutate and return the mapping argument rather than allocating a new mapping.</p>
<h6 id="mapping-foldreverse-proc-nil-mapping"><code>(mapping-fold/reverse proc nil mapping)</code></h6>
<p>Equivalent to (mapping-fold proc nil mapping) except that the associations are processed in reverse order with respect to the natural ordering of the keys.</p>
<h5 id="comparators">Comparators</h5>
<h6 id="comparator-obj-1"><code>(comparator? obj)</code></h6>
<p>Type predicate for comparators as exported by <code>(scheme comparator)</code>.</p>
<h6 id="mapping-comparator"><code>mapping-comparator</code></h6>
<p>mapping-comparator is constructed by invoking make-mapping-comparator on (make-default-comparator).</p>
<h6 id="make-mapping-comparator-comparator"><code>(make-mapping-comparator comparator)</code></h6>
<p>Returns a comparator for mappings that is compatible with the equality predicate (mapping=? comparator mapping1 mapping2). If make-mapping-comparator is imported from (srfi 146), it provides a (partial) ordering predicate that is applicable to pairs of mappings with the same (key) comparator. If (make-hashmap-comparator) is imported from (srfi 146 hash), it provides an implementation-dependent hash function.</p>
<p>If make-mapping-comparator is imported from (srfi 146), the lexicographic ordering with respect to the keys (and, in case a tiebreak is necessary, with respect to the ordering of the values) is used for mappings sharing a comparator.</p>
<p>The existence of comparators returned by make-mapping-comparator allows mappings whose keys are mappings themselves, and it allows to compare mappings whose values are mappings.</p>
<h4 id="hash-mapping">hash mapping</h4>
<h4 id="construtors-1">Construtors</h4>
<h5 id="hashmap-comparator-key-value-..."><code>(hashmap comparator [key value] ...)</code></h5>
<p>Returns a newly allocated hashmap. The comparator argument is used to control and distinguish the keys of the hashmap. The args alternate between keys and values and are used to initialize the hashmap. In particular, the number of args has to be even. Earlier associations with equal keys take precedence over later arguments.</p>
<h5 id="hashmap-unfold-stop-mapper-successor-seed-comparator"><code>(hashmap-unfold stop? mapper successor seed comparator)</code></h5>
<p>Create a newly allocated hashmap as if by hashmap using comparator. If the result of applying the predicate stop? to seed is true, return the hashmap. Otherwise, apply the procedure mapper to seed. Mapper returns two values which are added to the hashmap as the key and the value, respectively. Then get a new seed by applying the procedure successor to seed, and repeat this algorithm. Associations earlier in the list take precedence over those that come later.</p>
<h4 id="predicates-5">Predicates</h4>
<h5 id="hashmap-obj"><code>(hashmap? obj)</code></h5>
<p>Returns #t if obj is a hashmap, and #f otherwise.</p>
<h5 id="hashmap-contains-hashmap-key"><code>(hashmap-contains? hashmap key)</code></h5>
<p>Returns #t if key is the key of an association of hashmap and #f otherwise.</p>
<h5 id="hashmap-empty-hashmap"><code>(hashmap-empty? hashmap)</code></h5>
<p>Returns #t if hashmap has no associations and #f otherwise.</p>
<h5 id="hashmap-disjoint-hashmap1-hashmap2"><code>(hashmap-disjoint? hashmap1 hashmap2)</code></h5>
<p>Returns #t if hashmap1 and hashmap2 have no keys in common and #f otherwise.</p>
<h4 id="accessors-3">Accessors</h4>
<p>The following three procedures, given a key, return the corresponding value.</p>
<h5 id="hashmap-ref-hashmap-key-failure-success"><code>(hashmap-ref hashmap key [failure [success]])</code></h5>
<p>Extracts the value associated to key in the hashmap hashmap, invokes the procedure success in tail context on it, and returns its result; if success is not provided, then the value itself is returned. If key is not contained in hashmap and failure is supplied, then failure is invoked in tail context on no arguments and its values are returned. Otherwise, it is an error.</p>
<h5 id="hashmap-refdefault-hashmap-key-default"><code>(hashmap-ref/default hashmap key default)</code></h5>
<h5 id="hashmap-key-comparator-hashmap"><code>(hashmap-key-comparator hashmap)</code></h5>
<p>Returns the comparator used to compare the keys of the hashmap hashmap.</p>
<h4 id="updaters-1">Updaters</h4>
<h5 id="hashmap-adjoin-hashmap-arg-..."><code>(hashmap-adjoin hashmap arg ...)</code></h5>
<p>The hashmap-adjoin procedure returns a newly allocated hashmap that uses the same comparator as the hashmap hashmap and contains all the associations of hashmap, and in addition new associations by processing the arguments from left to right. The args alternate between keys and values. Whenever there is a previous association for a key, the previous association prevails and the new association is skipped. It is an error to add an association to hashmap whose key that does not return #t when passed to the type test procedure of the comparator.</p>
<h5 id="hashmap-adjoin-hashmap-arg-...-1"><code>(hashmap-adjoin! hashmap arg ...)</code></h5>
<p>The hashmap-adjoin! procedure is the same as hashmap-adjoin, except that it is permitted to mutate and return the hashmap argument rather than allocating a new hashmap.</p>
<h5 id="hashmap-set-hashmap-arg-..."><code>(hashmap-set hashmap arg ...)</code></h5>
<p>The hashmap-set procedure returns a newly allocated hashmap that uses the same comparator as the hashmap hashmap and contains all the associations of hashmap, and in addition new associations by processing the arguments from left to right. The args alternate between keys and values. Whenever there is a previous association for a key, it is deleted. It is an error to add an association to hashmap whose key that does not return #t when passed to the type test procedure of the comparator.</p>
<h5 id="hashmap-set-hashmap-arg-...-1"><code>(hashmap-set! hashmap arg ...)</code></h5>
<p>The hashmap-set! procedure is the same as hashmap-set, except that it is permitted to mutate and return the hashmap argument rather than allocating a new hashmap.</p>
<h5 id="hashmap-replace-hashmap-key-value"><code>(hashmap-replace hashmap key value)</code></h5>
<p>The hashmap-replace procedure returns a newly allocated hashmap that uses the same comparator as the hashmap hashmap and contains all the associations of hashmap except as follows: If key is equal (in the sense of hashmap's comparator) to an existing key of hashmap, then the association for that key is omitted and replaced the association defined by the pair key and value. If there is no such key in hashmap, then hashmap is returned unchanged.</p>
<h5 id="hashmap-replace-hashmap-key-value-1"><code>(hashmap-replace! hashmap key value)</code></h5>
<p>The hashmap-replace! procedure is the same as hashmap-replace, except that it is permitted to mutate and return the hashmap argument rather than allocating a new hashmap.</p>
<h5 id="hashmap-delete-hashmap-key-..."><code>(hashmap-delete hashmap key ...)</code></h5>
<h5 id="hashmap-delete-hashmap-key-...-1"><code>(hashmap-delete! hashmap key ...)</code></h5>
<h5 id="hashmap-delete-all-hashmap-key-list"><code>(hashmap-delete-all hashmap key-list)</code></h5>
<h5 id="hashmap-delete-all-hashmap-key-list-1"><code>(hashmap-delete-all! hashmap key-list)</code></h5>
<p>The hashmap-delete procedure returns a newly allocated hashmap containing all the associations of the hashmap hashmap except for any whose keys are equal (in the sense of hashmap's comparator) to one or more of the keys. Any key that is not equal to some key of the hashmap is ignored.</p>
<p>The hashmap-delete! procedure is the same as hashmap-delete, except that it is permitted to mutate and return the hashmap argument rather than allocating a new hashmap.</p>
<p>The hashmap-delete-all and hashmap-delete-all! procedures are the same as hashmap-delete and hashmap-delete!, respectively, except that they accept a single argument which is a list of keys whose associations are to be deleted.</p>
<h5 id="hashmap-intern-hashmap-key-failure"><code>(hashmap-intern hashmap key failure)</code></h5>
<p>Extracts the value associated to key in the hashmap hashmap, and returns hashmap and the value as two values. If key is not contained in hashmap, failure is invoked on no arguments. The procedure then returns two values, a newly allocated hashmap that uses the same comparator as the hashmap and contains all the associations of hashmap, and in addition a new association hashmap key to the result of invoking failure, and the result of invoking failure.</p>
<h5 id="hashmap-intern-hashmap-key-failure-1"><code>(hashmap-intern! hashmap key failure)</code></h5>
<p>The hashmap-intern! procedure is the same as hashmap-intern, except that it is permitted to mutate and return the hashmap argument as its first value rather than allocating a new hashmap.</p>
<h5 id="hashmap-update-hashmap-key-updater-failure-success"><code>(hashmap-update hashmap key updater [failure [success]])</code></h5>
<p>TODO</p>
<h5 id="hashmap-update-hashmap-key-updater-failure-success-1"><code>(hashmap-update! hashmap key updater [failure [success]])</code></h5>
<p>The hashmap-update! procedure is the same as hashmap-update, except that it is permitted to mutate and return the hashmap argument rather than allocating a new hashmap.</p>
<h5 id="hashmap-updatedefault-hashmap-key-updater-default"><code>(hashmap-update/default hashmap key updater default)</code></h5>
<p>TODO</p>
<h5 id="hashmap-updatedefault-hashmap-key-updater-default-1"><code>(hashmap-update!/default hashmap key updater default)</code></h5>
<p>The hashmap-update!/default procedure is the same as hashmap-update/default, except that it is permitted to mutate and return the hashmap argument rather than allocating a new hashmap.</p>
<h5 id="hashmap-pop-hashmap-failure"><code>(hashmap-pop hashmap [failure])</code></h5>
<p>The hashmap-pop procedure exported from (srfi 146) chooses the association with the least key from hashmap and returns three values, a newly allocated hashmap that uses the same comparator as hashmap and contains all associations of hashmap except the chosen one, and the key and the value of the chosen association. If hashmap contains no association and failure is supplied, then failure is invoked in tail context on no arguments and its values returned. Otherwise, it is an error.</p>
<h5 id="hashmap-pop-hashmap-failure-1"><code>(hashmap-pop! hashmap [failure])</code></h5>
<p>The hashmap-pop! procedure is the same as hashmap-pop, except that it is permitted to mutate and return the hashmap argument rather than allocating a new hashmap.</p>
<h5 id="hashmap-search-hashmap-key-failure-success"><code>(hashmap-search hashmap key failure success)</code></h5>
<p>The hashmap hashmap is searched in order (that is in the order of the stored keys) for an association with key key. If it is not found, then the failure procedure is tail-called with two continuation arguments, insert and ignore, and is expected to tail-call one of them. If an association with key key is found, then the success procedure is tail-called with the matching key of hashmap, the associated value, and two continuations, update and remove, and is expected to tail-call one of them.</p>
<p>It is an error if the continuation arguments are invoked, but not in tail position in the failure and success procedures. It is also an error if the failure and success procedures return to their implicit continuation without invoking one of their continuation arguments.</p>
<p>The effects of the continuations are as follows (where obj is any Scheme object):</p>
<ul>
<li><p>Invoking (insert value obj) causes a hashmap to be newly allocated that uses the same comparator as the hashmap hashmap and contains all the associations of hashmap, and in addition a new association hashmap key to value.</p></li>
<li><p>Invoking (ignore obj) has no effects; in particular, no new hashmap is allocated (but see below).</p></li>
<li><p>Invoking (update new-key new-value obj) causes a hashmap to be newly allocated that uses the same comparator as the hashmap and contains all the associations of hashmap, except for the association with key key, which is replaced by a new association hashmap new-key to new-value.</p></li>
<li><p>Invoking (remove obj) causes a hashmap to be newly allocated that uses the same comparator as the hashmap and contains all the associations of hashmap, except for the association with key key.</p></li>
</ul>
<p>In all cases, two values are returned: the possibly newly allocated hashmap and obj.</p>
<h5 id="hashmap-search-hashmap-key-failure-success-1"><code>(hashmap-search! hashmap key failure success)</code></h5>
<p>The hashmap-search! procedure is the same as hashmap-search, except that it is permitted to mutate and return the hashmap argument rather than allocating a new hashmap.</p>
<h4 id="the-whole-hashmap">The whole hashmap</h4>
<h5 id="hashmap-size-hashmap"><code>(hashmap-size hashmap)</code></h5>
<p>Returns the number of associations in hashmap as an exact integer.</p>
<h5 id="hashmap-find-predicate-hashmap-failure"><code>(hashmap-find predicate hashmap failure)</code></h5>
<p>Returns the association with the least key of the hashmap hashmap consisting of a key and value as two values such that predicate returns a true value when invoked with key and value as arguments, or the result of tail-calling failure with no arguments if there is none. There are no guarantees how many times and with which keys and values predicate is invoked.</p>
<h5 id="hashmap-count-predicate-hashmap"><code>(hashmap-count predicate hashmap)</code></h5>
<p>Returns the number of associations of the hashmap hashmap that satisfy predicate (in the sense of hashmap-find) as an exact integer. There are no guarantees how many times and with which keys and values predicate is invoked.</p>
<h5 id="hashmap-any-predicate-hashmap"><code>(hashmap-any? predicate hashmap)</code></h5>
<p>Returns #t if any association of the hashmap hashmap satisfies predicate (in the sense of hashmap-find), or #f otherwise. There are no guarantees how many times and with which keys and values predicate is invoked.</p>
<h5 id="hashmap-every-predicate-hashmap"><code>(hashmap-every? predicate hashmap)</code></h5>
<p>Returns #t if every association of the hashmap hashmap satisfies predicate (in the sense of hashmap-find), or #f otherwise. There are no guarantees how many times and with which keys and values predicate is invoked.</p>
<h5 id="hashmap-keys-hashmap"><code>(hashmap-keys hashmap)</code></h5>
<p>Returns a newly allocated list of all the keys in increasing order in the hashmap hashmap.</p>
<h5 id="hashmap-values-hashmap"><code>(hashmap-values hashmap)</code></h5>
<p>Returns a newly allocated list of all the values in increasing order of the keys in the hashmap hashmap.</p>
<h5 id="hashmap-entries-hashmap"><code>(hashmap-entries hashmap)</code></h5>
<p>Returns two values, a newly allocated list of all the keys in the hashmap hashmap, and a newly allocated list of all the values in the hashmap hashmap in increasing order of the keys.</p>
<h4 id="hashmap-and-folding">Hashmap and folding</h4>
<h5 id="hashmap-map-proc-comparator-hashmap"><code>(hashmap-map proc comparator hashmap)</code></h5>
<p>Applies proc, which returns two values, on two arguments, the key and value of each association of hashmap in increasing order of the keys and returns a newly allocated hashmap that uses the comparator comparator, and which contains the results of the applications inserted as keys and values.</p>
<h5 id="hashmap-map-list-proc-hashmap"><code>(hashmap-map-&gt;list proc hashmap)</code></h5>
<p>Calls proc for every association in increasing order of the keys in the hashmap hashmap with two arguments: the key of the association and the value of the association. The values returned by the invocations of proc are accumulated into a list, which is returned.</p>
<h5 id="hashmap-for-each-proc-hashmap"><code>(hashmap-for-each proc hashmap)</code></h5>
<p>Invokes proc for every association in the hashmap hashmap in increasing order of the keys, discarding the returned values, with two arguments: the key of the association and the value of the association. Returns an unspecified value.</p>
<h5 id="hashmap-fold-proc-nil-hashmap"><code>(hashmap-fold proc nil hashmap)</code></h5>
<p>Invokes proc for each association of the hashmap hashmap in increasing order of the keys with three arguments: the key of the association, the value of the association, and an accumulated result of the previous invocation. For the first invocation, nil is used as the third argument. Returns the result of the last invocation, or nil if there was no invocation.</p>
<h5 id="hashmap-filter-predicate-hashmap"><code>(hashmap-filter predicate hashmap)</code></h5>
<p>Returns a newly allocated hashmap with the same comparator as the hashmap hashmap, containing just the associations of hashmap that satisfy predicate (in the sense of hashmap-find).</p>
<h5 id="hashmap-filter-predicate-hashmap-1"><code>(hashmap-filter! predicate hashmap)</code></h5>
<p>A linear update procedure that returns a hashmap containing just the associations of hashmap that satisfy predicate.</p>
<h5 id="hashmap-remove-predicate-hashmap"><code>(hashmap-remove predicate hashmap)</code></h5>
<p>Returns a newly allocated hashmap with the same comparator as the hashmap hashmap, containing just the associations of hashmap that do not satisfy predicate (in the sense of hashmap-find).</p>
<h5 id="hashmap-remove-predicate-hashmap-1"><code>(hashmap-remove! predicate hashmap)</code></h5>
<p>A linear update procedure that returns a hashmap containing just the associations of hashmap that do not satisfy predicate.</p>
<h5 id="hashmap-partition-predicate-hashmap"><code>(hashmap-partition predicate hashmap)</code></h5>
<p>Returns two values: a newly allocated hashmap with the same comparator as the hashmap hashmap that contains just the associations of hashmap that satisfy predicate (in the sense of hashmap-find), and another newly allocated hashmap, also with the same comparator, that contains just the associations of hashmap that do not satisfy predicate.</p>
<h5 id="hashmap-partition-predicate-hashmap-1"><code>(hashmap-partition! predicate hashmap)</code></h5>
<p>A linear update procedure that returns two hashmaps containing the associations of hashmap that do and do not, respectively, satisfy predicate.</p>
<h4 id="copying-and-conversion-2">Copying and conversion</h4>
<h5 id="hashmap-copy-hashmap"><code>(hashmap-copy hashmap)</code></h5>
<p>Returns a newly allocated hashmap containing the associations of the hashmap hashmap, and using the same comparator.</p>
<h5 id="hashmap-alist-hashmap"><code>(hashmap-&gt;alist hashmap)</code></h5>
<p>Returns a newly allocated association list containing the associations of the hashmap in increasing order of the keys. Each association in the list is a pair whose car is the key and whose cdr is the associated value.</p>
<h5 id="alist-hashmap-comparator-alist"><code>(alist-&gt;hashmap comparator alist)</code></h5>
<p>Returns a newly allocated hashmap, created as if by hashmap using the comparator comparator, that contains the associations in the list, which consist of a pair whose car is the key and whose cdr is the value. Associations earlier in the list take precedence over those that come later.</p>
<h5 id="alist-hashmap-hashmap-alist"><code>(alist-&gt;hashmap! hashmap alist)</code></h5>
<p>A linear update procedure that returns a hashmap that contains the associations of both hashmap and alist. Associations in the hashmap and those earlier in the list take precedence over those that come later.</p>
<h4 id="set-theory-operations-1">Set theory operations</h4>
<h5 id="hashmap-union-hashmap1-hashmap2-..."><code>(hashmap-union hashmap1 hashmap2 ...)</code></h5>
<h5 id="hashmap-intersection-hashmap1-hashmap2-..."><code>(hashmap-intersection hashmap1 hashmap2 ...)</code></h5>
<h5 id="hashmap-difference-hashmap1-hashmap2-..."><code>(hashmap-difference hashmap1 hashmap2 ...)</code></h5>
<h5 id="hashmap-xor-hashmap1-hashmap2-..."><code>(hashmap-xor hashmap1 hashmap2 ...)</code></h5>
<p>Return a newly allocated hashmap whose set of associations is the union, intersection, asymmetric difference, or symmetric difference of the sets of associations of the hashmaps hashmaps. Asymmetric difference is extended to more than two hashmaps by taking the difference between the first hashmap and the union of the others. Symmetric difference is not extended beyond two hashmaps. When comparing associations, only the keys are compared. In case of duplicate keys (in the sense of the hashmaps comparators), associations in the result hashmap are drawn from the first hashmap in which they appear.</p>
<h5 id="hashmap-union-hashmap1-hashmap2-...-1"><code>(hashmap-union! hashmap1 hashmap2 ...)</code></h5>
<h5 id="hashmap-intersection-hashmap1-hashmap2-...-1"><code>(hashmap-intersection! hashmap1 hashmap2 ...)</code></h5>
<h5 id="hashmap-difference-hashmap1-hashmap2-...-1"><code>(hashmap-difference! hashmap1 hashmap2 ...)</code></h5>
<h5 id="hashmap-xor-hashmap1-hashmap2-...-1"><code>(hashmap-xor! hashmap1 hashmap2 ...)</code></h5>
<p>These procedures are the linear update analogs of the corresponding pure functional procedures above.</p>
<h4 id="comparators-1">Comparators</h4>
<h5 id="comparator-obj-2"><code>(comparator? obj)</code></h5>
<p>Type predicate for comparators as exported by <code>(scheme comparator)</code>.</p>
<h5 id="hashmap-comparator"><code>hashmap-comparator</code></h5>
<p>hashmap-comparator is constructed by invoking make-hashmap-comparator on (make-default-comparator).</p>
<h5 id="make-hashmap-comparator-comparator"><code>(make-hashmap-comparator comparator)</code></h5>
<p>Returns a comparator for hashmaps that is compatible with the equality predicate (hashmap=? comparator hashmap1 hashmap2). If make-hashmap-comparator is imported from (srfi 146), it provides a (partial) ordering predicate that is applicable to pairs of hashmaps with the same (key) comparator. If (make-hashmap-comparator) is imported from (srfi 146 hash), it provides an implementation-dependent hash function.</p>
<p>If make-hashmap-comparator is imported from (srfi 146), the lexicographic ordering with respect to the keys (and, in case a tiebreak is necessary, with respect to the ordering of the values) is used for hashmaps sharing a comparator.</p>
<p>The existence of comparators returned by make-hashmap-comparator allows hashmaps whose keys are hashmaps themselves, and it allows to compare hashmaps whose values are hashmaps.</p>
<h2 id="srfi-srfi-151"><code>(srfi srfi-151)</code></h2>
<p>This library is based on <a href="https://srfi.schemers.org/srfi-151/">SRFI-151</a>.</p>
<h3 id="abstract-55">Abstract</h3>
<p>This library offers a coherent and comprehensive set of procedures for performing bitwise logical operations on integers.</p>
<h3 id="reference-55">Reference</h3>
<h4 id="bitwise-not-i"><code>(bitwise-not i)</code></h4>
<p>Returns the bitwise complement of i; that is, all 1 bits are changed to 0 bits and all 0 bits to 1 bits.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(bitwise-not <span class="dv">10</span>) <span class="co">;; =&gt; -11</span>
(bitwise-not <span class="dv">-37</span>) <span class="co">;; =&gt; 36</span></code></pre></div>
<p>The following ten procedures correspond to the useful set of non-trivial two-argument boolean functions. For each such function, the corresponding bitwise operator maps that function across a pair of bitstrings in a bit-wise fashion. The core idea of this group of functions is this bitwise &quot;lifting&quot; of the set of dyadic boolean functions to bitstring parameters.</p>
<h4 id="bitwise-and-i-..."><code>(bitwise-and i ...)</code></h4>
<h4 id="bitwise-ior-i-..."><code>(bitwise-ior i ...)</code></h4>
<h4 id="bitwise-xor-i-..."><code>(bitwise-xor i ...)</code></h4>
<h4 id="bitwise-eqv-i-..."><code>(bitwise-eqv i ...)</code></h4>
<p>These operations are associative. When passed no arguments, the procedures return the identity values -1, 0, 0, and -1 respectively.</p>
<p>The bitwise-eqv procedure produces the complement of the bitwise-xor procedure. When applied to three arguments, it does not produce a 1 bit everywhere that a, b and c all agree. That is, it does not produce</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">     (bitwise-ior (bitwise-and a b c)
                  (bitwise-and (bitwise-not a)
                               (bitwise-not b)
                               (bitwise-not c)))</code></pre></div>
<p>Rather, it produces (bitwise-eqv a (bitwise-eqv b c)) or the equivalent (bitwise-eqv (bitwise-eqv a b) c).</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(bitwise-ior <span class="dv">3</span>  <span class="dv">10</span>)     <span class="kw">=&gt;</span>  <span class="dv">11</span>
(bitwise-and <span class="dv">11</span> <span class="dv">26</span>)     <span class="kw">=&gt;</span>  <span class="dv">10</span>
(bitwise-xor <span class="dv">3</span> <span class="dv">10</span>)      <span class="kw">=&gt;</span>   <span class="dv">9</span>
(bitwise-eqv <span class="dv">37</span> <span class="dv">12</span>)     <span class="kw">=&gt;</span> <span class="dv">-42</span>
(bitwise-and <span class="dv">37</span> <span class="dv">12</span>)     <span class="kw">=&gt;</span>   <span class="dv">4</span></code></pre></div>
<h4 id="bitwise-nand-i-j"><code>(bitwise-nand i j)</code></h4>
<h4 id="bitwise-nor-i-j"><code>(bitwise-nor i j)</code></h4>
<h4 id="bitwise-andc1-i-j"><code>(bitwise-andc1 i j)</code></h4>
<h4 id="bitwise-andc2-i-j"><code>(bitwise-andc2 i j)</code></h4>
<h4 id="bitwise-orc1-i-j"><code>(bitwise-orc1 i j)</code></h4>
<h4 id="bitwise-orc2-i-j"><code>(bitwise-orc2 i j)</code></h4>
<p>These operations are not associative.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(bitwise-nand <span class="dv">11</span> <span class="dv">26</span>) <span class="kw">=&gt;</span>  <span class="dv">-11</span>
(bitwise-nor  <span class="dv">11</span> <span class="dv">26</span>) <span class="kw">=&gt;</span> <span class="dv">-28</span>
(bitwise-andc1 <span class="dv">11</span> <span class="dv">26</span>) <span class="kw">=&gt;</span> <span class="dv">16</span>
(bitwise-andc2 <span class="dv">11</span> <span class="dv">26</span>) <span class="kw">=&gt;</span> <span class="dv">1</span>
(bitwise-orc1 <span class="dv">11</span> <span class="dv">26</span>) <span class="kw">=&gt;</span> <span class="dv">-2</span>
(bitwise-orc2 <span class="dv">11</span> <span class="dv">26</span>) <span class="kw">=&gt;</span> <span class="dv">-17</span></code></pre></div>
<h4 id="arithmetic-shift-i-count"><code>(arithmetic-shift i count)</code></h4>
<p>Returns the arithmetic left shift when count&gt;0; right shift when count&lt;0.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(arithmetic-shift <span class="dv">8</span> <span class="dv">2</span>) <span class="kw">=&gt;</span> <span class="dv">32</span>
(arithmetic-shift <span class="dv">4</span> <span class="dv">0</span>) <span class="kw">=&gt;</span> <span class="dv">4</span>
(arithmetic-shift <span class="dv">8</span> <span class="dv">-1</span>) <span class="kw">=&gt;</span> <span class="dv">4</span>
(arithmetic-shift <span class="dv">-100000000000000000000000000000000</span> <span class="dv">-100</span>) <span class="kw">=&gt;</span> <span class="dv">-79</span></code></pre></div>
<h4 id="bit-count-i"><code>(bit-count i)</code></h4>
<p>Returns the population count of 1's (i &gt;= 0) or 0's (i &lt; 0). The result is always non-negative.</p>
<p>Compatibility note: The R6RS analogue bitwise-bit-count applies bitwise-not to the population count before returning it if i is negative.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(bit-count <span class="dv">0</span>) <span class="kw">=&gt;</span>  <span class="dv">0</span>
(bit-count <span class="dv">-1</span>) <span class="kw">=&gt;</span>  <span class="dv">0</span>
(bit-count <span class="dv">7</span>) <span class="kw">=&gt;</span>  <span class="dv">3</span>
(bit-count  <span class="dv">13</span>) <span class="kw">=&gt;</span>  <span class="dv">3</span> <span class="co">;Two&#39;s-complement binary: ...0001101</span>
(bit-count <span class="dv">-13</span>) <span class="kw">=&gt;</span>  <span class="dv">2</span> <span class="co">;Two&#39;s-complement binary: ...1110011</span>
(bit-count  <span class="dv">30</span>) <span class="kw">=&gt;</span>  <span class="dv">4</span> <span class="co">;Two&#39;s-complement binary: ...0011110</span>
(bit-count <span class="dv">-30</span>) <span class="kw">=&gt;</span>  <span class="dv">4</span> <span class="co">;Two&#39;s-complement binary: ...1100010</span>
(bit-count (<span class="kw">expt</span> <span class="dv">2</span> <span class="dv">100</span>)) <span class="kw">=&gt;</span>  <span class="dv">1</span>
(bit-count (<span class="kw">-</span> (<span class="kw">expt</span> <span class="dv">2</span> <span class="dv">100</span>))) <span class="kw">=&gt;</span>  <span class="dv">100</span>
(bit-count (<span class="kw">-</span> (<span class="dv">1</span>+ (<span class="kw">expt</span> <span class="dv">2</span> <span class="dv">100</span>)))) <span class="kw">=&gt;</span>  <span class="dv">1</span></code></pre></div>
<h4 id="integer-length-i"><code>(integer-length i)</code></h4>
<p>The number of bits needed to represent i, i.e.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">ceiling</span> (<span class="kw">/</span> (<span class="kw">log</span> (<span class="kw">if</span> (<span class="kw">negative?</span> integer)
                     (<span class="kw">-</span> integer)
                     (<span class="kw">+</span> <span class="dv">1</span> integer)))
            (<span class="kw">log</span> <span class="dv">2</span>)))</code></pre></div>
<p>The result is always non-negative. For non-negative i, this is the number of bits needed to represent i in an unsigned binary representation. For all i, (+ 1 (integer-length i)) is the number of bits needed to represent i in a signed twos-complement representation.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(integer-length  <span class="dv">0</span>) <span class="kw">=&gt;</span> <span class="dv">0</span>
(integer-length  <span class="dv">1</span>) <span class="kw">=&gt;</span> <span class="dv">1</span>
(integer-length <span class="dv">-1</span>) <span class="kw">=&gt;</span> <span class="dv">0</span>
(integer-length  <span class="dv">7</span>) <span class="kw">=&gt;</span> <span class="dv">3</span>
(integer-length <span class="dv">-7</span>) <span class="kw">=&gt;</span> <span class="dv">3</span>
(integer-length  <span class="dv">8</span>) <span class="kw">=&gt;</span> <span class="dv">4</span>
(integer-length <span class="dv">-8</span>) <span class="kw">=&gt;</span> <span class="dv">3</span></code></pre></div>
<h4 id="bitwise-if-mask-i-j"><code>(bitwise-if mask i j)</code></h4>
<p>Merge the bitstrings i and j, with bitstring mask determining from which string to take each bit. That is, if the kth bit of mask is 1, then the kth bit of the result is the kth bit of i, otherwise the kth bit of j.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(bitwise-if <span class="dv">3</span> <span class="dv">1</span> <span class="dv">8</span>) <span class="kw">=&gt;</span> <span class="dv">9</span>
(bitwise-if <span class="dv">3</span> <span class="dv">8</span> <span class="dv">1</span>) <span class="kw">=&gt;</span> <span class="dv">0</span>
(bitwise-if <span class="dv">1</span> <span class="dv">1</span> <span class="dv">2</span>) <span class="kw">=&gt;</span> <span class="dv">3</span>
(bitwise-if <span class="ch">#b</span><span class="dv">00111100</span> <span class="ch">#b</span><span class="dv">11110000</span> <span class="ch">#b</span><span class="dv">00001111</span>) <span class="kw">=&gt;</span> <span class="ch">#b</span><span class="dv">00110011</span></code></pre></div>
<h4 id="bit-set-index-i"><code>(bit-set? index i)</code></h4>
<p>Is bit index set in bitstring i (where index is a non-negative exact integer)?</p>
<p>Compatibility note: The R6RS analogue bitwise-bit-set? accepts its arguments in the opposite order.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(bit-set? <span class="dv">1</span> <span class="dv">1</span>) <span class="kw">=&gt;</span>  false
(bit-set? <span class="dv">0</span> <span class="dv">1</span>) <span class="kw">=&gt;</span>  true
(bit-set? <span class="dv">3</span> <span class="dv">10</span>) <span class="kw">=&gt;</span>  true
(bit-set? <span class="dv">1000000</span> <span class="dv">-1</span>) <span class="kw">=&gt;</span>  true
(bit-set? <span class="dv">2</span> <span class="dv">6</span>) <span class="kw">=&gt;</span>  true
(bit-set? <span class="dv">0</span> <span class="dv">6</span>) <span class="kw">=&gt;</span>  false</code></pre></div>
<h4 id="copy-bit-index-i-boolean"><code>(copy-bit index i boolean)</code></h4>
<p>Returns an integer the same as i except in the indexth bit, which is 1 if boolean is #t and 0 if boolean is #f.</p>
<p>Compatibility note: The R6RS analogue bitwise-copy-bit as originally documented has a completely different interface. (bitwise-copy-bit dest index source) replaces the index'th bit of dest with the index'th bit of source. It is equivalent to (bit-field-replace-same dest source index (+ index 1)). However, an erratum made a silent breaking change to interpret the third argument as 0 for a false bit and 1 for a true bit. Some R6RS implementations applied this erratum but others did not.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(copy-bit <span class="dv">0</span> <span class="dv">0</span> <span class="dv">#t</span>) <span class="kw">=&gt;</span> <span class="ch">#b</span><span class="dv">1</span>
(copy-bit <span class="dv">2</span> <span class="dv">0</span> <span class="dv">#t</span>) <span class="kw">=&gt;</span> <span class="ch">#b</span><span class="dv">100</span>
(copy-bit <span class="dv">2</span> <span class="ch">#b</span><span class="dv">1111</span> <span class="dv">#f</span>) <span class="kw">=&gt;</span> <span class="ch">#b</span><span class="dv">1011</span></code></pre></div>
<h4 id="bit-swap-index1-index2-i"><code>(bit-swap index1 index2 i)</code></h4>
<p>Returns an integer the same as i except that the index1th bit and the index2th bit have been exchanged.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(bit-swap <span class="dv">0</span> <span class="dv">2</span> <span class="dv">4</span>) <span class="kw">=&gt;</span> <span class="ch">#b</span><span class="dv">1</span></code></pre></div>
<h4 id="any-bit-set-test-bits-i"><code>(any-bit-set? test-bits i)</code></h4>
<h4 id="every-bit-set-test-bits-i"><code>(every-bit-set? test-bits i)</code></h4>
<p>Determines if any/all of the bits set in bitstring test-bits are set in bitstring i. I.e., returns (not (zero? (bitwise-and test-bits i))) and (= test-bits (bitwise-and test-bits i))) respectively.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(any-bit-set? <span class="dv">3</span> <span class="dv">6</span>) <span class="kw">=&gt;</span> <span class="dv">#t</span>
(any-bit-set? <span class="dv">3</span> <span class="dv">12</span>) <span class="kw">=&gt;</span> <span class="dv">#f</span>
(every-bit-set? <span class="dv">4</span> <span class="dv">6</span>) <span class="kw">=&gt;</span> <span class="dv">#t</span>
(every-bit-set? <span class="dv">7</span> <span class="dv">6</span>) <span class="kw">=&gt;</span> <span class="dv">#f</span></code></pre></div>
<h4 id="first-set-bit-i"><code>(first-set-bit i)</code></h4>
<p>Return the index of the first (smallest index) 1 bit in bitstring i. Return -1 if i contains no 1 bits (i.e., if i is zero).</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(first-set-bit <span class="dv">1</span>) <span class="kw">=&gt;</span> <span class="dv">0</span>
(first-set-bit <span class="dv">2</span>) <span class="kw">=&gt;</span> <span class="dv">1</span>
(first-set-bit <span class="dv">0</span>) <span class="kw">=&gt;</span> <span class="dv">-1</span>
(first-set-bit <span class="dv">40</span>) <span class="kw">=&gt;</span> <span class="dv">3</span>
(first-set-bit <span class="dv">-28</span>) <span class="kw">=&gt;</span> <span class="dv">2</span>
(first-set-bit (<span class="kw">expt</span>  <span class="dv">2</span> <span class="dv">99</span>)) <span class="kw">=&gt;</span> <span class="dv">99</span>
(first-set-bit (<span class="kw">expt</span> <span class="dv">-2</span> <span class="dv">99</span>)) <span class="kw">=&gt;</span> <span class="dv">99</span></code></pre></div>
<h4 id="bit-field-i-start-end">`(bit-field i start end)</h4>
<p>Returns the field from i, shifted down to the least-significant position in the result.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(bit-field <span class="ch">#b</span><span class="dv">1101101010</span> <span class="dv">0</span> <span class="dv">4</span>) <span class="kw">=&gt;</span> <span class="ch">#b</span><span class="dv">1010</span>
(bit-field <span class="ch">#b</span><span class="dv">1101101010</span> <span class="dv">3</span> <span class="dv">9</span>) <span class="kw">=&gt;</span> <span class="ch">#b</span><span class="dv">101101</span>
(bit-field <span class="ch">#b</span><span class="dv">1101101010</span> <span class="dv">4</span> <span class="dv">9</span>) <span class="kw">=&gt;</span> <span class="ch">#b</span><span class="dv">10110</span>
(bit-field <span class="ch">#b</span><span class="dv">1101101010</span> <span class="dv">4</span> <span class="dv">10</span>) <span class="kw">=&gt;</span> <span class="ch">#b</span><span class="dv">110110</span>
(bit-field <span class="dv">6</span> <span class="dv">0</span> <span class="dv">1</span>) <span class="kw">=&gt;</span> <span class="dv">0</span>
(bit-field <span class="dv">6</span> <span class="dv">1</span> <span class="dv">3</span>) <span class="kw">=&gt;</span> <span class="dv">3</span>
(bit-field <span class="dv">6</span> <span class="dv">2</span> <span class="dv">999</span>) <span class="kw">=&gt;</span> <span class="dv">1</span>
(bit-field <span class="ch">#x</span><span class="dv">100000000000000000000000000000000</span> <span class="dv">128</span> <span class="dv">129</span>) <span class="kw">=&gt;</span> <span class="dv">1</span></code></pre></div>
<h4 id="bit-field-any-i-start-end"><code>(bit-field-any? i start end)</code></h4>
<p>Returns true if any of the field's bits are set in bitstring i, and false otherwise.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(bit-field-any? <span class="ch">#b</span><span class="dv">1001001</span> <span class="dv">1</span> <span class="dv">6</span>) <span class="kw">=&gt;</span> <span class="dv">#t</span>
(bit-field-any? <span class="ch">#b</span><span class="dv">1000001</span> <span class="dv">1</span> <span class="dv">6</span>) <span class="kw">=&gt;</span> <span class="dv">#f</span></code></pre></div>
<h4 id="bit-field-every-i-start-end"><code>(bit-field-every? i start end)</code></h4>
<p>Returns false if any of the field's bits are not set in bitstring i, and true otherwise.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(bit-field-every? <span class="ch">#b</span><span class="dv">1011110</span> <span class="dv">1</span> <span class="dv">5</span>) <span class="kw">=&gt;</span> <span class="dv">#t</span>
(bit-field-every? <span class="ch">#b</span><span class="dv">1011010</span> <span class="dv">1</span> <span class="dv">5</span>) <span class="kw">=&gt;</span> <span class="dv">#f</span></code></pre></div>
<h4 id="bit-field-clear-i-start-end"><code>(bit-field-clear i start end)</code></h4>
<h4 id="bit-field-set-i-start-end"><code>(bit-field-set i start end)</code></h4>
<p>Returns i with the field's bits set to all 0s/1s.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(bit-field-clear <span class="ch">#b</span><span class="dv">101010</span> <span class="dv">1</span> <span class="dv">4</span>) <span class="kw">=&gt;</span> <span class="ch">#b</span><span class="dv">100000</span>
(bit-field-set <span class="ch">#b</span><span class="dv">101010</span> <span class="dv">1</span> <span class="dv">4</span>) <span class="kw">=&gt;</span> <span class="ch">#b</span><span class="dv">101110</span></code></pre></div>
<h4 id="bit-field-replace-dest-source-start-end"><code>(bit-field-replace dest source start end)</code></h4>
<p>Returns dest with the field replaced by the least-significant end-start bits in source.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(bit-field-replace <span class="ch">#b</span><span class="dv">101010</span> <span class="ch">#b</span><span class="dv">010</span> <span class="dv">1</span> <span class="dv">4</span>) <span class="kw">=&gt;</span> <span class="ch">#b</span><span class="dv">100100</span>
(bit-field-replace <span class="ch">#b</span><span class="dv">110</span> <span class="dv">1</span> <span class="dv">0</span> <span class="dv">1</span>) <span class="kw">=&gt;</span> <span class="ch">#b</span><span class="dv">111</span>
(bit-field-replace <span class="ch">#b</span><span class="dv">110</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">2</span>) <span class="kw">=&gt;</span> <span class="ch">#b</span><span class="dv">110</span></code></pre></div>
<h4 id="bit-field-replace-same-dest-source-start-end"><code>(bit-field-replace-same dest source start end)</code></h4>
<p>Returns dest with its field replaced by the corresponding field in source.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(bit-field-replace-same <span class="ch">#b</span><span class="dv">1111</span> <span class="ch">#b</span><span class="dv">0000</span> <span class="dv">1</span> <span class="dv">3</span>) <span class="kw">=&gt;</span> <span class="ch">#b</span><span class="dv">1001</span></code></pre></div>
<h4 id="bit-field-rotate-i-count-start-end"><code>(bit-field-rotate i count start end)</code></h4>
<p>Returns i with the field cyclically permuted by count bits towards high-order.</p>
<p>Compatibility note: The R6RS analogue bitwise-rotate-bit-field uses the argument ordering i start end count.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(bit-field-rotate <span class="ch">#b</span><span class="dv">110</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">10</span>) <span class="kw">=&gt;</span> <span class="ch">#b</span><span class="dv">110</span>
(bit-field-rotate <span class="ch">#b</span><span class="dv">110</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">256</span>) <span class="kw">=&gt;</span> <span class="ch">#b</span><span class="dv">110</span>
(bit-field-rotate <span class="ch">#x</span><span class="dv">100000000000000000000000000000000</span> <span class="dv">1</span> <span class="dv">0</span> <span class="dv">129</span>) <span class="kw">=&gt;</span> <span class="dv">1</span>
(bit-field-rotate <span class="ch">#b</span><span class="dv">110</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">2</span>) <span class="kw">=&gt;</span> <span class="ch">#b</span><span class="dv">110</span>
(bit-field-rotate <span class="ch">#b</span><span class="dv">110</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">4</span>) <span class="kw">=&gt;</span> <span class="ch">#b</span><span class="dv">1010</span>
(bit-field-rotate <span class="ch">#b</span><span class="dv">0111</span> <span class="dv">-1</span> <span class="dv">1</span> <span class="dv">4</span>) <span class="kw">=&gt;</span> <span class="ch">#b</span><span class="dv">1011</span></code></pre></div>
<h4 id="bit-field-reverse-i-start-end"><code>(bit-field-reverse i start end)</code></h4>
<p>Returns i with the order of the bits in the field reversed.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(bit-field-reverse <span class="dv">6</span> <span class="dv">1</span> <span class="dv">3</span>) <span class="kw">=&gt;</span> <span class="dv">6</span>
(bit-field-reverse <span class="dv">6</span> <span class="dv">1</span> <span class="dv">4</span>) <span class="kw">=&gt;</span> <span class="dv">12</span>
(bit-field-reverse <span class="dv">1</span> <span class="dv">0</span> <span class="dv">32</span>) <span class="kw">=&gt;</span> <span class="ch">#x</span><span class="dv">80000000</span>
(bit-field-reverse <span class="dv">1</span> <span class="dv">0</span> <span class="dv">31</span>) <span class="kw">=&gt;</span> <span class="ch">#x</span><span class="dv">40000000</span>
(bit-field-reverse <span class="dv">1</span> <span class="dv">0</span> <span class="dv">30</span>) <span class="kw">=&gt;</span> <span class="ch">#x</span><span class="dv">20000000</span>
(bit-field-reverse <span class="ch">#x</span><span class="dv">140000000000000000000000000000000</span> <span class="dv">0</span> <span class="dv">129</span>) <span class="kw">=&gt;</span> <span class="dv">5</span></code></pre></div>
<h4 id="bits-list-i-len"><code>(bits-&gt;list i [ len ])</code></h4>
<h4 id="bits-vector-i-len"><code>(bits-&gt;vector i [ len ])</code></h4>
<p>Returns a list/vector of len booleans corresponding to each bit of the non-negative integer i, returning bit #0 as the first element, bit #1 as the second, and so on. #t is returned for each 1; #f for 0.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(bits-&gt;list <span class="ch">#b</span><span class="dv">1110101</span>)) <span class="kw">=&gt;</span> (<span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#t</span>)
(bits-&gt;list <span class="dv">3</span> <span class="dv">5</span>)) <span class="kw">=&gt;</span> (<span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#f</span> <span class="dv">#f</span>)
(bits-&gt;list <span class="dv">6</span> <span class="dv">4</span>)) <span class="kw">=&gt;</span> (<span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#f</span>)

(bits-&gt;vector <span class="ch">#b</span><span class="dv">1110101</span>)) <span class="kw">=&gt;</span> #(<span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#t</span>)</code></pre></div>
<h4 id="list-bits-list"><code>(list-&gt;bits list)</code></h4>
<h4 id="vector-bits-vector"><code>(vector-&gt;bits vector)</code></h4>
<p>Returns an integer formed from the booleans in list/vector, using the first element as bit #0, the second element as bit #1, and so on. It is an error if list/vector contains non-booleans. A 1 bit is coded for each #t; a 0 bit for #f. Note that the result is never a negative integer.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(list-&gt;bits &#39;(<span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#t</span>)) <span class="kw">=&gt;</span> <span class="ch">#b</span><span class="dv">1110101</span>
(list-&gt;bits &#39;(<span class="dv">#f</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#t</span>)) <span class="kw">=&gt;</span> <span class="ch">#b</span><span class="dv">111010100</span>
(list-&gt;bits &#39;(<span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span>)) <span class="kw">=&gt;</span> <span class="dv">6</span>
(list-&gt;bits &#39;(<span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#f</span>)) <span class="kw">=&gt;</span> <span class="dv">6</span>
(list-&gt;bits &#39;(<span class="dv">#f</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span>)) <span class="kw">=&gt;</span> <span class="dv">12</span>

(vector-&gt;bits &#39;#(<span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#t</span>)) <span class="kw">=&gt;</span> <span class="ch">#b</span><span class="dv">1110101</span>
(vector-&gt;bits &#39;#(<span class="dv">#f</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#t</span>)) <span class="kw">=&gt;</span> <span class="ch">#b</span><span class="dv">111010100</span>
(vector-&gt;bits &#39;#(<span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span>)) <span class="kw">=&gt;</span> <span class="dv">6</span>
(vector-&gt;bits &#39;#(<span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#f</span>)) <span class="kw">=&gt;</span> <span class="dv">6</span>
(vector-&gt;bits &#39;#(<span class="dv">#f</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span>)) <span class="kw">=&gt;</span> <span class="dv">12</span></code></pre></div>
<p>For positive integers, bits-&gt;list and list-&gt;bits are inverses in the sense of equal?, and so are bits-&gt;vector and vector-&gt;bits.</p>
<h4 id="bits-bool-..."><code>(bits bool ...)</code></h4>
<p>Returns the integer coded by the bool arguments. The first argument is bit #0, the second argument is bit #1, and so on. Note that the result is never a negative integer.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(bits <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#t</span>) <span class="kw">=&gt;</span> <span class="ch">#b</span><span class="dv">1110101</span>
(bits <span class="dv">#f</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#t</span>) <span class="kw">=&gt;</span> <span class="ch">#b</span><span class="dv">111010100</span></code></pre></div>
<h4 id="bitwise-fold-proc-seed-i"><code>(bitwise-fold proc seed i)</code></h4>
<p>For each bit b of i from bit #0 (inclusive) to bit (integer-length i) (exclusive), proc is called as (proc b r), where r is the current accumulated result. The initial value of r is seed, and the value returned by proc becomes the next accumulated result. When the last bit has been processed, the final accumulated result becomes the result of bitwise-fold.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(bitwise-fold <span class="kw">cons</span> &#39;() <span class="ch">#b</span><span class="dv">1010111</span>) <span class="kw">=&gt;</span> (<span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#t</span>)</code></pre></div>
<h4 id="bitwise-for-each-proc-i"><code>(bitwise-for-each proc i)</code></h4>
<p>Repeatedly applies proc to the bits of i starting with bit #0 (inclusive) and ending with bit (integer-length i) (exclusive). The values returned by proc are discarded. Returns an unspecified value.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">      (<span class="kw">let</span> ((count <span class="dv">0</span>))
        (bitwise-for-each (<span class="kw">lambda</span> (b) (<span class="kw">if</span> b (set! count (<span class="kw">+</span> count <span class="dv">1</span>))))
                          <span class="ch">#b</span><span class="dv">1010111</span>)
       count)</code></pre></div>
<h4 id="bitwise-unfold-stop-mapper-successor-seed"><code>(bitwise-unfold stop? mapper successor seed)</code></h4>
<p>Generates a non-negative integer bit by bit, starting with bit 0. If the result of applying stop? to the current state (whose initial value is seed) is true, return the currently accumulated bits as an integer. Otherwise, apply mapper to the current state to obtain the next bit of the result by interpreting a true value as a 1 bit and a false value as a 0 bit. Then get a new state by applying successor to the current state, and repeat this algorithm.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">  (bitwise-unfold (<span class="kw">lambda</span> (i) (<span class="kw">=</span> i <span class="dv">10</span>))
                  <span class="kw">even?</span>
                  (<span class="kw">lambda</span> (i) (<span class="kw">+</span> i <span class="dv">1</span>))
                  <span class="dv">0</span>)) <span class="kw">=&gt;</span> <span class="ch">#b</span><span class="dv">101010101</span></code></pre></div>
<h4 id="make-bitwise-generator-i"><code>(make-bitwise-generator i)</code></h4>
<p>Returns a SRFI 121 generator that generates all the bits of i starting with bit #0. Note that the generator is infinite.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">let</span> ((g (make-bitwise-generator <span class="ch">#b</span><span class="dv">110</span>)))
  (test <span class="dv">#f</span> (g))
  (test <span class="dv">#t</span> (g))
  (test <span class="dv">#t</span> (g))
  (test <span class="dv">#f</span> (g)))</code></pre></div>
<h2 id="srfi-srfi-158"><code>(srfi srfi-158)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-158/srfi-158.html">SRFI-158</a></p>
<h3 id="abstract-56">Abstract</h3>
<p>This SRFI defines utility procedures that create, transform, and consume generators. A generator is simply a procedure with no arguments that works as a source of values. Every time it is called, it yields a value. Generators may be finite or infinite; a finite generator returns an end-of-file object to indicate that it is exhausted. For example, read-char, read-line, and read are generators that generate characters, lines, and objects from the current input port. Generators provide lightweight laziness.</p>
<p>This SRFI also defines procedures that return accumulators. An accumulator is the inverse of a generator: it is a procedure of one argument that works as a sink of values.</p>
<h3 id="reference-56">Reference</h3>
<h4 id="generator">Generator</h4>
<h5 id="generator-arg-..."><code>(generator arg ...)</code></h5>
<p>The simplest finite generator. Generates each of its arguments in turn. When no arguments are provided, it returns an empty generator that generates no values.</p>
<h5 id="circular-generator-arg-..."><code>(circular-generator arg ...)</code></h5>
<p>The simplest infinite generator. Generates each of its arguments in turn, then generates them again in turn, and so on forever.</p>
<h5 id="make-iota-generator-count-start-step"><code>(make-iota-generator count [start [step]])</code></h5>
<p>Creates a finite generator of a sequence of count numbers. The sequence begins with start (which defaults to 0) and increases by step (which defaults to 1). If both start and step are exact, it generates exact numbers; otherwise it generates inexact numbers. The exactness of count doesn't affect the exactness of the results.</p>
<h5 id="make-range-generator-start-end-step"><code>(make-range-generator start [end [step]])</code></h5>
<p>Creates a generator of a sequence of numbers. The sequence begins with start, increases by step (default 1), and continues while the number is less than end, or forever if end is omitted. If both start and step are exact, it generates exact numbers; otherwise it generates inexact numbers. The exactness of end doesn't affect the exactness of the results.</p>
<h5 id="make-coroutine-generator-proc"><code>(make-coroutine-generator proc)</code></h5>
<p>Creates a generator from a coroutine.</p>
<p>The proc argument is a procedure that takes one argument, yield. When called, make-coroutine-generator immediately returns a generator g. When g is called, proc runs until it calls yield. Calling yield causes the execution of proc to be suspended, and g returns the value passed to yield.</p>
<p>Whether this generator is finite or infinite depends on the behavior of proc. If proc returns, it is the end of the sequence — g returns an end-of-file object from then on. The return value of proc is ignored.</p>
<p>The following code creates a generator that produces a series 0, 1, and 2 (effectively the same as (make-range-generator 0 3)) and binds it to g.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> g</span>
  (make-coroutine-generator
   (<span class="kw">lambda</span> (yield) (<span class="kw">let</span> loop ((i <span class="dv">0</span>))
               (when (<span class="kw">&lt;</span> i <span class="dv">3</span>) (yield i) (loop (<span class="kw">+</span> i <span class="dv">1</span>)))))))

(generator-&gt;list g) <span class="co">;; =&gt; (0 1 2)</span></code></pre></div>
<h5 id="list-generator-list"><code>(list-&gt;generator list)</code></h5>
<p>Convert <code>LIST</code> into a generator.</p>
<h5 id="vector-generator-vector-start-end"><code>(vector-&gt;generator vector [start [end]])</code></h5>
<h5 id="reverse-vector-generator-vector-start-end"><code>(reverse-vector-&gt;generator vector [start [end]])</code></h5>
<h5 id="string-generator-string-start-end"><code>(string-&gt;generator string [start [end]])</code></h5>
<h5 id="bytevector-generator-bytevector-start-end"><code>(bytevector-&gt;generator bytevector [start [end]])</code></h5>
<p>These procedures return generators that yield each element of the given argument. Mutating the underlying object will affect the results of the generator.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(generator-&gt;list (list-&gt;generator &#39;(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>)))
  <span class="co">;; =&gt; (1 2 3 4 5)</span>
(generator-&gt;list (vector-&gt;generator &#39;#(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>)))
  <span class="co">;; =&gt; (1 2 3 4 5)</span>
(generator-&gt;list (reverse-vector-&gt;generator &#39;#(<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span>)))
  <span class="co">;; =&gt; (5 4 3 2 1)</span>
(generator-&gt;list (string-&gt;generator <span class="st">&quot;abcde&quot;</span>))
  <span class="co">;; =&gt; (#\a #\b #\c #\d #\e)</span></code></pre></div>
<p>The generators returned by the constructors are exhausted once all elements are retrieved; the optional start-th and end-th arguments can limit the range the generator walks across.</p>
<p>For reverse-vector-&gt;generator, the first value is the element right before the end-th element, and the last value is the start-th element. For all the other constructors, the first value the generator yields is the start-th element, and it ends right before the end-th element.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(generator-&gt;list (vector-&gt;generator &#39;#(a b c d e) <span class="dv">2</span>))
  <span class="co">;; =&gt; (c d e)</span>
(generator-&gt;list (vector-&gt;generator &#39;#(a b c d e) <span class="dv">2</span> <span class="dv">4</span>))
  <span class="co">;; =&gt; (c d)</span>
(generator-&gt;list (reverse-vector-&gt;generator &#39;#(a b c d e) <span class="dv">2</span>))
  <span class="co">;; =&gt; (e d c)</span>
(generator-&gt;list (reverse-vector-&gt;generator &#39;#(a b c d e) <span class="dv">2</span> <span class="dv">4</span>))
  <span class="co">;; =&gt; (d c)</span>
(generator-&gt;list (reverse-vector-&gt;generator &#39;#(a b c d e) <span class="dv">0</span> <span class="dv">2</span>))
  <span class="co">;; =&gt; (b a)</span></code></pre></div>
<h5 id="make-for-each-generator-for-each-obj"><code>(make-for-each-generator for-each obj)</code></h5>
<p>A generator constructor that converts any collection obj to a generator that returns its elements using a for-each procedure appropriate for obj. This must be a procedure that when called as (for-each proc obj) calls proc on each element of obj. Examples of such procedures are for-each, string-for-each, and vector-for-each from R7RS. The value returned by for-each is ignored. The generator is finite if the collection is finite, which would typically be the case.</p>
<p>The collections need not be conventional ones (lists, strings, etc.) as long as for-each can invoke a procedure on everything that counts as a member. For example, the following procedure allows for-each-generator to generate the digits of an integer from least to most significant:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> </span>(for-each-digit proc n)
  (when (<span class="kw">&gt;</span> n <span class="dv">0</span>)
    (let-values (((div rem) (truncate/ n <span class="dv">10</span>)))
      (proc rem)
      (for-each-digit proc div))))</code></pre></div>
<h5 id="make-unfold-generator-stop-mapper-successor-seed"><code>(make-unfold-generator stop? mapper successor seed)</code></h5>
<p>A generator constructor similar to <code>(scheme list)</code> unfold.</p>
<p>The stop? predicate takes a seed value and determines whether to stop. The mapper procedure calculates a value to be returned by the generator from a seed value. The successor procedure calculates the next seed value from the current seed value.</p>
<p>For each call of the resulting generator, stop? is called with the current seed value. If it returns true, then the generator returns an end-of-file object. Otherwise, it applies mapper to the current seed value to get the value to return, and uses successor to update the seed value.</p>
<p>This generator is finite unless stop? never returns true.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(generator-&gt;list (make-unfold-generator
                      (<span class="kw">lambda</span> (s) (<span class="kw">&gt;</span> s <span class="dv">5</span>))
                      (<span class="kw">lambda</span> (s) (* s <span class="dv">2</span>))
                      (<span class="kw">lambda</span> (s) (<span class="kw">+</span> s <span class="dv">1</span>))
                      <span class="dv">0</span>))
  <span class="co">;; =&gt; (0 2 4 6 8 10)</span></code></pre></div>
<h5 id="gcons-item-...-generator"><code>(gcons* item ... generator)</code></h5>
<p>Returns a generator that adds items in front of gen. Once the items have been consumed, the generator is guaranteed to tail-call gen.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(generator-&gt;list (gcons* &#39;a &#39;b (make-range-generator <span class="dv">0</span> <span class="dv">2</span>)))
 <span class="co">;; =&gt; (a b 0 1)</span></code></pre></div>
<h5 id="gappend-generator-..."><code>(gappend generator ...)</code></h5>
<p>Returns a generator that yields the items from the first given generator, and once it is exhausted, from the second generator, and so on.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(generator-&gt;list (gappend (make-range-generator <span class="dv">0</span> <span class="dv">3</span>) (make-range-generator <span class="dv">0</span> <span class="dv">2</span>)))
 <span class="co">;; =&gt; (0 1 2 0 1)</span>

(generator-&gt;list (gappend))
 <span class="co">;; =&gt; ()</span></code></pre></div>
<h5 id="gflatten-generator"><code>(gflatten generator)</code></h5>
<p>Returns a generator that yields the elements of the lists produced by the given generator.</p>
<h5 id="ggroup-generator-k-padding"><code>(ggroup generator k [padding])</code></h5>
<p>Returns a generator that yields lists of k items from the given generator. If fewer than k elements are available for the last list, and padding is absent, the short list is returned; otherwise, it is padded by padding to length k.</p>
<h5 id="gmerge-less-than-generator1-..."><code>(gmerge less-than generator1 ...)</code></h5>
<p>Returns a generator that yields the items from the given generators in the order dictated by less-than. If the items are equal, the leftmost item is used first. When all of given generators are exhausted, the returned generator is exhausted also.</p>
<p>As a special case, if only one generator is given, it is returned.</p>
<h5 id="gmap-proc-generator-..."><code>(gmap proc generator ...)</code></h5>
<p>When only one generator is given, returns a generator that yields the items from the given generator after invoking proc on them.</p>
<p>When more than one generator is given, each item of the resulting generator is a result of applying proc to the items from each generator. If any of input generator is exhausted, the resulting generator is also exhausted.</p>
<p>Note: This differs from generator-map-&gt;list, which consumes all values at once and returns the results as a list, while gmap returns a generator immediately without consuming input.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(generator-&gt;list (gmap <span class="kw">-</span> (make-range-generator <span class="dv">0</span> <span class="dv">3</span>)))
 <span class="co">;; =&gt; (0 -1 -2)</span>

(generator-&gt;list (gmap <span class="kw">cons</span> (generator <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>) (generator <span class="dv">4</span> <span class="dv">5</span>)))
 <span class="co">;; =&gt; ((1 . 4) (2 . 5))</span></code></pre></div>
<h5 id="gcombine-proc-seed-generator-generator2"><code>(gcombine proc seed generator generator2)</code></h5>
<p>A generator for mapping with state. It yields a sequence of sub-folds over proc.</p>
<p>The proc argument is a procedure that takes as many arguments as the input generators plus one. It is called as (proc v1 v2 … seed), where v1, v2, … are the values yielded from the input generators, and seed is the current seed value. It must return two values, the yielding value and the next seed. The result generator is exhausted when any of the genn generators is exhausted, at which time all the others are in an undefined state.</p>
<h5 id="gfilter-predicate-generator"><code>(gfilter predicate generator)</code></h5>
<h5 id="gremove-predicate-generator"><code>(gremove predicate generator)</code></h5>
<p>Returns generators that yield the items from the source generator, except those on which pred answers false or true respectively.</p>
<h5 id="gstate-filter-proc-seed-generator"><code>(gstate-filter proc seed generator)</code></h5>
<p>Returns a generator that obtains items from the source generator and passes an item and a state (whose initial value is seed) as arguments to proc. Proc in turn returns two values, a boolean and a new value of the state. If the boolean is true, the item is returned; otherwise, this algorithm is repeated until gen is exhausted, at which point the returned generator is also exhausted. The final value of the state is discarded.</p>
<h5 id="gtake-gen-k-padding"><code>(gtake gen k [padding])</code></h5>
<h5 id="gdrop-gen-k"><code>(gdrop gen k)</code></h5>
<p>These are generator analogues of SRFI 1 take and drop. Gtake returns a generator that yields (at most) the first k items of the source generator, while gdrop returns a generator that skips the first k items of the source generator.</p>
<p>These won't complain if the source generator is exhausted before generating k items. By default, the generator returned by gtake terminates when the source generator does, but if you provide the padding argument, then the returned generator will yield exactly k items, using the padding value as needed to provide sufficient additional values.</p>
<h5 id="gtake-while-pred-gen"><code>gtake-while pred gen</code></h5>
<h5 id="gdrop-while-pred-gen"><code>gdrop-while pred gen</code></h5>
<p>The generator analogues of SRFI-1 take-while and drop-while. The generator returned from gtake-while yields items from the source generator as long as pred returns true for each. The generator returned from gdrop-while first reads and discards values from the source generator while pred returns true for them, then starts yielding items returned by the source.</p>
<h5 id="gdelete-item-gen"><code>(gdelete item gen [=])</code></h5>
<p>Creates a generator that returns whatever gen returns, except for any items that are the same as item in the sense of =, which defaults to equal?. The = predicate is passed exactly two arguments, of which the first was generated by gen before the second.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(generator-&gt;list (gdelete <span class="dv">3</span> (generator <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">3</span> <span class="dv">6</span> <span class="dv">7</span>)))
  <span class="co">;; =&gt; (1 2 4 5 6 7)</span></code></pre></div>
<h5 id="gdelete-neighbor-dups-gen"><code>(gdelete-neighbor-dups gen [=])</code></h5>
<p>Creates a generator that returns whatever gen returns, except for any items that are equal to the preceding item in the sense of =, which defaults to equal?. The = predicate is passed exactly two arguments, of which the first was generated by gen before the second.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(generator-&gt;list (gdelete-neighbor-dups (list-&gt;generator &#39;(a a b c a a a d c))))
  <span class="co">;; =&gt; (a b c a d c)</span></code></pre></div>
<h5 id="gindex-value-gen-index-gen"><code>(gindex value-gen index-gen)</code></h5>
<p>Creates a generator that returns elements of value-gen specified by the indices (non-negative exact integers) generated by index-gen. It is an error if the indices are not strictly increasing, or if any index exceeds the number of elements generated by value-gen. The result generator is exhausted when either generator is exhausted, at which time the other is in an undefined state.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(generator-&gt;list (gindex (list-&gt;generator &#39;(a b c d e f))
                         (list-&gt;generator &#39;(<span class="dv">0</span> <span class="dv">2</span> <span class="dv">4</span>))))
  <span class="co">;; =&gt; (a c e)</span></code></pre></div>
<h5 id="gselect-value-gen-truth-gen"><code>(gselect value-gen truth-gen)</code></h5>
<p>Creates a generator that returns elements of value-gen that correspond to the values generated by truth-gen. If the current value of truth-gen is true, the current value of value-gen is generated, but otherwise not. The result generator is exhausted when either generator is exhausted, at which time the other is in an undefined state.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(generator-&gt;list (gselect (list-&gt;generator &#39;(a b c d e f))
                          (list-&gt;generator &#39;(<span class="dv">#t</span> <span class="dv">#f</span> <span class="dv">#f</span> <span class="dv">#t</span> <span class="dv">#t</span> <span class="dv">#f</span>))))
  <span class="co">;; =&gt; (a d e)</span></code></pre></div>
<h5 id="generator-list-generator-k"><code>(generator-&gt;list generator [k])</code></h5>
<p>Reads items from generator and returns a newly allocated list of them. By default, it reads until the generator is exhausted.</p>
<p>If an optional argument k is given, it must be a non-negative integer, and the list ends when either k items are consumed, or generator is exhausted; therefore generator can be infinite in this case.</p>
<h5 id="generator-reverse-list-generator-k"><code>(generator-&gt;reverse-list generator [k])</code></h5>
<p>Reads items from generator and returns a newly allocated list of them in reverse order. By default, this reads until the generator is exhausted.</p>
<p>If an optional argument k is given, it must be a non-negative integer, and the list ends when either k items are read, or generator is exhausted; therefore generator can be infinite in this case.</p>
<h5 id="generator-vector-generator-k"><code>(generator-&gt;vector generator [k])</code></h5>
<p>Reads items from generator and returns a newly allocated vector of them. By default, it reads until the generator is exhausted.</p>
<p>If an optional argument k is given, it must be a non-negative integer, and the list ends when either k items are consumed, or generator is exhausted; therefore generator can be infinite in this case.</p>
<h5 id="generator-vector-vector-at-generator"><code>(generator-&gt;vector! vector at generator)</code></h5>
<p>Reads items from generator and puts them into vector starting at index at, until vector is full or generator is exhausted. Generator can be infinite. The number of elements generated is returned.</p>
<h5 id="generator-string-generator-k"><code>(generator-&gt;string generator [k])</code></h5>
<p>Reads items from generator and returns a newly allocated string of them. It is an error if the items are not characters. By default, it reads until the generator is exhausted.</p>
<p>If an optional argument k is given, it must be a non-negative integer, and the string ends when either k items are consumed, or generator is exhausted; therefore generator can be infinite in this case.</p>
<h5 id="generator-fold-proc-seed-generator-..."><code>(generator-fold proc seed generator ...)</code></h5>
<p>Works like <code>(scheme list)</code> fold on the values generated by the generator arguments.</p>
<p>When one generator is given, for each value v generated by gen, proc is called as (proc v r), where r is the current accumulated result; the initial value of the accumulated result is seed, and the return value from proc becomes the next accumulated result. When gen is exhausted, the accumulated result at that time is returned from generator-fold.</p>
<p>When more than one generator is given, proc is invoked on the values returned by all the generator arguments followed by the current accumulated result. The procedure terminates when any of the genn generators is exhausted, at which time all the others are in an undefined state.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(with-input-from-string <span class="st">&quot;a b c d e&quot;</span>
  (<span class="kw">lambda</span> () (generator-fold <span class="kw">cons</span> &#39;z <span class="kw">read</span>)))
  <span class="co">;; =&gt; (e d c b a . z)</span></code></pre></div>
<h5 id="generator-for-each-proc-generator-..."><code>(generator-for-each proc generator ...)</code></h5>
<p>A generator analogue of for-each that consumes generated values using side effects. Repeatedly applies proc on the values yielded by gen, gen2 … until any one of the generators is exhausted, at which time all the others are in an undefined state. The values returned from proc are discarded. Returns an unspecified value.</p>
<h5 id="generator-map-list-proc-generator-..."><code>(generator-map-&gt;list proc generator ...)</code></h5>
<p>A generator analogue of map that consumes generated values, processes them through a mapping function, and returns a list of the mapped values. Repeatedly applies proc on the values yielded by gen, gen2 … until any one of the generators is exhausted, at which time all the others are in an undefined state. The values returned from proc are accumulated into a list, which is returned.</p>
<h5 id="generator-find-predicate-generator"><code>(generator-find predicate generator)</code></h5>
<p>Returns the first item from the generator gen that satisfies the predicate pred, or #f if no such item is found before gen is exhausted. If gen is infinite, generator-find will not return if it cannot find an appropriate item.</p>
<h5 id="generator-count-predicate-generator"><code>(generator-count predicate generator)</code></h5>
<p>Returns the number of items available from the generator gen that satisfy the predicate pred.</p>
<h5 id="generator-any-predicate-generator"><code>(generator-any predicate generator)</code></h5>
<p>Applies predicate to each item from gen. As soon as it yields a true value, the value is returned without consuming the rest of gen. If gen is exhausted, returns #f.</p>
<h5 id="generator-every-predicate-generator"><code>(generator-every predicate generator)</code></h5>
<p>Applies pred to each item from gen. As soon as it yields a false value, the value is returned without consuming the rest of gen. If gen is exhausted, returns the last value returned by pred, or #t if pred was never called.</p>
<h5 id="generator-unfold-gen-unfold-arg-..."><code>(generator-unfold gen unfold arg ...)</code></h5>
<p>Equivalent to <code>(unfold eof-object? (lambda (x) x) (lambda (x) (gen)) (gen) arg ...)</code>. The values of gen are unfolded into the collection that unfold creates.</p>
<p>The signature of the unfold procedure is (unfold stop? mapper successor seed args ...). Note that the vector-unfold and vector-unfold-right of SRFI 43 and SRFI 133 do not have this signature and cannot be used with this procedure. To unfold into a vector, use SRFI 1's unfold and then apply list-&gt;vector to the result.</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme"><span class="co">;; Iterates over string and unfolds into a list using SRFI 1 unfold</span>
(generator-unfold (make-for-each-generator string-for-each <span class="st">&quot;abc&quot;</span>) unfold)
<span class="co">;; =&gt; (#\a #\b #\c)</span></code></pre></div>
<h4 id="accumulator">Accumulator</h4>
<h5 id="make-accumulator-kons-knil-finalizer"><code>(make-accumulator kons knil finalizer)</code></h5>
<p>Returns an accumulator that, when invoked on an object other than an end-of-file object, invokes kons on its argument and the accumulator's current state, using the same order as a function passed to fold. It then sets the accumulator's state to the value returned by kons and returns an unspecified value. The initial state of the accumulator is set to knil. However, if an end-of-file object is passed to the accumulator, it returns the result of tail-calling the procedure finalizer on the state. Repeated calls with an end-of-file object will reinvoke finalizer.</p>
<h5 id="count-accumulator"><code>(count-accumulator)</code></h5>
<p>Returns an accumulator that, when invoked on an object, adds 1 to a count inside the accumulator and returns an unspecified value. However, if an end-of-file object is passed, the accumulator returns the count.</p>
<h5 id="list-accumulator"><code>(list-accumulator)</code></h5>
<p>Returns an accumulator that, when invoked on an object, adds that object to a list inside the accumulator in order of accumulation and returns an unspecified value. However, if an end-of-file object is passed, the accumulator returns the list.</p>
<h5 id="reverse-list-accumulator"><code>(reverse-list-accumulator)</code></h5>
<p>Returns an accumulator that, when invoked on an object, adds that object to a list inside the accumulator in reverse order of accumulation and returns an unspecified value. However, if an end-of-file object is passed, the accumulator returns the list.</p>
<h5 id="vector-accumulator"><code>(vector-accumulator)</code></h5>
<p>Returns an accumulator that, when invoked on an object, adds that object to a vector inside the accumulator in order of accumulation and returns an unspecified value. However, if an end-of-file object is passed, the accumulator returns the vector.</p>
<h5 id="reverse-vector-accumulator"><code>(reverse-vector-accumulator)</code></h5>
<p>Returns an accumulator that, when invoked on an object, adds that object to a vector inside the accumulator in reverse order of accumulation and returns an unspecified value. However, if an end-of-file object is passed, the accumulator returns the vector.</p>
<h5 id="vector-accumulator-vector-at"><code>(vector-accumulator! vector at)</code></h5>
<p>Returns an accumulator that, when invoked on an object, adds that object to consecutive positions of vector starting at at in order of accumulation. It is an error to try to accumulate more objects than vector will hold. An unspecified value is returned. However, if an end-of-file object is passed, the accumulator returns vector.</p>
<h5 id="string-accumulator"><code>(string-accumulator)</code></h5>
<p>Returns an accumulator that, when invoked on a character, adds that character to a string inside the accumulator in order of accumulation and returns an unspecified value. However, if an end-of-file object is passed, the accumulator returns the string.</p>
<h5 id="bytevector-accumulator"><code>(bytevector-accumulator)</code></h5>
<p>Returns an accumulator that, when invoked on a byte, adds that integer to a bytevector inside the accumulator in order of accumulation and returns an unspecified value. However, if an end-of-file object is passed, the accumulator returns the bytevector.</p>
<h5 id="bytevector-accumulator-bytevector-at"><code>(bytevector-accumulator! bytevector at)</code></h5>
<p>Returns an accumulator that, when invoked on a byte, adds that byte to consecutive positions of bytevector starting at at in order of accumulation. It is an error to try to accumulate more bytes than vector will hold. An unspecified value is returned. However, if an end-of-file object is passed, the accumulator returns bytevector.</p>
<h5 id="sum-accumulator"><code>(sum-accumulator)</code></h5>
<p>Returns an accumulator that, when invoked on a number, adds that number to a sum inside the accumulator in order of accumulation and returns an unspecified value. However, if an end-of-file object is passed, the accumulator returns the sum.</p>
<h5 id="product-accumulator">`(product-accumulator)</h5>
<p>Returns an accumulator that, when invoked on a number, multiplies that number to a product inside the accumulator in order of accumulation and returns an unspecified value. However, if an end-of-file object is passed, the accumulator returns the product.</p>
<h2 id="srfi-srfi-167"><code>(srfi srfi-167)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-167/">SRFI-167</a>.</p>
<h3 id="abstract-57">Abstract</h3>
<p>This library describes an interface for an ordered key-value store. There is a memory backend and a wiredtiger backend.</p>
<p>This library contains four modules:</p>
<ul>
<li><code>(srfi srfi-167 pack)</code></li>
<li><code>(srfi srfi-167 engine)</code></li>
<li><code>(srfi srfi-167 memory)</code></li>
<li><code>(srfi srfi-167 wiredtiger)</code></li>
</ul>
<h2 id="srfi-srfi-167-pack"><code>(srfi srfi-167 pack)</code></h2>
<h3 id="abstract-58">Abstract</h3>
<p>This library allows to pack and unpack Scheme objects from and to bytevectors while preserving their natural order.</p>
<h3 id="reference-57">Reference</h3>
<h4 id="pack-.-args-bytevector"><code>(pack . args)</code> → <code>bytevector</code></h4>
<h4 id="unpack-bytevector"><code>(unpack bytevector)</code></h4>
<h2 id="srfi-srfi-167-engine"><code>(srfi srfi-167 engine)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-167/">SRFI-167</a>.</p>
<h3 id="abstract-59">Abstract</h3>
<p>This library describe a typeclass object for ordered key-value stores. It allows database abstraction to switch between ordered key-value store implementation easily.</p>
<h3 id="reference-58">Reference</h3>
<h4 id="make-engine-ref-set-delete-range-remove-range-prefix-range-hook-on-transaction-begin-hook-on-transaction-commit-pack-unpack"><code>(make-engine ref set delete range-remove range prefix-range hook-on-transaction-begin hook-on-transaction-commit pack unpack)</code></h4>
<p>Return an engine record instance.</p>
<h4 id="engine-obj"><code>(engine? obj)</code></h4>
<p>Return <code>#t</code> if <code>OBJ</code> is an engine record instance. Otherwise, it returns <code>#f</code>.</p>
<h4 id="engine-ref-engine"><code>(engine-ref engine)</code></h4>
<p>Return the procedure <code>okvs-ref</code>.</p>
<h4 id="engine-set-engine"><code>(engine-set engine)</code></h4>
<p>Return the procedure <code>okvs-set!</code>.</p>
<h4 id="engine-delete-engine"><code>(engine-delete engine)</code></h4>
<p>Return the procedure <code>okvs-delete!</code>.</p>
<h4 id="engine-range-remove-engine"><code>(engine-range-remove engine)</code></h4>
<p>Return the procedure <code>okvs-range-remove!</code>.</p>
<h4 id="engine-range-engine"><code>(engine-range engine)</code></h4>
<p>Return the procedure <code>okvs-range</code>.</p>
<h4 id="engine-prefix-range-engine"><code>(engine-prefix-range engine)</code></h4>
<p>Return the procedure <code>okvs-prefix-range</code>.</p>
<h4 id="engine-hook-on-transaction-begin-engine"><code>(engine-hook-on-transaction-begin engine)</code></h4>
<p>Return the procedure <code>okvs-hook-on-transaction-begin</code>.</p>
<h4 id="engine-hook-on-transaction-commit-engine"><code>(engine-hook-on-transaction-commit engine)</code></h4>
<p>Return the procedure okvs-hook-on-transaction-commit.</p>
<h4 id="engine-pack-engine"><code>(engine-pack engine)</code></h4>
<p>Return a packing procedure that allows to encode some scheme types into bytevectors preserving their natural order. The supported Scheme types is implementation dependent.</p>
<h4 id="engine-unpack-engine"><code>(engine-unpack engine)</code></h4>
<p>Return an unpacking procedure that will decode a bytevector encoded with the above <code>pack</code> procedure into a Scheme object.</p>
<h2 id="srfi-srfi-167-memory"><code>(srfi srfi-167 memory)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-167/">SRFI-167</a>.</p>
<h3 id="abstract-60">Abstract</h3>
<p>TODO</p>
<h3 id="reference-59">Reference</h3>
<h4 id="okvs-open-home-config"><code>(okvs-open home [config])</code></h4>
<p>TODO</p>
<h4 id="okvs-obj"><code>(okvs? obj)</code></h4>
<p>TODO</p>
<h4 id="okvs-close-okvs-config"><code>(okvs-close okvs [config])</code></h4>
<p>TODO</p>
<h4 id="make-default-state"><code>(make-default-state)</code></h4>
<p>TODO</p>
<h4 id="okvs-transaction-obj"><code>(okvs-transaction? obj)</code></h4>
<p>TODO</p>
<h4 id="okvs-transaction-state-transaction"><code>(okvs-transaction-state transaction)</code></h4>
<p>TODO</p>
<h4 id="okvs-in-transaction-okvs-proc-failure-success-make-sate-config"><code>(okvs-in-transaction okvs proc [failure [success [make-sate [config]]]])</code></h4>
<p>TODO</p>
<h4 id="okvs-ref-okvs-or-transaction-key"><code>(okvs-ref okvs-or-transaction key)</code></h4>
<p>TODO</p>
<h4 id="okvs-set-okvs-or-transaction-key-value"><code>(okvs-set! okvs-or-transaction key value)</code></h4>
<p>TODO</p>
<h4 id="okvs-delete-okvs-or-transaction-key"><code>(okvs-delete! okvs-or-transaction key)</code></h4>
<p>TODO</p>
<h4 id="okvs-range-remove-okvs-or-transaction-start-key-start-include-end-key-end-include"><code>(okvs-range-remove! okvs-or-transaction start-key start-include? end-key end-include?)</code></h4>
<p>TODO</p>
<h4 id="okvs-range-okvs-or-transaction-start-key-start-include-end-key-end-include-config">`(okvs-range okvs-or-transaction start-key start-include? end-key end-include? [CONFIG])</h4>
<p>TODO</p>
<h4 id="okvs-prefix-range-okvs-or-transaction-prefix-config"><code>(okvs-prefix-range okvs-or-transaction prefix [config])</code></h4>
<p>TODO</p>
<h4 id="okvs-hook-on-transaction-begin-okvs"><code>(okvs-hook-on-transaction-begin okvs)</code></h4>
<p>TODO</p>
<h4 id="okvs-hook-on-transaction-commit-okvs"><code>(okvs-hook-on-transaction-commit okvs)</code></h4>
<p>TODO</p>
<h4 id="make-default-engine"><code>(make-default-engine)</code></h4>
<p>Return an engine for the current okvs implementation.</p>
<h2 id="srfi-srfi-173"><code>(srfi srfi-173)</code></h2>
<p>This is based on <a href="https://srfi.schemers.org/srfi-173/">SRFI-173</a>.</p>
<h3 id="abstract-61">Abstract</h3>
<p>This library describes a mechanism known as hooks. Hooks are a certain kind of extension point in a program that allows interleaving the execution of arbitrary code with the execution of the program without introducing any coupling between the two.</p>
<h3 id="reference-60">Reference</h3>
<h3 id="make-hook-arity"><code>(make-hook arity)</code></h3>
<p>Create a hook object for storing procedures of ARITY. The return value is a hook object.</p>
<h3 id="hook-obj"><code>(hook? obj)</code></h3>
<p>Return #t if obj is a hook. Otherwise, it returns #f.</p>
<h3 id="list-hook-arity-lst"><code>(list-&gt;hook arity lst)</code></h3>
<p>Create a hook with the given procedures LST that must have an arity equal to ARITY. The return value is a hook object.</p>
<h3 id="list-hook-hook-lst"><code>(list-&gt;hook! hook lst)</code></h3>
<p>Replace procedures in HOOK by the procedures in LST. The return value is unspecified</p>
<h3 id="hook-add-hook-proc"><code>(hook-add! hook proc)</code></h3>
<p>Add the procedure PROC to the HOOK object. The return value is not specified. An implementation may check that the arity of PROC is equal to the arity of the HOOK.</p>
<h3 id="hook-delete-hook-proc"><code>(hook-delete! hook proc)</code></h3>
<p>Delete the procedure PROC from the HOOK object. The return value is not specified.</p>
<h3 id="hook-reset-hook"><code>(hook-reset! hook)</code></h3>
<p>Remove all procedures from the HOOK object. The return value is not specified.</p>
<h3 id="hook-list-hook"><code>(hook-&gt;list hook)</code></h3>
<p>Convert the list of procedures of HOOK object to a list.</p>
<h3 id="hook-run-hook-.-args"><code>(hook-run hook . args)</code></h3>
<p>Apply all procedures from HOOK to the arguments ARGS. The order of the procedure application is not specified. The return value is not specified. The length of ARGS must be equal to the arity of the HOOK object.</p>
<h2 id="arew-stream"><code>(arew stream)</code></h2>
<h3 id="abstract-62">Abstract</h3>
<p>Wanna be fast and functional streams.</p>
<h3 id="reference-61">Reference</h3>
<h4 id="list-stream-lst"><code>(list-&gt;stream lst)</code></h4>
<p>TODO</p>
<h4 id="stream-list-stream"><code>(stream-&gt;list stream)</code></h4>
<p>TODO</p>
<h4 id="stream-null-2"><code>(stream-null)</code></h4>
<p>Return an empty stream.</p>
<h4 id="stream-empty-stream"><code>(stream-empty? stream)</code></h4>
<p>Return <code>#t</code> if the stream is empty. Otherwise, return <code>#f</code>.</p>
<h4 id="stream-car-stream"><code>(stream-car stream)</code></h4>
<p>Return the first element of <code>STREAM</code>.</p>
<h4 id="stream-map-proc-stream"><code>(stream-map proc stream)</code></h4>
<p>Return a stream where <code>PROC</code> was applied to every value of <code>STREAM</code>.</p>
<h4 id="stream-for-each-proc-stream"><code>(stream-for-each proc stream)</code></h4>
<p>Apply <code>PROC</code> to every value of stream. The return value is undefined.</p>
<h4 id="stream-filter-predicate-stream"><code>(stream-filter predicate? stream)</code></h4>
<p>Return a stream of values from <code>STREAM</code> for which <code>PREDICATE?</code> return <code>#t</code>.</p>
<h4 id="stream-apppend-.-streams"><code>(stream-apppend . streams)</code></h4>
<p>Return a stream made of the given <code>STREAMS</code>.</p>
<h4 id="stream-concatenate-stream"><code>(stream-concatenate stream)</code></h4>
<p><code>STREAM</code> must be stream of stream. Return a stream of the values.</p>
<h2 id="arew-data-json"><code>(arew data json)</code></h2>
<h3 id="abstract-63">Abstract</h3>
<p>Provide a <code>(json-&gt;scm string)</code> procedure that parse a json string into a Scheme object.</p>
<h3 id="reference-62">Reference</h3>
<h4 id="json-scm-string"><code>(json-&gt;scm string)</code></h4>
<p>Return a Scheme object representation of the JSON <code>STRING</code>. In case of error, return <code>#f</code>.</p>
<p>Arrays are represented as a list. JSON Objects are represented as an association list prefixed with a star symbol where keys are symbols.</p>
<h2 id="arew-data-parser-combinator"><code>(arew data parser combinator)</code></h2>
<h3 id="abstract-64">Abstract</h3>
<p>parser combinators inspired from the following projects:</p>
<ul>
<li>https://epsil.github.io/gll/</li>
<li>https://docs.racket-lang.org/parsack/index.html</li>
<li>https://docs.racket-lang.org/megaparsack/</li>
<li>https://git.dthompson.us/guile-parser-combinators.git</li>
<li>https://gitlab.com/tampe/stis-parser</li>
</ul>
<h3 id="reference-63">Reference</h3>
<h4 id="make-pseudo-xchar-char"><code>(make-pseudo-xchar char)</code></h4>
<p>Make an extended character without line, column or offset information.</p>
<h4 id="parse-parser-stream"><code>(parse parser stream)</code></h4>
<p>Parse <code>STREAM</code> using <code>PARSER</code>. Return <code>#f</code> in case of error.</p>
<h4 id="parse-any-stream"><code>(parse-any stream)</code></h4>
<p>Parser that succeed with anything in <code>STREAM</code>.</p>
<h4 id="parse-char-char"><code>(parse-char char)</code></h4>
<p>Parser that succeed with the given <code>CHAR</code></p>
<h4 id="parse-char-set-char-set"><code>(parse-char-set char-set)</code></h4>
<p>Parser that succeed with the given <code>CHAR-SET</code> from <code>(scheme charset)</code>.</p>
<h4 id="parse-each-parser-...-syntax"><code>(parse-each &lt;parser&gt; ...)</code> syntax</h4>
<p>Parser that succeed if every parser succeed in sequence.</p>
<h4 id="parse-either-parser-...-syntax"><code>(parse-either &lt;parser&gt; ...)</code> syntax</h4>
<p>Parser that succeed when the first given parser succeed.</p>
<h4 id="parse-lift-proc-parser"><code>(parse-lift proc parser)</code></h4>
<p>Apply <code>PROC</code> to the result of <code>PARSER</code>.</p>
<h4 id="parse-maybe-parser"><code>(parse-maybe parser)</code></h4>
<p>If <code>PARSER</code> succeed return its result, otherwise return <code>#f</code> as result.</p>
<h4 id="parse-one-or-more-parser"><code>(parse-one-or-more parser)</code></h4>
<p>Parser that succeed if <code>PARSER</code> succeed one or more time.</p>
<h4 id="parse-only-predicate-parser"><code>(parse-only predicate? parser)</code></h4>
<p>Parser that succeed only when the result of <code>PARSER</code> returns <code>#t</code> when passed to <code>PREDICATE?</code>.</p>
<h4 id="parse-return-value"><code>(parse-return value</code>)</h4>
<p>Parser that always succeed with <code>VALUE</code> as result.</p>
<h4 id="parse-xstring-string"><code>(parse-xstring string)</code></h4>
<p>Parser that succeed when <code>STRING</code> can be parsed as a sequence of extended characters.</p>
<h4 id="parse-when-predicate-parser"><code>(parse-when predicate? parser)</code></h4>
<p>Parser that succeed when the next value returns <code>#t</code> when passed as argument to <code>PREDICATE?</code>. Return the result of <code>PARSER</code>.</p>
<h4 id="parse-when-parser-other"><code>(parse-when* parser other)</code></h4>
<p>More general form of <code>parse-when</code>. If <code>PARSER</code> succeed, return the result of <code>OTHER</code> parser.</p>
<h4 id="parse-unless-predicate-parser"><code>(parse-unless predicate? parser)</code></h4>
<p>Parser that succeed unless the next value returns <code>#t</code> when passed as argument to <code>PREDICATE?</code>. Return the result of <code>PARSER</code>.</p>
<h4 id="parse-unless-parser-other"><code>(parse-unless* parser other)</code></h4>
<p>More general form of <code>parse-unless</code>. If <code>PARSER</code> fails, return the result of <code>OTHER</code> parser.</p>
<h4 id="parse-xchar-char"><code>(parse-xchar char)</code></h4>
<p>Parser that succeed if the next value is an extended character that is a <code>CHAR</code>.</p>
<h4 id="parse-zero-or-more-parser"><code>(parse-zero-or-more parser)</code></h4>
<p>Succeed if <code>PARSER</code> succeed zero or more time.</p>
<h4 id="string-stream-string"><code>(string-&gt;stream string)</code></h4>
<p>Create a stream of extended characters based on <code>STRING</code>.</p>
<h4 id="xchar-char-xchar"><code>(xchar-char xchar)</code></h4>
<p>Return the character of <code>XCHAR</code>.</p>
<h4 id="xchar-obj"><code>(xchar? obj)</code></h4>
<p>Return <code>#t</code> if <code>OBJ</code> is an extended character. Otherwise, return <code>#f</code>.</p>
<h2 id="arew-data-base-lsm"><code>(arew data base lsm)</code></h2>
<h3 id="abstract-65">Abstract</h3>
<p>LSM is an embedded database library for key-value data, roughly similar in scope to Berkeley DB, LevelDB or KyotoCabinet. Both keys and values are specified and stored as byte arrays. Duplicate keys are not supported. Keys are always sorted in <code>memcmp()</code> order. LSM supports the following operations for the manipulation and query of database data:</p>
<ul>
<li>Writing a new key and value into the database.</li>
<li>Deleting an existing key from the database.</li>
<li>Deleting a range of keys from the database.</li>
<li>Querying the database for a specific key.</li>
<li>Iterating through a range of database keys (either forwards or backwards).</li>
</ul>
<p>Other salient features are:</p>
<ul>
<li><p>A single-writer/multiple-reader MVCC based transactional concurrency model. SQL style nested sub-transactions are supported. Clients may concurrently access a single LSM database from within a single process or multiple application processes.</p></li>
<li><p>An entire database is stored in a single file on disk.</p></li>
<li><p>Data durability in the face of application or power failure. LSM may optionally use a write-ahead log file when writing to the database to ensure committed transactions are not lost if an application or power failure occurs.</p></li>
</ul>
<p>See <a href="https://sqlite.org/src4/doc/trunk/www/lsmusr.wiki">sqlite's lsm extension documentation</a>.</p>
<h3 id="reference-64">Reference</h3>
<h4 id="lsm-new"><code>(lsm-new)</code></h4>
<p>Open a database connection handle.</p>
<h4 id="lsm-close-db"><code>(lsm-close db)</code></h4>
<p>Close a database connection handle.</p>
<h4 id="lsm-config-db-config-value"><code>(lsm-config db config value)</code></h4>
<p>Configuring a database connection.</p>
<p>TODO: document configuration.</p>
<h4 id="lsm-open-db-filename"><code>(lsm-open db filename)</code></h4>
<p>Connect to a database.</p>
<h4 id="lsm-begin-db-level"><code>(lsm-begin db level)</code></h4>
<p>Open a transaction or sub-transaction. To open a top-level transaction pass <code>1</code> as <code>LEVEL</code>. Passing <code>0</code> as <code>LEVEL</code> is no-op.</p>
<h4 id="lsm-commit-db-level"><code>(lsm-commit db level)</code></h4>
<p>Commit transaction and any sub-transactions. A successfull call to <code>lsm-commit</code> ensures that there are at most <code>LEVEL</code> nested transactions open. To commit a top-level transaction, pass <code>0</code> as <code>LEVEL</code>. To commit all sub-transactions inside the main transaction, pass <code>1</code> as <code>LEVEL</code>.</p>
<h4 id="lsm-rollback-db-level"><code>(lsm-rollback db level)</code></h4>
<p>Roll back transaction and sub-transactions. A successful call to <code>lsm-rollback</code> restores the database to the state it was in when the <code>LEVEL</code>'th nested sub-transaction (if any) was first opened. And then closes transactions to ensure that there are at most <code>LEVEL</code> nested transactions open. Passing <code>0</code> as <code>LEVEL</code> rolls back and closes the top-level transaction. <code>LEVEL</code> equal to <code>1</code> also rolls back the top-level transaction, but leaves it open. <code>LEVEL</code> equal to <code>2</code> rolls back the sub-transaction nested directly inside the top-level transaction (and leaves it open).</p>
<h4 id="lsm-insert-db-key-value"><code>(lsm-insert db key value)</code></h4>
<p>Write a new value into the database where <code>KEY</code> and <code>VALUE</code> are bytevectors. If a value with a duplicate key already exists it is replaced.</p>
<h4 id="lsm-delete-db-key"><code>(lsm-delete db key)</code></h4>
<p>Delete a value from the database. No error is returned if the specified <code>KEY</code> does not exist in the database.</p>
<h4 id="lsm-delete-range-db-key1-key2"><code>(lsm-delete-range db key1 key2)</code></h4>
<p>TODO: Implement it.</p>
<h4 id="lsm-cursor-open-db"><code>(lsm-cursor-open db)</code></h4>
<p>Open a cursor.</p>
<h4 id="lsm-cursor-close-cursor"><code>(lsm-cursor-close cursor)</code></h4>
<p>Close a cursor.</p>
<h4 id="lsm-cursor-seek-cursor-key-seek"><code>(lsm-cursor-seek cursor key seek)</code></h4>
<p>Position the cursor at <code>KEY</code> according to <code>SEEK</code> symbol.</p>
<h4 id="lsm-cursor-first-cursor"><code>(lsm-cursor-first cursor)</code></h4>
<p>Position the cursor at the first value.</p>
<h4 id="lsm-cursor-last-cursor"><code>(lsm-cursor-last cursor)</code></h4>
<p>Position the cursor at the last value.</p>
<h4 id="lsm-cursor-next-cursor"><code>(lsm-cursor-next cursor)</code></h4>
<p>Move the cursor at the next value.</p>
<h4 id="lsm-cursor-prev-cursor"><code>(lsm-cursor-prev cursor)</code></h4>
<p>Move the cursor at the previous value.</p>
<h4 id="lsm-cursor-valid-cursor"><code>(lsm-cursor-valid? cursor)</code></h4>
<p>Determine whether or not the cursor currently points to a valid entry.</p>
<h4 id="lsm-cursor-key-cursor"><code>(lsm-cursor-key cursor)</code></h4>
<p>Retrieve the key as a bytevector.</p>
<h4 id="lsm-cursor-value-cursor"><code>(lsm-cursor-value cursor)</code></h4>
<p>Retrieve the value as a bytevector. ## <code>(cffi wiredtiger)</code></p>
<h3 id="connection-obj"><code>(connection? obj)</code></h3>
<p>Return <code>#t</code> if <code>OBJ</code> is a connection, otherwise <code>#f</code>.</p>
<h3 id="connection-open-path-config"><code>(connection-open path config)</code></h3>
<p>Open a new connection at <code>PATH</code> using <code>CONFIG</code>.</p>
<h3 id="connection-close-connection-config"><code>(connection-close connection config)</code></h3>
<p>Close <code>CONNECTION</code> using <code>CONFIG</code>.</p>
<h3 id="session-obj"><code>(session? obj)</code></h3>
<p>Return <code>#t</code> if <code>OBJ</code> is a session, otherwise <code>#f</code>.</p>
<h3 id="session-open-connection-config"><code>(session-open connection config)</code></h3>
<p>Open a session against <code>CONNECTION</code> using <code>CONFIG</code>.</p>
<h3 id="session-close-session-config"><code>(session-close session config)</code></h3>
<p>Close <code>SESSION</code> using <code>CONFIG</code>.</p>
<h3 id="session-create-session-name"><code>(session-create session name)</code></h3>
<p>Create a table named <code>NAME</code> using <code>SESSION</code> with a bytevector column as key and value.</p>
<h3 id="session-reset-session"><code>(session-reset session)</code></h3>
<p>Reset <code>SESSION</code>.</p>
<h3 id="session-transaction-begin-session-config"><code>(session-transaction-begin session config)</code></h3>
<p>Begin transaction against <code>SESSION</code> using <code>CONFIG</code>.</p>
<h3 id="session-transaction-commit-session-config"><code>(session-transaction-commit session config)</code></h3>
<p>Commit transaction against <code>SESSION</code> using <code>CONFIG</code>.</p>
<h3 id="session-transaction-rollback-session-config"><code>(session-transaction-rollback session config)</code></h3>
<p>Rollback transaction against <code>SESSION</code> using <code>CONFIG</code>.</p>
<h3 id="cursor-open-session-uri-config"><code>(cursor-open session uri config)</code></h3>
<p>Open a cursor against <code>SESSION</code> at <code>URI</code> using <code>CONFIG</code>.</p>
<h3 id="cursor-cursor"><code>(cursor? cursor)</code></h3>
<p>Return <code>#t</code> if <code>CURSOR</code> is a cursor. Otherwise return <code>#f</code>.</p>
<h3 id="cursor-close-cursor"><code>(cursor-close cursor)</code></h3>
<p>Close <code>CURSOR</code>.</p>
<h3 id="cursor-uri-cursor"><code>(cursor-uri cursor)</code></h3>
<p>Return <code>CURSOR</code>'s uri.</p>
<h3 id="cursor-key-format-cursor"><code>(cursor-key-format cursor)</code></h3>
<p>Return <code>CURSOR</code>'s key format.</p>
<h3 id="cursor-value-format-cursor"><code>(cursor-value-format cursor)</code></h3>
<p>Return <code>CURSOR</code>'s value format.</p>
<h3 id="cursor-key-ref-cursor"><code>(cursor-key-ref cursor)</code></h3>
<p>Return the key pointed by <code>CURSOR</code> as a bytevector.</p>
<h3 id="cursor-value-ref-cursor"><code>(cursor-value-ref cursor)</code></h3>
<p>Return the value pointed by <code>CURSOR</code> as a bytevector.</p>
<h3 id="cursor-next-cursor"><code>(cursor-next? cursor)</code></h3>
<p>Move <code>CURSOR</code> to the next record, return <code>#t</code> if any. Otherwise it return <code>#f</code>.</p>
<h3 id="cursor-prev-cursor"><code>(cursor-prev? cursor)</code></h3>
<p>Move <code>CURSOR</code> to the previous record, return <code>#t</code> if any. Otherwise it return <code>#f</code>.</p>
<h3 id="cursor-reset-cursor"><code>(cursor-reset cursor)</code></h3>
<p>Reset <code>CURSOR</code>.</p>
<h3 id="cursor-search-cursor-key"><code>(cursor-search? cursor key)</code></h3>
<p>Try to position <code>CURSOR</code> at <code>KEY</code>. Return <code>#t</code> if it succeed. Otherwise it return <code>#f</code>.</p>
<h3 id="cursor-search-near-cursor-key"><code>(cursor-search-near cursor key)</code></h3>
<p>Try to position <code>CURSOR</code> near <code>KEY</code>. Return <code>'before</code>, <code>'exact</code> or <code>'after</code> depending on where the cursor is positioned. Otherwise it return <code>#f</code>.</p>
<h3 id="cursor-insert-cursor-key-value"><code>(cursor-insert cursor key value)</code></h3>
<p>Insert <code>KEY</code> and <code>VALUE</code> using <code>CURSOR</code>.</p>
<h3 id="cursor-update-cursor-key-value"><code>(cursor-update cursor key value)</code></h3>
<p>Update <code>KEY</code> with <code>VALUE</code> using <code>CURSORS</code>.</p>
<h3 id="cursor-remove-cursor-key"><code>(cursor-remove cursor key)</code></h3>
<p>Remove record that has <code>KEY</code> as key using <code>CURSOR</code>.</p>
<h2 id="arew-network-socket"><code>(arew network socket)</code></h2>
<h3 id="abstract-66">Abstract</h3>
<p>BSD Sockets</p>
<h3 id="reference-65">Reference</h3>
<h4 id="close-fd"><code>(close fd)</code></h4>
<p>Close the socket described by <code>FD</code>.</p>
<h4 id="socket-domain-type-protocol"><code>(socket domain type protocol)</code></h4>
<p><code>DOMAIN</code> can be one the following symbol:</p>
<ul>
<li><code>unspecified</code></li>
<li><code>unix</code> or <code>local</code></li>
<li><code>inet</code></li>
<li><code>inet6</code></li>
</ul>
<p><code>TYPE</code> can be one the following symbol:</p>
<ul>
<li><code>stream</code></li>
<li><code>datagram</code></li>
<li><code>raw</code></li>
<li><code>rdm</code></li>
<li><code>seqpacket</code></li>
<li><code>dccp</code></li>
<li><code>packet</code></li>
<li><code>close-on-exec</code></li>
<li><code>non-blocking</code></li>
</ul>
<p><code>PROTOCOL</code> can be one the following symbol:</p>
<ul>
<li><code>ipv4</code></li>
<li><code>icmp</code></li>
<li><code>igmp</code></li>
<li><code>ipip</code></li>
<li><code>gcp</code></li>
<li><code>egp</code></li>
<li><code>pup</code></li>
<li><code>udp</code></li>
<li><code>idp</code></li>
<li><code>tp</code></li>
<li><code>dccp</code></li>
<li><code>ipv6</code></li>
<li><code>rsvp</code></li>
<li><code>gre</code></li>
<li><code>esp</code></li>
<li><code>ah</code></li>
<li><code>beetph</code></li>
<li><code>encap</code></li>
<li><code>pim</code></li>
<li><code>comp</code></li>
<li><code>sctp</code></li>
<li><code>udplite</code></li>
<li><code>mpls</code></li>
<li><code>raw</code></li>
</ul>
<h4 id="connect-sockfd-address"><code>(connect sockfd address)</code></h4>
<p><code>SOCKFD</code> must be socket opened with <code>socket</code>. <code>ADDRESS</code> must be an association list with the following keys:</p>
<ul>
<li><code>family</code> only <code>inet</code> value is supported</li>
<li><code>port</code> a number below 65536</li>
<li><code>address</code> a string describing an ipv4 address.</li>
</ul>
<h4 id="getaddrinfo-node-service-hints"><code>(getaddrinfo node service hints)</code></h4>
<p><code>NODE</code>, <code>SERVICE</code> and <code>HINTS</code> may be false. If <code>HINTS</code> is provided it must be an association list with the following keys:</p>
<ul>
<li><code>flags</code></li>
<li><code>family</code></li>
<li><code>type</code></li>
<li><code>protocol</code></li>
</ul>
<p><code>flags</code> value can be one or more the following:</p>
<ul>
<li><code>passive</code></li>
<li><code>canonname</code></li>
<li><code>v4mapped</code></li>
<li><code>numerichost</code></li>
<li><code>all</code></li>
<li><code>addrconfig</code></li>
<li><code>idn</code></li>
<li><code>canonidn</code></li>
<li><code>idn-allow-unassigned</code></li>
<li><code>idn-use-std3-ascii-rules</code></li>
</ul>
<p><code>family</code>, <code>type</code> and <code>protocol</code> are described above.</p>
<h4 id="recv-fd-bytevector-flags"><code>(recv fd bytevector flags)</code></h4>
<p><code>flags</code> can be <code>#f</code> one or more of the following symbols:</p>
<ul>
<li><code>oob</code></li>
<li><code>peek</code></li>
<li><code>tryhard</code></li>
<li><code>ctrunc</code></li>
<li><code>proxy</code></li>
<li><code>trunc</code></li>
<li><code>dontwait</code></li>
<li><code>eor</code></li>
<li><code>waitall</code></li>
<li><code>fin</code></li>
<li><code>syn</code></li>
<li><code>confirm</code></li>
<li><code>rst</code></li>
<li><code>errqueue</code></li>
<li><code>nosignal</code></li>
<li><code>more</code></li>
<li><code>waitforone</code></li>
<li><code>batch</code></li>
<li><code>fastopen</code></li>
<li><code>cmsg-cloexec</code></li>
</ul>
<p>It will return <code>-1</code> on error and <code>errno</code> is set. Otherwise it return the count bytes read.</p>
<h4 id="recvfrom-fd-bytevector-flags"><code>(recvfrom fd bytevector flags)</code></h4>
<p><code>FLAGS</code> is described above. Return two values. The first value <code>#f</code> in case of error and <code>errno</code> can be used to retrieve the error. Otherwise it return the count bytes read along the address as an association list.</p>
<h4 id="send-fd-bytevector-flags"><code>(send fd bytevector flags)</code></h4>
<p><code>FLAGS</code> is described above. In case of success return the count of bytes sent. Otherwise, it return <code>-1</code> and <code>errno</code> can be used to retrieve the error.</p>
<h4 id="sendto-fd-bytevector-flags-address"><code>(sendto fd bytevector flags address)</code></h4>
<p><code>FLAGS</code> is described above. <code>address</code> must be an association list description of the destination.</p>
<h4 id="accept-sock"><code>(accept sock)</code></h4>
<p>Return the file descriptor of the accepted connection. Otherwise raise an error.</p>
<h4 id="bind-sock-address"><code>(bind sock address)</code></h4>
<h4 id="fcntl-sock-command"><code>(fcntl sock command)</code></h4>
<h4 id="fcntl-sock-command-flags"><code>(fcntl! sock command flags)</code></h4>
<h4 id="setsockopt-socket-level-optname-optval-optlen"><code>(setsockopt socket level optname optval optlen)</code></h4>
<h4 id="listen-sock-backlog"><code>(listen sock backlog)</code></h4>
<h4 id="fd-port-fd"><code>(fd-&gt;port fd)</code></h4>
<p>Return a port based on <code>FD</code>.</p>
