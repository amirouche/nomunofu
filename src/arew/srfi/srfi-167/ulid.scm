;;
;; Universally Unique Lexicographically Sortable Identifier
;;
;; See https://github.com/ulid/spec.
;;
;; The specification prescribe 48 bits of milliseconds since epoch and
;; 80 bits of randomness. This implementation makes the first 16 bits
;; of randomness configureable on thread by thread basis using a
;; parameter called `thread-index`. It allows to reduce fragmentation
;; for writes that happens in the same thread at the same millisecond.
;;
;; That is very likely to happen when the application starts for the
;; first time and the empty object-store must be populated in a batch.
;;
;; When creating a new POSIX thread, the user must set the
;; `thread-index` parameter to a bytevector of length 2 e.g. using
;; (random-bytes 2).
;;
;; AFAIU, it is not useful to share thread-index value across reboots.
;;
(library (arew srfi srfi-167 ulid)

  (export ulid random-bytes)

  (import (arew scheme base)
          (arew scheme bitwise)
          (arew thread)
          (only (rnrs) open-file-input-port file-options)
          (only (chezscheme) current-time time-second time-nanosecond))


(define /dev/urandom (open-file-input-port "/dev/urandom" (file-options) 'none))

;; TODO: move the somewhere else, and rename (random-bytevector length)
(define (random-bytes count)
  "Return a bytevector of length COUNT generated by /dev/urandom"
  (let ((bv (make-bytevector count)))
    (let loop ((index 0))
      (unless (= index count)
        (let ((byte (read-u8 /dev/urandom)))
              (bytevector-u8-set! bv index byte)
              (loop (+ index 1)))))
    bv))

(define (current-milliseconds)
  (let ((now (current-time 'time-utc)))
    (+ (* (time-second now) (expt 10 3))
       (round (/ (time-nanosecond now) (expt 10 6))))))

(define (pack integer)
  "pack INTEGER into a 6 bytes big endian"
  (let* ((count-bytes 6)
         (out (make-bytevector count-bytes)))
    (let loop ((index 0))
      (unless (= index count-bytes)
        (bytevector-u8-set! out
                            index (bitwise-and
                                   (arithmetic-shift integer
                                                     (- (* (- count-bytes index 1) 8)))
                                   #xFF))
        (loop (+ index 1))))
    out))

(define (ulid)
  (let ((epoch (pack (current-milliseconds)))
        (index (thread-index))
        (randomness (random-bytes 8)))
    (bytevector-append epoch index randomness))))
